<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>heros come back</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bondaddy.github.io/"/>
  <updated>2020-01-02T04:05:52.248Z</updated>
  <id>http://bondaddy.github.io/</id>
  
  <author>
    <name>bon爸</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Scala实用指南读书笔记（一）</title>
    <link href="http://bondaddy.github.io/2020/01/02/----81/"/>
    <id>http://bondaddy.github.io/2020/01/02/----81/</id>
    <published>2020-01-01T18:08:48.000Z</published>
    <updated>2020-01-02T04:05:52.248Z</updated>
    
    <content type="html"><![CDATA[<p>第一部分 小试牛刀<br>Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。</p><h1 id="探索scala"><a href="#探索scala" class="headerlink" title="探索scala"></a>探索scala</h1><h2 id="scala的特殊性"><a href="#scala的特殊性" class="headerlink" title="scala的特殊性"></a>scala的特殊性</h2><p>scala的关键特性信息：</p><ul><li>同时支持命令式风格和函数式风格</li><li>纯面向对象</li><li>强制合理的静态类型和类型推断</li><li>简洁而富有表现力</li><li>能和 Java 无缝地互操作</li><li>基于精小的内核构建</li><li>高度的伸缩性，仅用少量代码就可以创建高性能的应用程序</li><li>具有强大、易用的并发模型</li></ul><h2 id="以少胜多"><a href="#以少胜多" class="headerlink" title="以少胜多"></a>以少胜多</h2><p>用更少的代码解决更多的问题 — 简化日常编程<br>筛选出内部最高价格的股票</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span>(<span class="params">year: <span class="type">Int</span>, month: <span class="type">Int</span>, date: <span class="type">Int</span>, closePrice: <span class="type">BigDecimal</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">PrintMax</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getYearEndClosingPrice</span></span>(symbol: <span class="type">String</span>, year: <span class="type">Int</span>): <span class="type">BigDecimal</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">s"https://raw.githubusercontent.com/ReactivePlatform/"</span> +</span><br><span class="line">      <span class="string">s"Pragmatic-Scala-StaticResources/master/src/main/resources/"</span> + <span class="string">s"stocks/daily/daily_<span class="subst">$symbol</span>.csv"</span></span><br><span class="line">    <span class="keyword">val</span> data = io.<span class="type">Source</span>.fromURL(url).mkString</span><br><span class="line">    <span class="keyword">val</span> maxClosePrize = data.split(<span class="string">"\n"</span>)</span><br><span class="line">      .filter(record =&gt; record.startsWith(<span class="string">s"<span class="subst">$year</span>-12"</span>)).map(record =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(timestamp, open, high, low, close, volume) = record.split(<span class="string">","</span>)</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(year, month, date) = timestamp.split(<span class="string">"-"</span>)</span><br><span class="line">      <span class="type">Record</span>(year.toInt, month.toInt, date.toInt, <span class="type">BigDecimal</span>(close.trim))</span><br><span class="line">    &#125;).sortBy(_.date)(<span class="type">Ordering</span>[<span class="type">Int</span>].reverse).take(<span class="number">1</span>)</span><br><span class="line">      .map(_.closePrice)</span><br><span class="line">      .head</span><br><span class="line">    maxClosePrize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> symbols = <span class="type">List</span>(<span class="string">"AMD"</span>, <span class="string">"AAPL"</span>)</span><br><span class="line">    <span class="keyword">val</span> year = <span class="number">2017</span></span><br><span class="line">    <span class="keyword">val</span> (topStock, topPrice) = symbols.par.map &#123; ticker =&gt; (ticker, getYearEndClosingPrice(ticker, year)) &#125;</span><br><span class="line">      .maxBy &#123; stockPrice =&gt; stockPrice._2 &#125;</span><br><span class="line">    printf(<span class="string">s"Top stock of <span class="subst">$year</span> is <span class="subst">$topStock</span> closing at price $$<span class="subst">$topPrice</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个功能强大的专用迭代器— map() 函数和 maxBy()函数。在 Java 中，我们习惯用“方法”这个术语来指代类的成员，而“函 数”这个术语通常用于指代不属于类的过程(procedure)。然而，在 Scala 中这两个术语可交 换使用。</p><p>这两个迭代器分别行使了两种独立的职责。首先，我们使用 map()函数遍历股票代码， 以创建一个由股票代码及其 2017 年收盘价格组成的“对”或“元组”为元素的列表。最终结 果的元组列表形式为 List((股票代码 1，价格 1)，(股票代码 2，价格 2)，…)。</p><a id="more"></a><p>第二个迭代器处理第一个迭代器的结果。maxBy()函数是一个从列表中取出最大值的专 用迭代器。因为该列表中的值是元组(对)，所以我们需要告诉 maxBy()函数如何比较两个 值。在 maxBy()函数附带的代码块中，我们指定了一个包含两个元素的元组，我们感兴趣的 是第二个属性(代码块中的_2)— 价格。</p><p>可视化动作：<br><img src="/images/media/15773763608881/15773793874093.jpg" alt="-w514"></p><p>在这个例子中，我们从 Web 获取每个股票代码的数据，这涉及多次访问网络的调用。假 设网络延迟是d秒，而我们要分析n支股票，那么顺序代码大概需要n × d秒。因为代码中 最大的延迟在于访问网络来获取数据，所以如果我们并行地执行代码以获取不同股票代码的 数据，那么我们可以将时间缩短到大约 d 秒。Scala 使得将顺序代码改成并行模式变得很简单， 只需一个很小的改动:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbols.par.map &#123; ticker =&gt; (ticker, getYearEndClosingPrice(ticker, year)) &#125; .maxBy &#123; stockPrice =&gt; stockPrice._2 &#125;</span><br></pre></td></tr></table></figure><p>插入了对 par 的调用，就是这么简单。这段代码现在已经是在并行地处理每一个股 票代码，而不是顺序迭代。</p><p><strong>强调一下这个例子的一些优点</strong>：</p><ul><li>代码很简洁。我们利用了Scala的许多强大特性，如函数值、(并行)集 合、专用迭代器、不可变值、不可变性和元组等</li><li>函数式风格，具体说来就是函数组合。我们使用 map()方法将股票代码 的列表转换为股票代码及其价格组成的元组的列表。然后我们使用 maxBy()方法将 其转换成所需的值。和使用命令式风格不同，我们将控制逻辑让渡给函数所在的标准 库以完成任务，而不是耗费精力在迭代的控制上。</li><li>无痛地使用并发。没有必要再使用 wait()和 notify()方法或者 synchronized 关键字了。</li></ul><p>更多的优点：</p><ul><li>Java 中的原始类型在 Scala 中被看作对象。例如，2.toString()在 Java 中将产生编译 错误，但在 Scala 中是有效</li><li>Scala 编译成了字节码，这样我们就可以使用运行 Java 程序的方式来运行 Scala 程序，也 可以用脚本的方式运行它。Scala 也可以很好地与 Java 互操作。</li><li>Scala是一门静态类型的编程语言，但与Java不同，它的静态类型更加合理— Scala会 尽可能地使用类型推断。我们可以依靠 Scala 本身来推断出类型，并将结果类型应用到其余 代码中，而不是重复又冗余地指定类型。我们不应该为编译器工作，而应该让编译器为我们 工作。例如，当我们定义var i = 1时，Scala将立即推断出变量i的类型为Int。</li></ul><h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>Scala 本质上是一门混合型编程语言，我们既可以使用命令式风格也可以使用函数式风 格，这是把双刃剑。其优点在于，当使用 Scala 编写代码时，我们可以先使其工作，然后再 做优化。对于刚刚接触函数式编程的程序员，他们可以先用命令式风格写好代码，然后再将 代码重构成函数式风格。</p><p>函数式编程提倡<strong>不可变性</strong>、<strong>高阶函数</strong>和<strong>函数组合</strong>。这些特性合在一起就能使代码简洁、 富有表现力、易于理解和修改。不可变性还有助于减少那些由于状态改变而悄然滋生的错误。</p><p><strong>Java和Scala代码风格对比</strong></p><p>命令式风格的 Java 代码1，用于从给定日期开始的一系列温度中计算出最大值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(List&lt;Integer&gt; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> highTemperature = Integer.MIN_VALUE; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temperature : temperatures) &#123;</span><br><span class="line">        highTemperature = Math.max(highTemperature, temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> highTemperature; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala 也支持命令式风格，下面是 Scala 版本的代码:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMax</span></span>(temperatures: <span class="type">List</span>[<span class="type">Int</span>]) = &#123; </span><br><span class="line">    <span class="keyword">var</span> highTemperature = <span class="type">Integer</span>.<span class="type">MIN_VALUE</span> </span><br><span class="line">    <span class="keyword">for</span> (temperature &lt;- temperatures) &#123;</span><br><span class="line">        highTemperature = <span class="type">Math</span>.max(highTemperature, temperature) </span><br><span class="line">    &#125;</span><br><span class="line">    highTemperature </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建了可变变量 highTemperature，并在循环中持续修改它。我们必须确保正确 地初始化可变变量，并在正确的地方把它们修改为正确的值。</p><p>函数式编程是一种声明式风格，我们只要指定做什么而不用指定如何去做。XSLT、规则 引擎和 ANTLR 这些工具都普遍使用声明式风格。让我们把前面的代码用不带可变参数的函 数式风格重写一下。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMax</span></span>(temperatures: <span class="type">List</span>[<span class="type">Int</span>]) = &#123; </span><br><span class="line">    temperatures.foldLeft(<span class="type">Integer</span>.<span class="type">MIN_VALUE</span>) &#123; <span class="type">Math</span>.max &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="体验-Scala"><a href="#体验-Scala" class="headerlink" title="体验 Scala"></a>体验 Scala</h1><h2 id="使用-REPL"><a href="#使用-REPL" class="headerlink" title="使用 REPL"></a>使用 REPL</h2><p>相当多的编程语言都提供了REPL(read-eval-print loop)工具，使用REPL可以便捷地 键入代码片段，并以交互方式立即看到代码运行结果。除了执行代码片段外，REPL 往往还 提供一些在运行时不方便获取的细节。这使得 REPL 成为一个特殊工具，可以用来做试验， 也可以用来学习 Scala 推断变量或函数类型的方法。</p><p>要启动 REPL，应在命令行(在终端窗口或命令提示符下)键入 scala。启动后会打印 出一些介绍信息，紧跟着一个提示符:</p><h2 id="命令行上的-Scala"><a href="#命令行上的-Scala" class="headerlink" title="命令行上的 Scala"></a>命令行上的 Scala</h2><p>和Java最大的差异，直接写代码就可以得到最终的反馈结果，而不需要像java一样必须使用 main()方法的 Main 类</p><h2 id="以独立脚本方式运行-Scala-代码"><a href="#以独立脚本方式运行-Scala-代码" class="headerlink" title="以独立脚本方式运行 Scala 代码"></a>以独立脚本方式运行 Scala 代码</h2><h3 id="在类-Unix-系统上以独立脚本方式运行"><a href="#在类-Unix-系统上以独立脚本方式运行" class="headerlink" title="在类 Unix 系统上以独立脚本方式运行"></a>在类 Unix 系统上以独立脚本方式运行</h3><p>在类 Unix 系统上，在脚本中设置 shebang 前缀如下。键入并运行chmod + x hello.sh以确保文件hello.sh具有可执行权限，然后在 命令行上键入如下命令以运行:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env </span></span><br><span class="line">scala println(<span class="string">"Hello "</span> + args(0))</span><br></pre></td></tr></table></figure><p>./hello.sh Buddy<br>Buddy 是传递给脚本的参数。下面是运行结果: Hello Buddy</p><h3 id="在-Windows-上以独立脚本方式运行"><a href="#在-Windows-上以独立脚本方式运行" class="headerlink" title="在 Windows 上以独立脚本方式运行"></a>在 Windows 上以独立脚本方式运行</h3><p>忽略不计，不在windows上进行代码操作</p><h3 id="Scala-的-IDE-支持"><a href="#Scala-的-IDE-支持" class="headerlink" title="Scala 的 IDE 支持"></a>Scala 的 IDE 支持</h3><p>根据Intellij Idea 配置</p><h4 id="Maven依赖配置"><a href="#Maven依赖配置" class="headerlink" title="Maven依赖配置"></a>Maven依赖配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-actors<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-scala-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Maven打包插件配置"><a href="#Maven打包插件配置" class="headerlink" title="Maven打包插件配置"></a>Maven打包插件配置</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;!-- 这是个编译java代码的 --&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span>&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">        &lt;encoding&gt;<span class="type">UTF</span><span class="number">-8</span>&lt;/encoding&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;!-- 这是个编译scala代码的 --&gt;</span><br><span class="line">    &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;scala-compile-first&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;process-resources&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;add-source&lt;/goal&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;mainClass&gt;pro.simba.<span class="type">Main</span>&lt;/mainClass&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-<span class="keyword">with</span>-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;<span class="keyword">package</span>&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure><h4 id="编译sdk配置"><a href="#编译sdk配置" class="headerlink" title="编译sdk配置"></a>编译sdk配置</h4><p><img src="/images/media/15773763608881/15774317263759.jpg" alt=""></p><h1 id="从-Java-到-Scala"><a href="#从-Java-到-Scala" class="headerlink" title="从 Java 到 Scala"></a>从 Java 到 Scala</h1><p>你可以在使用 Scala 的同时运用自己的 Java 技能。在某些方面 Scala 与 Java 类似，但在 许多其他方面又彼此不同。Scala 青睐纯面向对象，但它又尽可能将类型和 Java 的类型对应 起来。Scala 在支持熟悉的命令式编程风格的同时，也支持函数式编程风格。因此，你可以使 用最熟悉的风格立即开始编程，而不用承受陡峭的学习曲线。</p><h2 id="Scala-简洁的-Java"><a href="#Scala-简洁的-Java" class="headerlink" title="Scala:简洁的 Java"></a>Scala:简洁的 Java</h2><p>Java代码中通常充斥着很多样板代码— getter、setter、访问修饰符、处理受检异常的代 码等。这些样板还在不断增多，使代码不断膨胀。在后面我们会了解到，Scala 编译器做了一 些额外的工作，这样就不用耗费精力编写并维护那些本可以生成的代码上了。</p><h3 id="减少样板代码"><a href="#减少样板代码" class="headerlink" title="减少样板代码"></a>减少样板代码</h3><p>Scala 具有非常高的代码密度— 输入少量代码就可以完成许多功能。作为对比，我们来 看一个 Java 代码的例子。例如：字符串插值(语法形如 s”…${expression}…”)，避免了Java的拼凑字符串。</p><h3 id="更多便利特性"><a href="#更多便利特性" class="headerlink" title="更多便利特性"></a>更多便利特性</h3><p>使用 val 或 var 定义变量。使用 val 定 义的变量是不可变的，即初始化后不能更改。然而，那些使用 var 定义(不推荐使用)的变 量是可变的，可以被改任意次。</p><p>scala中 ，循环所使用的 to()是一个方法，这一点很容易被忽略。to()方法和 until()方法实际上都是 RichInt 上的方法— 我们将在 3.2 节中讨论富封装器(rich wrapper)。变量 i 的类型为 Int， 被隐式转换为 RichInt，因此在这个变量上可以调用这个方法。这两个方法都返回 Range 的实例。因此，1 to 3等价于1.to(3)，但是前者更优雅。</p><h3 id="转向函数式风格"><a href="#转向函数式风格" class="headerlink" title="转向函数式风格"></a>转向函数式风格</h3><p>使用偏向函数式风格的 foreach()方法来实现循环：<code>(1 to 3).foreach(i =&gt; print(s&quot;$i,&quot;))</code><br>上面这个例子很简洁，且没有赋值操作。我们使用了 Range 类的 foreach()方法。这 个方法接受函数值作为参数。所以，在括号中，我们提供了一个接受一个参数的代码主体， 在这个例子中参数为 i。=&gt;符号将左侧的参数列表与右侧的实现分开。</p><h2 id="Java-原始类型对应的-Scala-类"><a href="#Java-原始类型对应的-Scala-类" class="headerlink" title="Java 原始类型对应的 Scala 类"></a>Java 原始类型对应的 Scala 类</h2><p>Java 的世界观是分裂的— 其原始类型(如 int 和 double)和对象截然不同。从 Java 5 开始，利用自动装箱(autoboxing)机制，可以将原始类型视为对象。然而，Java 的原始类 型不允许方法调用，如 2.toString()。另外，自动装箱还涉及类型转换的开销，会带来一 些负面的影响。<br>和 Java 不同，Scala 将所有的类型都视为对象。这就意味着，和调用对象上的方法一样， 也可以在字面量上进行方法调用。在下面的代码中，我们创建了一个 Scala 中的 Int 的实例， 并将它传给 java.util.ArrayList 的 ensureCapacity()方法，其参数类型为 Java 的 原始类型 int。</p><h2 id="元组和多重赋值"><a href="#元组和多重赋值" class="headerlink" title="元组和多重赋值"></a>元组和多重赋值</h2><p>在 Java 中，方法可以接受多个参数，但是只能返回一个结果。在 Java 中返回多个结果 需要使用拙劣的变通方案。例如，为了返回用户的姓、名和电子邮箱地址，我们不得不引入 Person 类，或者返回一个 String 数组或一个 ArrayList。Scala 的元组，与多重赋值(multiple assignment)结合，可以将返回多个值变成小菜一碟。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPersonInfo</span></span>(primaryKey: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="comment">// 假定primaryKey是用来获取用户信息的主键</span></span><br><span class="line">    <span class="comment">// 这里响应体是固定的</span></span><br><span class="line">    (<span class="string">"Venkat"</span>, <span class="string">"Subramaniam"</span>, <span class="string">"venkats@agiledeveloper.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> (firstName, lastName, emailAddress) = getPersonInfo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p> 除了直接赋值，还可以直接访问元组中的单个元素。例如，如果运行 val info = getPersonInfo(1)，那么随后就可以采用 info._1 这种语法形式访问其中的第一个元 素，第二个元素则是 info._2，以此类推。</p><h2 id="灵活的参数和参数值"><a href="#灵活的参数和参数值" class="headerlink" title="灵活的参数和参数值"></a>灵活的参数和参数值</h2><p>参数的定义和参数值的传递在任何编程语言中都是最常见的编程任务。Scala 提供了一些 便利的特性来定义变长参数、声明参数的默认值以及定义命名参数。</p><h3 id="传递变长参数值"><a href="#传递变长参数值" class="headerlink" title="传递变长参数值"></a>传递变长参数值</h3><p><strong>只有最后一个 参数可以接受变长参数值</strong>。我们可以在最后一个参数类型后面<strong>加上星号</strong>，以表明该参数 (parameter)可以接受可变长度的参数值(argument)。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(values: <span class="type">Int</span>*) = values.foldLeft(values(<span class="number">0</span>)) &#123; <span class="type">Math</span>.max &#125;</span><br></pre></td></tr></table></figure><h3 id="为参数提供默认值"><a href="#为参数提供默认值" class="headerlink" title="为参数提供默认值"></a>为参数提供默认值</h3><p>使用参数默认值的例子</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span></span>(destination: <span class="type">String</span> = <span class="string">"head office"</span>, mailClass: <span class="type">String</span> = <span class="string">"first"</span>): <span class="type">Unit</span> = println(<span class="string">s"sending to <span class="subst">$destination</span> by <span class="subst">$mailClass</span> class"</span>)</span><br></pre></td></tr></table></figure><p>调用 mail()方法的几个样例</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail(<span class="string">"Houston office"</span>, <span class="string">"Priority"</span>) </span><br><span class="line">mail(<span class="string">"Boston office"</span>)</span><br><span class="line">mail()</span><br></pre></td></tr></table></figure><p>为省略的参数补上默认值这个操作是在编译时完成的。不过在重载方法的时候，需要特 别小心。如果一个方法在基类中用了一个默认值，而在其派生类的相应重载方法中却使用了 另一个默认值，就会让人感到困惑，到底选用哪个默认值。对于多参数的方法，如果对于其中一个参数，你选择使用它的默认值，你就不得不让这 个参数后面的所有参数都使用默认值。</p><h3 id="使用命名参数"><a href="#使用命名参数" class="headerlink" title="使用命名参数"></a>使用命名参数</h3><p>使用命名参数时，必须注意以下几点:</p><ul><li>对于所有没有默认值的参数，必须要提供参数的值。</li><li>对于那些有默认值的参数，可以选择性地使用命名参数传值。</li><li>一个参数最多只能传值一次。</li><li>在重载基类的方法时，应该保持参数名字的一致性。如果不这样做，编译器就会优先使用基类中的参数名，就可能会违背最初的目的。</li><li>如果有多个重载的方法，它们的参数名一样，但是参数类型不同，那么函数调用就很有可能产生歧义。在这种情况下，编译器会严格报错，就不得不切换回基于位置的参数形式。</li></ul><p>调用方式：<code>mail(mailClass = &quot;Priority&quot;)</code></p><h2 id="隐式参数"><a href="#隐式参数" class="headerlink" title="隐式参数"></a>隐式参数</h2><p>函数的定义者首先需要把参数标记为 implicit。针对这种场景，Scala 要求我们把隐式 参数放在一个单独的参数列表而非常规的参数列表中(6.4 节将详细介绍 Scala 支持多参数列 表)。如果一个参数被定义为 implicit，那么就像有默认值的参数，该参数的值传递是可然而，如果没有传值，Scala 会在调用的作用域中寻找一个隐式变量。这个隐式变量必 须和相应的隐式参数具有相同的类型，因此，在一个作用域中每一种类型都最多只能有一个 隐式变量。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wifi</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectToNetwork</span></span>(user: <span class="type">String</span>)(<span class="keyword">implicit</span> wifi: <span class="type">Wifi</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s"User: <span class="subst">$user</span> connected to WIFI <span class="subst">$wifi</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atOffice</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"--- at the office ---"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">officeNetwork</span></span>: <span class="type">Wifi</span> = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"office-network"</span>)</span><br><span class="line">  <span class="keyword">val</span> cafeteriaNetwork = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"cafe-connect"</span>)</span><br><span class="line">  connectToNetwork(<span class="string">"guest"</span>)(cafeteriaNetwork) </span><br><span class="line">  connectToNetwork (<span class="string">"Jill Coder"</span>) </span><br><span class="line">  connectToNetwork (<span class="string">"Joe Hacker"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atJoesHome</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"--- at Joe's home ---"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">homeNetwork</span></span>: <span class="type">Wifi</span> = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"home-network"</span>)</span><br><span class="line">  connectToNetwork(<span class="string">"guest"</span>)(homeNetwork)</span><br><span class="line">  connectToNetwork(<span class="string">"Joe Hacker"</span>)</span><br><span class="line">&#125;</span><br><span class="line">atOffice() </span><br><span class="line">atJoesHome()</span><br></pre></td></tr></table></figure><p>connectToNetwork()函数拥有两个参数列表，一个是类型为 String 的常规参数， 另一个是类型为 Wifi 的隐式参数。</p><p>在 atOffice()函数中，我们定义了 Wifi 类的两个实例，并将其中一个标记为 implicit。我们调用了 connectToNetwork()方法 3 次，但只在第一次调用时为参数 wifi 提供了值。其他两次调用编译器都会自动填入参数的值。如果参数有一个默认值，那么编译 器会在函数的定义中寻找该值。然而，因为这里的参数 wifi 是隐式参数，所以编译器会在 这个函数调用的作用域中寻找定义为 implicit 的值。</p><p>在 atJoesHome()函数中，我们只定义了一个 Wifi 实例，并标记为 implicit。给connectToNetwork()方法传递参数是可选的。例如，客人可能想要知道自己连接到了哪个网络，但是这个网络很有可能就是常驻者日常隐式使用的 。在这种情况下，显式指定一个隐式定义的参数是正确的。</p><p> 运行这段脚本可以观察到如下输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- at the office ---</span><br><span class="line">User: guest connected to WIFI cafe-connect</span><br><span class="line">User: Jill Coder connected to WIFI office-network </span><br><span class="line">User: Joe Hacker connected to WIFI office-network</span><br><span class="line">--- at Joe&#39;s home ---</span><br><span class="line">User: guest connected to WIFI home-network</span><br><span class="line">User: Joe Hacker connected to WIFI home-network</span><br></pre></td></tr></table></figure><p>输出结果表明，在省略参数值时，相应作用域中的隐式变量就会被使用。尽管在不同的 函数中调用的是同一个函数，但是所传入的被省去的参数却不是同一个。虽然参数默认值和 隐式参数都可以让调用者省去参数，但是编译器绑定到参数的值却完全不同。</p><h2 id="字符串和多行原始字符串"><a href="#字符串和多行原始字符串" class="headerlink" title="字符串和多行原始字符串"></a>字符串和多行原始字符串</h2><p>在 Scala 中创建一个跨行的字符串非常简单，完全不需要用乱七八糟的+=，只要将多行的 字符串放在一对 3 个双引号之中(“””…”””)就可以了。这是 Scala 对所谓的 here 文档2(或 heredoc)的支持。我们创建一个跨行的字符串来举例说明。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">""</span><span class="string">"In his famous inaugural speech, John F. Kennedy said</span></span><br><span class="line"><span class="string">"</span><span class="type">And</span> so, my fellow <span class="type">Americans</span>: ask not what your country can do <span class="keyword">for</span> you-ask what you can do <span class="keyword">for</span> your country.<span class="string">"</span></span><br><span class="line"><span class="string">He then proceeded to speak to the citizens of the World..."</span><span class="string">""</span></span><br><span class="line">println(str)</span><br></pre></td></tr></table></figure><h2 id="字符串插值"><a href="#字符串插值" class="headerlink" title="字符串插值"></a>字符串插值</h2><p>在 Java 中以输出或者消息的形式创建一个字符串非常混乱。例如，要创建一条这样的消 息”A discount of 10% has been applied”，其中的数值10来自一个名为discount 的变量，就十分费力。我们可以这样写:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = <span class="string">"A discount of "</span> + discount + <span class="string">"% has been applied"</span>;</span><br></pre></td></tr></table></figure><p>同样烦琐。Scala 提供了简洁而流畅的语法，使用表达式来创建字符串字面量。下面 是在 Scala 中用于创建所需要的消息的等价方式:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message = <span class="string">s"A discount of <span class="subst">$discount</span>% has been applied"</span></span><br></pre></td></tr></table></figure><p>字符串字面量中可以有零个或者多个内嵌表达式。如果表达式是最简单的一个变量，那 么在它的前面加上美元符号($)。而对于更复杂的表达式，可以把它们放在大括号中，如下 例所示:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">90</span></span><br><span class="line"><span class="keyword">val</span> totalPrice = <span class="string">s"The amount of discount is <span class="subst">$&#123;price * discount / 100&#125;</span> dollars"</span></span><br></pre></td></tr></table></figure><h2 id="合理的约定"><a href="#合理的约定" class="headerlink" title="合理的约定"></a>合理的约定</h2><p>Scala 中有一些约定，可以让代码简洁且易于阅读、编写。下面是这些特性的示例。</p><ul><li>支持脚本。不是所有的代码都需要放在一个类中。如果一个脚本就能满足需求，就直 接将可执行的代码放在一个文件中，没有必要都堆在一个类中。</li><li>return 是可选的。假定最后一个求值的表达式能够匹配方法所声明的返回类型，那 么这个表达式的求值结果将会自动作为方法调用的结果值返回。无须加入显式的 return 语句可以简化代码，尤其是在将一个闭包传递为方法参数时。</li><li>分号是可选的。不需要使用分号来标识每一个语句或者表达式的结束(参见 3.10.3 节)这个特性能够去除代码中的噪声。如果要多个语句放在同一行上面，可以使用分 号来分隔。没有分号，Scala 也能智能地推断出一个语句或者表达式是否是完整的， 如果不是，那么 Scala 将会接着在下一行读取剩余的代码。</li><li>类和方法默认就是公开的，所以你无须显式使用 public 关键字。</li><li>Scala 提供轻便的语法以创建 JavaBeans— 它用很少的代码就能创建变量和不可变的属性(参见 4.1.2 节)。</li><li>对于我们不关心的那些异常，Scala不会强制要求进行捕获(参见10.1节)，这样做能够缩减代码体积，同时也能够避免不合理的异常处理。</li><li>括号和点号也是可选的，我们在 3.1.2 节讨论过。</li></ul><p>除此之外，Scala 默认会导入两个包、scala.Predef 对象以及它们相应的类和成员。 只用类名就可以从这些预导入的包中引用相应的类。Scala 按照顺序导入下面的包和类:</p><ul><li>java.lang</li><li>scala</li><li>scala.Predef</li></ul><h2 id="操作符重载"><a href="#操作符重载" class="headerlink" title="操作符重载"></a>操作符重载</h2><p>不常用，不实际 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">val real: <span class="type">Int</span>, val imaginary: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">    println(<span class="string">"Calling +"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Complex</span>(real + operand.real, imaginary + operand.imaginary)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">    println(<span class="string">"Calling *"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Complex</span>(</span><br><span class="line">      real * operand.real - imaginary * operand.imaginary,</span><br><span class="line">      real * operand.imaginary + imaginary * operand.real)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sign = <span class="keyword">if</span> (imaginary &lt; <span class="number">0</span>) <span class="string">""</span> <span class="keyword">else</span> <span class="string">"+"</span></span><br><span class="line">    <span class="string">s"<span class="subst">$real</span><span class="subst">$sign</span><span class="subst">$&#123;imaginary&#125;</span>i"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line"><span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">2</span>, - <span class="number">3</span>) </span><br><span class="line"><span class="keyword">val</span> c3 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">2</span>, <span class="number">2</span>) </span><br><span class="line">println (c1 + c2 * c3)</span><br></pre></td></tr></table></figure><h2 id="Scala-与-Java-的差异"><a href="#Scala-与-Java-的差异" class="headerlink" title="Scala 与 Java 的差异"></a>Scala 与 Java 的差异</h2><p>在你开始感受到 Scala 设计上的优雅和简洁时，你也应该注意到一些细微差别。例如， 在处理赋值、等价性检查、函数返回值的时候，Scala 和 Java 有语义上的不同。因为这些特 性的处理与我们在 Java 中已经习惯的方式有显著的不同，很容易犯错。请花一点时间了解它 们以避免各种“惊喜”。</p><h3 id="赋值的结果"><a href="#赋值的结果" class="headerlink" title="赋值的结果"></a>赋值的结果</h3><p>在Java中，赋值操作(像a = b)的值就是a的值，因此像x = a = b这样的多重 赋值就可以出现，但是在 Scala 中不能这样做。在 Scala 中赋值操作的结果值是一个 Unit— 大概等价于一个 Void。从结果上讲，将这种值赋值给另外一个变量有可能造成类型不匹配。 看一看下面这个例子。</p><h3 id="Scala-的"><a href="#Scala-的" class="headerlink" title="Scala 的=="></a>Scala 的==</h3><p>对于基于值的比较，在 Scala 中，可以使用简洁的==而不是 equals()方法。如果要对 引用做基于身份1的比较，那么可以使用 Scala 中的 eq()方法。</p><h3 id="可有可无的分号"><a href="#可有可无的分号" class="headerlink" title="可有可无的分号"></a>可有可无的分号</h3><p>在涉及语句或者表达式的终止时，Scala 很厚道— 分号(;)是可选的，这就能够减少 代码中的噪声。我们可以在语句或者表达式的末尾放置一个分号，特别是，如果想要在同一 行上放置多个语句或者表达式的话，但一定要小心。在同一行上写多个语句或者表达式可能 会降低代码的可读性，就像下面这个例子:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sample = <span class="keyword">new</span> <span class="type">Sample</span>;</span><br><span class="line">println(sample)</span><br></pre></td></tr></table></figure><p>如果一行的末尾没有以一个中缀标记1(如+、*、. )结尾，且不在括号或者方括号中， 那么 Scala 会自动补上分号。如果下一行的起始处能够开始一个语句或者表达式，那么这一 行的末尾也会自动补上分号。</p><h3 id="避免显式-return"><a href="#避免显式-return" class="headerlink" title="避免显式 return"></a>避免显式 return</h3><p>使用 return 语句从方法返回结果，而这在 Scala 中却不是一个好的实 践。return 语句在 Scala 中是隐式的，显式地放置一个 return 命令会影响 Scala 推断返回 类型的能力。</p><h2 id="默认访问修饰符"><a href="#默认访问修饰符" class="headerlink" title="默认访问修饰符"></a>默认访问修饰符</h2><p>Scala 的访问修饰符(access modifier)和 Java 有如下不同点: </p><ul><li>如果不指定任何访问修饰符，那么 Java 会默认为包内部可见，而 Scala 则默认为公开。</li><li>Java 主张全有或全无，也就是说，对当前包的所有类可见或者对所有都不可见。而Scala 对可见性的控制是细粒度的。</li><li>Java 的 protected 是宽泛的，其作用域包括在任意包中的派生类和当前包中的任意类，而 Scala 的 protected 与 C++和 C#的类似，只有派生类能够访问。然而，在Scala 中 protected 还有相当自由和灵活的用法。</li><li>Java 的封装是类级别的。可以在一个类的实例方法中访问该类的任何实例的所有私有字段和方法，在 Scala 中也一样，不过，在 Scala 中也可以进行定制，让其只能在当 前的实例方法中访问，这样就和 Ruby 比较像了。</li></ul><h3 id="定制访问修饰"><a href="#定制访问修饰" class="headerlink" title="定制访问修饰"></a>定制访问修饰</h3><p>在不使用任何访问修饰符的情况下，Scala 默认认为类、字段和方法都是公开的。如 果想将一个成员标记为 private 或者 protected，只要像下面这样用相应的关键字标 记即可。</p><h3 id="Scala-的-protected"><a href="#Scala-的-protected" class="headerlink" title="Scala 的 protected"></a>Scala 的 protected</h3><p>在 Scala 中，protected 让所修饰的成员仅对自己和派生类可见。对于其他类来说，即 使正好和所定义这个类处于同一个包中，也无法访问这些成员。更进一步，派生类在访问 protected 成员的时候，成员的类型也需要一致。让我们用下面的例子做检验。</p><h3 id="细粒度的访问控制"><a href="#细粒度的访问控制" class="headerlink" title="细粒度的访问控制"></a>细粒度的访问控制</h3><p>可以为 private 和 protected 修饰符指定额外的参数。故而，除了简单地将一个成员 标记为 private，还可以标记为 private[AccessQualifier]，其中 AccessQualifier 可以是任何封闭类名、一个封闭的包名或者是 this(即实例级别的可见性)。</p><p>访问修饰符上的限定词告诉 Scala，对于所有类该成员都是私有的，除了以下情况。</p><ul><li>如果没有指定 AccessQualifier(在默认情况下)，那么该成员只能在当前类或者 其伴生对象中访问(第 4 章中将讨论伴生对象)。</li><li>如果 AccessQualifier 是一个类名，那么该成员可以在当前类、伴生对象以及 AccessQualifier 对应的封闭类和其伴生对象中可访问。</li><li>如果 AccessQualifier 是一个封闭的包名，那么该成员可以在当前类、伴生对象 以及所提到的包下面的所有类中访问。</li><li>如果 AccessQualifier 是 this，那么将会限制该成员只能在该实例中访问，对 于同一个类的其他实例，也是不可见的，这是所有选项中限制最严格的。</li></ul><h1 id="处理对象"><a href="#处理对象" class="headerlink" title="处理对象"></a>处理对象</h1><p>我们将从最熟悉的基础开始，快速深入 Scala 面向对象的方方面面。让我们把一个简单 的 Java 类移植到 Scala，然后再深入研究 Scala 的能力。首先构造器就很有意思，因为 Scala 代码往往会比 Java 代码更加简洁，然后我们会见到 Scala 为对象的创建提供的便利。</p><h2 id="创建并使用类"><a href="#创建并使用类" class="headerlink" title="创建并使用类"></a>创建并使用类</h2><p>在 Scala 中创建类表意清晰且高度简洁。我们先探索如何创建实例，然后探索如何创建 类，最后才是如何定义字段和方法。</p><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>在 Scala 中创建类的实例和在 Java 中创建实例差不太多。例如，我们创建 StringBuilder 的一个实例:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringBuilder</span>(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure><h3 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h3><p>在 Java 的版本中，我们为属性 year 显式定义了字段和方法，并显式定义了构造器。而 在 Scala 中，类构造器(我们非正式地用其指代类)的参数定义了字段，并自动生成了访问 器方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> milesDriven: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">miles</span></span>: <span class="type">Int</span> = milesDriven</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">drive</span></span>(distance: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    milesDriven += <span class="type">Math</span>.abs(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="定义字段、方法和构造器"><a href="#定义字段、方法和构造器" class="headerlink" title="定义字段、方法和构造器"></a>定义字段、方法和构造器</h3><p>如果类定义没有主体，就没有必要使用大括号({})。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val number: <span class="type">Int</span>, var creditLimit: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure><p>除了用主构造器参数声明的字段，还可以定义其他字段、方法和辅助构造器(auxiliary constructor)。在下面的代码中，this()方法就是一个辅助构造器。另外，我们定义了变量 position 并且重载了 toString()方法。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val firstName: <span class="type">String</span>, val lastName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> position: <span class="type">String</span> = _</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$toString</span>"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>, positionHeld: <span class="type">String</span>) &#123; <span class="keyword">this</span>(firstName, lastName)</span><br><span class="line">    position = positionHeld</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;<span class="string">s"<span class="subst">$firstName</span> <span class="subst">$lastName</span> holds <span class="subst">$position</span> position"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与类定义结合的主构造器接收两个参数，即 firstName 和 lastName。如果需要，可 以很容易就把主构造器设置为 private，详见 4.6.2 节。<br>除了主构造器，我们还有一个辅助构造器，使用名为 this()的方法定义。它接收 3 个 参数:前两个和主构造器相同，第三个是 positionHeld。在辅助构造器中，我们调用主构 造器来初始化与名字相关的字段。Scala 强制规定:辅助构造器的第一行有效语句必须调用主 构造器或者其他辅助构造器。</p><h2 id="遵循-JavaBean-惯例"><a href="#遵循-JavaBean-惯例" class="headerlink" title="遵循 JavaBean 惯例"></a>遵循 JavaBean 惯例</h2><p>大部分 Java 框架已经认定了 JavaBean 惯例，不遵循该惯例会 让我们在那些框架中使用 Scala 类非常困难。别着急，用一个注解就能轻松解决这个问题。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dude</span>(<span class="params">@<span class="type">BeanProperty</span> val firstName: <span class="type">String</span>, val lastName: <span class="type">String</span></span>) </span>&#123; </span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> position: <span class="type">String</span> = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用该注解，我们让 Scala 创建了访问器方法 getFirstName()、getPosition()和 setPosition()，还有两个参数和一个声明字段上的 Scala 风格的访问器。因为我们没有用 该注解标记参数 lastName，所以 Scala 不会为它生成 JavaBean 风格的访问器。</p><h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>Cop 就能概括这一切，也更容易输入。下面演示了如何给 PoliceOfficer 取别名，且不失其身份。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoliceOfficer</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">CopApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Cop</span> </span>= <span class="type">PoliceOfficer</span></span><br><span class="line">  <span class="keyword">val</span> topCop = <span class="keyword">new</span> <span class="type">Cop</span>(<span class="string">"Jack"</span>)</span><br><span class="line">  println(topCop.getClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Scala 标准库中很多类都取了别名。有时候别名是为了使用更合适的名字，有时候是为了 在指定包中引用某些类。例如，Set 就是一个别名，它指向 immutable 包中的 Set 版本， 而不是 mutable 包中的版本。</p><h2 id="扩展一个类"><a href="#扩展一个类" class="headerlink" title="扩展一个类"></a>扩展一个类</h2><p>在 Scala 中扩展一个基类和 Java 中很像，只是多了两个非常好的限制:其一，方法的重 载必须用 override 关键字;其二，只有主构造器能传递参数给基类的构造器。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>(<span class="params">val id: <span class="type">Int</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"ID: <span class="subst">$id</span> Year: <span class="subst">$year</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">override val id: <span class="type">Int</span>, override val year: <span class="type">Int</span>, var fuelLevel: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Vehicle</span>(<span class="params">id, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"<span class="subst">$&#123;super.toString&#125;</span> Fuel Level: <span class="subst">$fuelLevel</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> car = <span class="keyword">new</span> <span class="type">Car</span>(<span class="number">1</span>, <span class="number">2015</span>, <span class="number">100</span>)</span><br><span class="line">println(car)</span><br></pre></td></tr></table></figure><h2 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h2><p>在 Scala 中，可以创建单独的函数，也可以创建参数化的函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>[<span class="type">T</span>](input1: <span class="type">T</span>, input2: <span class="type">T</span>): <span class="type">Unit</span> = println(<span class="string">s"got <span class="subst">$input1</span> (<span class="subst">$&#123;input1.getClass&#125;</span>) <span class="subst">$input2</span> (<span class="subst">$&#123;input2.getClass&#125;</span>)"</span>)</span><br></pre></td></tr></table></figure><p>没有将 echo()函数的参数类型指定为 Int 或者 String 这样的具体类型，而是将 它们开放为参数化类型 T，留给程序员去决定(具体类型)。记号[T]告诉编译器后面提到的 类型 T 其实不是一个已经存在的命名风格糟糕的单字母类，而是一个参数化类型。</p><p>可以像调用别的函数一样调用这个函数，但是参数的类型必须在调用时决定。我们使用 两种不同类型的参数来调用 echo()函数。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">"hello"</span>, <span class="string">"there"</span>) </span><br><span class="line">echo(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>创建一个参数化类和创建参数化函数一样简单。我们创建了一个类 Message，并延迟定义其字段的类型。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>[<span class="type">T</span>](<span class="params">val content: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"message content is <span class="subst">$content</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(value: <span class="type">T</span>): <span class="type">Boolean</span> = value == content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字段 content 的类型被参数化了，其类型会在类创建实例的时候决定。is()方法的参 数类型也是如此。和单独的函数不同，我们不需要在 is()方法的定义中放[T]标记。如果这 个方法接受的参数类型不是类层面指定的参数化类型 T，基于同样的理由，我们就必须和前 面提到的一样使用那个标记。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message1: <span class="type">Message</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Message</span>(<span class="string">"howdy"</span>) </span><br><span class="line"><span class="keyword">val</span> message2 = <span class="keyword">new</span> <span class="type">Message</span>(<span class="number">42</span>)</span><br><span class="line">println(message1) </span><br><span class="line">println(message1.is(<span class="string">"howdy"</span>)) </span><br><span class="line">println(message1.is(<span class="string">"hi"</span>)) </span><br><span class="line">println(message2.is(<span class="number">22</span>))</span><br></pre></td></tr></table></figure><p>在 Java 中，<strong>尖括号(&lt;&gt;)被用于指定泛型。在 Scala 中我们使用方括号([])来替代</strong> 。然而，这不是唯一的差异。在 Java 中类型擦除会让范式变得相当脆弱，Scala 在参数化类型 上会做更加严谨的类型检查— 我们会在 5.1.2 节中看到这些内容。而且，我们可以在参数化 类型上加限制— 我们将会在 5.4 节中探索这个话题。</p><h2 id="单例对象和伴生对象"><a href="#单例对象和伴生对象" class="headerlink" title="单例对象和伴生对象"></a>单例对象和伴生对象</h2><p>在处理 static 字段和方法时，Scala 和 Java 有显著不同。此外，Scala 直接支持单例对 象。我们来探索一下单例对象和伴生对象，以及 Scala 对 static 的处理方法。</p><h3 id="单例对象"><a href="#单例对象" class="headerlink" title="单例对象"></a>单例对象</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span>(<span class="params">val color: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$&#123;this&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"marker color <span class="subst">$color</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MarkerFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> markers = mutable.<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"red"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"red"</span>), <span class="string">"blue"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"blue"</span>), <span class="string">"yellow"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"yellow"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMarker</span></span>(color: <span class="type">String</span>): <span class="type">Marker</span> = markers.getOrElseUpdate(color, <span class="keyword">new</span> <span class="type">Marker</span>(color))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="独立对象和伴生对象"><a href="#独立对象和伴生对象" class="headerlink" title="独立对象和伴生对象"></a>独立对象和伴生对象</h3><p>选择将一个单例关联到一个类。这样的单例，其名字和对应类的名字一致，因此被 称为伴生对象(companion object)。相应的类被称为伴生类。我们在后面可以看到这种方式 非常强大。</p><p>在前面的例子中，我们想规范 Marker 实例的创建。类与其伴生对象间没有边界— 它 们可以相互访问私有字段和方法。一个类的构造器，包括主构造器，也可以标记为 private。 我们可以结合这两个特性来解决前一节末尾特别提出的问题。下面是使用一个伴生对象对 Marker 这个例子进行的重写。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> <span class="title">private</span>(<span class="params">val color: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$&#123;this&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"marker color <span class="subst">$color</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Marker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> markers = mutable.<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"red"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"red"</span>), <span class="string">"blue"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"blue"</span>), <span class="string">"yellow"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"yellow"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMarker</span></span>(color: <span class="type">String</span>): <span class="type">Marker</span> = markers.getOrElseUpdate(color, <span class="keyword">new</span> <span class="type">Marker</span>(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Marker 的构造器被声明为 private;然而，它的伴生对象可以访问它。因此，我们可 以在伴生对象中创建 Marker 的实例。如果试着在类或者伴生对象之外创建 Marker 的实例， 就会收到错误提示。</p><h3 id="Scala-中的-static"><a href="#Scala-中的-static" class="headerlink" title="Scala 中的 static"></a>Scala 中的 static</h3><p> 在 Scala 的未来版本中，将会引入@static 注解对静态方法和字段提供了支持。</p><h2 id="创建枚举类"><a href="#创建枚举类" class="headerlink" title="创建枚举类"></a>创建枚举类</h2><p>Scala 中创建枚举，要先从创建对象开始，这和创建一个单例的语法特别相像，但 可以赋予多个命名的实例，毕竟，单例模式并不强制只有一个实例，它只是一种对所选实例 的创建的控制方式。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Currency</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Currency</span> </span>= <span class="type">Value</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">CNY</span>, <span class="type">GBP</span>, <span class="type">INR</span>, <span class="type">JPY</span>, <span class="type">NOK</span>, <span class="type">PLN</span>, <span class="type">SEK</span>, <span class="type">USD</span> = <span class="type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包对象"><a href="#包对象" class="headerlink" title="包对象"></a>包对象</h2><p>首先我们使用单例创建一个例子，然后将其转换成一个包对象，这样做可以帮助我们理解其中的好处。<br>在这个例子中，我们会复用之前创建的枚举 Currency 和类 Money。这是一个名为 Converter 的单例，带有一个 convert()方法，它能帮助我们将钱从一种货币换算成另一 种货币。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Currency</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(money: <span class="type">Money</span>, to: <span class="type">Currency</span>): <span class="type">Money</span> = &#123;</span><br><span class="line">    <span class="comment">// 获取当前的市场汇率......这里使用了模拟值</span></span><br><span class="line">    <span class="keyword">val</span> conversionRate = <span class="number">2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Money</span>(money.amount * conversionRate, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>让我们在同一个包的类 Charge 中使用这个方法:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Charge</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">chargeInUSD</span></span>(money: <span class="type">Money</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moneyInUSD</span> </span>= <span class="type">Converter</span>.convert(money, <span class="type">Currency</span>.<span class="type">USD</span>)</span><br><span class="line">    <span class="string">s"charged $$<span class="subst">$&#123;moneyInUSD.amount&#125;</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们能够敏锐地观察到:convert()操作对于 finance.currencies 这个包非常基 础，但是 Converter 这个前缀没有增加任何价值。它是一个人工的占位符— 一种噪声。 我们可以用包对象来避免它。<br>包对象没什么特别的，就是一个单例，和 Converter 本身很像，只不过它有特殊的名 字和语法。它使用相应的包名作为名字，并用单词 package 标记。我们把 Converter 重 写为一个包对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance</span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">currencies</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Currency</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(money: <span class="type">Money</span>, to: <span class="type">Currency</span>): <span class="type">Money</span> = &#123; <span class="comment">// 获取当前的市场汇率......这里使用了模拟值</span></span><br><span class="line">    <span class="keyword">val</span> conversionRate = <span class="number">2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Money</span>(money.amount * conversionRate, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="善用类型"><a href="#善用类型" class="headerlink" title="善用类型"></a>善用类型</h1><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>与任何静态类型的编程语言一样，Scala 在编译时验证对象的类型。同时，它不要求明确 标注显而易见的类型，它可以进行类型推断。无论是对于简单类型还是泛型，都可以使用类 型推断。</p><h3 id="简单类型的类型推断"><a href="#简单类型的类型推断" class="headerlink" title="简单类型的类型推断"></a>简单类型的类型推断</h3><p>以下几种情况下，必须要显式地指定类型:</p><ul><li>当定义没有初始值的类字段时;</li><li>当定义函数或方法的参数时;</li><li>当定义函数或方法的返回类型，仅当我们使用显式的 return 语句或者使用递归时1;</li><li>当将变量定义为另一种类型，而不是被直接推断出的类型时，如 val frequency: 2 Double = 1 。</li></ul><h3 id="针对泛型和集合的类型推断"><a href="#针对泛型和集合的类型推断" class="headerlink" title="针对泛型和集合的类型推断"></a>针对泛型和集合的类型推断</h3><p>定义 了几个 ArrayList 的实例，我们先使用显式的类型，然后再使用类型推断。</p><p><code>var list1: util.List[Int] = new util.ArrayList[Int]</code></p><h2 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h2><p>尽管可以在 Scala 中使用 Java 的任何类型，但同时也可以享受到由 Scala 提供的一些原生 类型。Scala 在值类型和引用类型之间进行了更加明确的划分，并且通过类型定义进一步增强 了类型验证和类型推断。让我们掌握这些基础类型，因为在 Scala 中，将会经常遇到这些类型。</p><h3 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a>Any 类型</h3><p>Scala 的 Any 类型是所有类型的超类型2，如图 5-1 所示。<br><img src="/images/media/15773763608881/15777817957416.jpg" alt=""><br>Any 是一个抽象类1，定义了如下方 法:!=()、==()、asInstanceOf()、equals()、hashCode()、isInstanceOf() 和 toString()。</p><h3 id="关于-Nothing"><a href="#关于-Nothing" class="headerlink" title="关于 Nothing"></a>关于 Nothing</h3><p>在 Scala 中，Nothing 是一切类型的子类型。</p><h3 id="Option-类型"><a href="#Option-类型" class="headerlink" title="Option 类型"></a>Option 类型</h3><p>返回空集合，而不是 null 引用。如果遵循这个建议，我们就不必忍受 NullPointerException 了。即使结果 集合为空，迭代也会变得很容易。在使用集合的时候，这是很好的建议，但是在使用其他返 回类型时，我们也需要类似的内容。</p><p>Scala 进一步指定了可能的不存在性。使用 Scala 的 Option[T]，可以进行有意图的编 程，并指定打算不返回结果。Scala 以类型安全的方式实现了这一点，因此可以在编译时强制 进行检查。让我们来看一个使用了这个特殊类型的例子。</p><h3 id="Either-类型"><a href="#Either-类型" class="headerlink" title="Either 类型"></a>Either 类型</h3><p>当一个函数调用的结果可能存在也可能不存在时，Option 类型很有用。有时候，你可 能希望从一个函数中返回两种不同类型的值之一。这个时候，Scala 的 Either 类型就派上 用场了。</p><h2 id="返回值类型推断"><a href="#返回值类型推断" class="headerlink" title="返回值类型推断"></a>返回值类型推断</h2><p>Scala 是否自动推断取决于你如何定义函数。<strong>只有当你使用等号(=)将方法 的声明和方法的主体部分区分开时1，Scala 的返回值类型推断才会生效。否则，该方法将 会被视为返回一个 Unit，等效于 Java 中的 Void。</strong>让我们研究一下下面这些函数的返回值 类型。</p><h2 id="参数化类型的型变"><a href="#参数化类型的型变" class="headerlink" title="参数化类型的型变"></a>参数化类型的型变</h2><p>在 5.1.2 节中，Scala 阻止我们将一个指向 ArrayList[Int]的引用赋值给一个指向 Array List[Any]的引用。这是一件好事情。通常来说，一个派生类型的集合不应该赋值给一个基 类型的集合。然而，有时候我们需要放宽这一规则。在这些情况下，我们可以要求 Scala 允 许在其他情况下无效的转换。</p><h3 id="协变和逆变"><a href="#协变和逆变" class="headerlink" title="协变和逆变"></a>协变和逆变</h3><p>在期望接收一个基类实例的集合的地方，能够使用一个子类实例的集合的能力叫作协变 (covariance)。而在期望接收一个子类实例的集合的地方，能够使用一个超类实例的集合的能力叫作逆变(contravariance)。在默认的情况下，Scala 都不允许(即不变)。</p><h3 id="支持协变"><a href="#支持协变" class="headerlink" title="支持协变"></a>支持协变</h3><p>虽然 Scala 的默认行为总的来说是好事，但是我们还是想要小心地将派生类型的集合， 也就是 Dog 的集合，看作是其基类型的集合，也就是 Pet 的集合。考虑下面的例子。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dogs = <span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"Rover"</span>), <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"Comet"</span>))</span><br></pre></td></tr></table></figure><p>如果我们把 dogs 传递给前面的方法，我们将会得到一个编译错误:workWithPets(dogs) // 编译错误</p><p>不能将一个包含Dog的数组发送给一个接受 Pet 的数组的方法。但是，这个方法是无害的。然而，Scala 并不知道这一点，<br>所以它试图保护我们。我们必须要告诉 Scala，我们允许这样做。下面是一个我们如何能够做到这一点的例子 。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playWithPets</span></span>[<span class="type">T</span> &lt;: <span class="type">Pet</span>](pets: <span class="type">Array</span>[<span class="type">T</span>]): <span class="type">Unit</span> = println(<span class="string">"Playing with pets: "</span> + pets.mkString(<span class="string">", "</span>))</span><br></pre></td></tr></table></figure><p>我们使用一种特殊语法定义了playWithPets()方法。T &lt;: Pet表明由T表示的类 派生自 Pet 类。这个语法用于定义一个上界(如果可视化这个类的层次结构，那么 Pet 将 会是类型 T 的上界)，T 可以是任何类型的 Pet，也可以是在该类型层次结构中低于 Pet 的 类型。通过指定上界，我们告诉 Scala 数组参数的类型参数 T 必须至少是一个 Pet 的数组， 但是也可以是任何派生自 Pet 类型的类的实例数组。因此，现在我们可以执行下面的调用了。</p><h3 id="支持逆变"><a href="#支持逆变" class="headerlink" title="支持逆变"></a>支持逆变</h3><p>假设我们想要将宠物从一个集合复制到另外一个集合，那么我们可以编写一个名 为 copy()的方法，其接受两个类型为 Array[Pet]的参数。然而，这将不能帮助我们传递 一个 Dog 的数组。此外，我们应该能够从一个 Dog 的数组复制到一个 Pet 的数组。换句话 说，在这个场景下，接收数组中元素类型是源数组中元素类型的超类型也是可以的。这里我们需要的是一个下界 。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyPets</span></span>[<span class="type">S</span>, <span class="type">D</span> &gt;: <span class="type">S</span>](fromPets: <span class="type">Array</span>[<span class="type">S</span>], toPets: <span class="type">Array</span>[<span class="type">D</span>]): <span class="type">Unit</span> = &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">val</span> pets = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Pet</span>](<span class="number">10</span>) </span><br><span class="line">copyPets(dogs, pets)</span><br></pre></td></tr></table></figure><h3 id="定制集合的型变"><a href="#定制集合的型变" class="headerlink" title="定制集合的型变"></a>定制集合的型变</h3><p>如果你是一个集合类的作者， 你也可以控制这一行为，也就是说，如果你假定派生类型的集合可以被看作是其基类型的集 合。你可以通过将参数化类型标记为+T 而不是 T 来完成这项操作，如下所示。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">T</span>] <span class="title">//</span>...</span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">list1</span> </span>= <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">Int</span>] </span><br><span class="line"><span class="keyword">var</span> list2: <span class="type">MyList</span>[<span class="type">Any</span>] = _ </span><br><span class="line">list2 = list1 <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>实现类型转换有两种不同的方式— 编写隐式函数和创建隐式类。第一种方法在 Scala 中由来已久，而隐式类则是相对较新的。让我们一起来探索一下吧。</p><h3 id="隐式函数"><a href="#隐式函数" class="headerlink" title="隐式函数"></a>隐式函数</h3><p>DateHelper 提供了我们想要的 days()方法。我们在该方法中使用的 match()方法 是 Scala 的模式匹配(我们将会在第 9 章中学习)的一部分。因为 DateHelper 是一个常规 类，所以我们可以创建一个它的实例，并调用其上面的 days()方法。但是，真正的乐趣在 于，在一个 Int 上调用 days()方法，并让 Scala 静默地将 Int 转换为一个 DateHelper 的实例，这样就可以调用这个方法了。Scala 只需在一个简单的函数前面加上 implicit 关 键字即可使用启用这个技巧的特性。<br>如果一个函数被标记为 implicit，且在当前作用域中存在这个函数(通过当前的 import 语句导入，或者存在于当前文件中)，那么 Scala 都将会自动使用这个函数。让我们 创建这个隐式函数，并进行流式调用吧:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"><span class="keyword">import</span> java.time.<span class="type">LocalDate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">offset: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">LocalDate</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> today = <span class="type">LocalDate</span>.now</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; today.minusDays(offset)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; today.plusDays(offset)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; today</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">  <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  implicit def convertInt2DateHelper(offset: Int): DateHelper = new DateHelper(offset)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TopStock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(offset: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">    <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line">    <span class="keyword">val</span> past = <span class="number">2.</span>days(ago)</span><br><span class="line">    <span class="keyword">val</span> appointment = <span class="number">5</span> days from_now</span><br><span class="line">    println(past)</span><br><span class="line">    println(appointment)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="隐式类"><a href="#隐式类" class="headerlink" title="隐式类"></a>隐式类</h3><p>将一个类标记为 implicit 类。当使用隐式 类的时候，Scala 设置了一些限制。其中最值得注意的是，它不能是一个独立的类，它必须要 在一个单例对象、类或者特质中。让我们重新修改这个流式日期的例子，从而使用隐式类。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">  <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">val offset: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.time.<span class="type">LocalDate</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">LocalDate</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> today = <span class="type">LocalDate</span>.now</span><br><span class="line">      when <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; today.minusDays(offset)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; today.plusDays(offset)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; today</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TopStock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">DateUtil</span>._</span><br><span class="line">    <span class="keyword">val</span> past = <span class="number">2</span> days ago</span><br><span class="line">    <span class="keyword">val</span> appointment = <span class="number">5</span> days from_now</span><br><span class="line">    println(past)</span><br><span class="line">    println(appointment)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;第一部分 小试牛刀&lt;br&gt;Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。&lt;/p&gt;
&lt;h1 id=&quot;探索scala&quot;&gt;&lt;a href=&quot;#探索scala&quot; class=&quot;headerlink&quot; title=&quot;探索scala&quot;&gt;&lt;/a&gt;探索scala&lt;/h1&gt;&lt;h2 id=&quot;scala的特殊性&quot;&gt;&lt;a href=&quot;#scala的特殊性&quot; class=&quot;headerlink&quot; title=&quot;scala的特殊性&quot;&gt;&lt;/a&gt;scala的特殊性&lt;/h2&gt;&lt;p&gt;scala的关键特性信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同时支持命令式风格和函数式风格&lt;/li&gt;
&lt;li&gt;纯面向对象&lt;/li&gt;
&lt;li&gt;强制合理的静态类型和类型推断&lt;/li&gt;
&lt;li&gt;简洁而富有表现力&lt;/li&gt;
&lt;li&gt;能和 Java 无缝地互操作&lt;/li&gt;
&lt;li&gt;基于精小的内核构建&lt;/li&gt;
&lt;li&gt;高度的伸缩性，仅用少量代码就可以创建高性能的应用程序&lt;/li&gt;
&lt;li&gt;具有强大、易用的并发模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;以少胜多&quot;&gt;&lt;a href=&quot;#以少胜多&quot; class=&quot;headerlink&quot; title=&quot;以少胜多&quot;&gt;&lt;/a&gt;以少胜多&lt;/h2&gt;&lt;p&gt;用更少的代码解决更多的问题 — 简化日常编程&lt;br&gt;筛选出内部最高价格的股票&lt;/p&gt;
&lt;figure class=&quot;highlight scala&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Record&lt;/span&gt;(&lt;span class=&quot;params&quot;&gt;year: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, month: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, date: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;, closePrice: &lt;span class=&quot;type&quot;&gt;BigDecimal&lt;/span&gt;&lt;/span&gt;)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;title&quot;&gt;object&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;PrintMax&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;getYearEndClosingPrice&lt;/span&gt;&lt;/span&gt;(symbol: &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;, year: &lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;): &lt;span class=&quot;type&quot;&gt;BigDecimal&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; url = &lt;span class=&quot;string&quot;&gt;s&quot;https://raw.githubusercontent.com/ReactivePlatform/&quot;&lt;/span&gt; +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;s&quot;Pragmatic-Scala-StaticResources/master/src/main/resources/&quot;&lt;/span&gt; + &lt;span class=&quot;string&quot;&gt;s&quot;stocks/daily/daily_&lt;span class=&quot;subst&quot;&gt;$symbol&lt;/span&gt;.csv&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; data = io.&lt;span class=&quot;type&quot;&gt;Source&lt;/span&gt;.fromURL(url).mkString&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; maxClosePrize = data.split(&lt;span class=&quot;string&quot;&gt;&quot;\n&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .filter(record =&amp;gt; record.startsWith(&lt;span class=&quot;string&quot;&gt;s&quot;&lt;span class=&quot;subst&quot;&gt;$year&lt;/span&gt;-12&quot;&lt;/span&gt;)).map(record =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;(timestamp, open, high, low, close, volume) = record.split(&lt;span class=&quot;string&quot;&gt;&quot;,&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;(year, month, date) = timestamp.split(&lt;span class=&quot;string&quot;&gt;&quot;-&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;type&quot;&gt;Record&lt;/span&gt;(year.toInt, month.toInt, date.toInt, &lt;span class=&quot;type&quot;&gt;BigDecimal&lt;/span&gt;(close.trim))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;).sortBy(_.date)(&lt;span class=&quot;type&quot;&gt;Ordering&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;Int&lt;/span&gt;].reverse).take(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .map(_.closePrice)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .head&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    maxClosePrize&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;main&lt;/span&gt;&lt;/span&gt;(args: &lt;span class=&quot;type&quot;&gt;Array&lt;/span&gt;[&lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;]): &lt;span class=&quot;type&quot;&gt;Unit&lt;/span&gt; = &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; symbols = &lt;span class=&quot;type&quot;&gt;List&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;AMD&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;AAPL&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; year = &lt;span class=&quot;number&quot;&gt;2017&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;val&lt;/span&gt; (topStock, topPrice) = symbols.par.map &amp;#123; ticker =&amp;gt; (ticker, getYearEndClosingPrice(ticker, year)) &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      .maxBy &amp;#123; stockPrice =&amp;gt; stockPrice._2 &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&lt;span class=&quot;string&quot;&gt;s&quot;Top stock of &lt;span class=&quot;subst&quot;&gt;$year&lt;/span&gt; is &lt;span class=&quot;subst&quot;&gt;$topStock&lt;/span&gt; closing at price $$&lt;span class=&quot;subst&quot;&gt;$topPrice&lt;/span&gt;&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;两个功能强大的专用迭代器— map() 函数和 maxBy()函数。在 Java 中，我们习惯用“方法”这个术语来指代类的成员，而“函 数”这个术语通常用于指代不属于类的过程(procedure)。然而，在 Scala 中这两个术语可交 换使用。&lt;/p&gt;
&lt;p&gt;这两个迭代器分别行使了两种独立的职责。首先，我们使用 map()函数遍历股票代码， 以创建一个由股票代码及其 2017 年收盘价格组成的“对”或“元组”为元素的列表。最终结 果的元组列表形式为 List((股票代码 1，价格 1)，(股票代码 2，价格 2)，…)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="professional skill" scheme="http://bondaddy.github.io/categories/professional-skill/"/>
    
    
      <category term="software programming" scheme="http://bondaddy.github.io/tags/software-programming/"/>
    
      <category term="scala" scheme="http://bondaddy.github.io/tags/scala/"/>
    
  </entry>
  
  <entry>
    <title>开局一只狗，装备全靠打</title>
    <link href="http://bondaddy.github.io/2020/01/01/----80/"/>
    <id>http://bondaddy.github.io/2020/01/01/----80/</id>
    <published>2019-12-31T18:08:48.000Z</published>
    <updated>2019-12-31T19:30:35.187Z</updated>
    
    <content type="html"><![CDATA[<p>在开始这一篇的日记的时候，我居然因为今年一个倒霉催的开局，想到了这么二呼的一句话 ，其实吧，在这个时候，我也还在熬夜加班，等待着同事们在处理新疆网信办服务迁移的事情 。</p><p>过去的每一年，我都特别期待每一年是一个全新的自己，而今年，就如我上一篇日记所说的我并没有特别的期待新年，因为很多事情已经在12月份做好了准备，而2020年我相信一定是我特别有收获的一年。</p><p>其实细细回望过去，每一年我都很有收获。虽然我也怨恨过很多事情，但是发现自己被眷顾的事情也不少。有一个美好的妻子，可爱的女儿，以及不近不远的各种人际关系，使我的生活不会喧嚣，淡也不至于孤独和寂寞 。</p><p>岳父和岳母的关系没有缓和的迹象，而生活需要给予他们的是一定的决断。男人这种东西，其实没有太多出息，岳母花费越多的心思去追寻男人，男人就是会嫌恶的更多。为什么这么清楚这个情况，也是我自己也是男人啊。</p><p>最近又开始学习scala，针对上次的kotlin语言学习写了一个oss，golang写了一个proxy。scala也需要寻找一个全新的代码开始执行，要考虑使用vcc还是ass的权限组织架构生成来处理，实践才是学习的最快的方式。</p><p>答应星爷这周去道馆报道的，衣服裤子也都洗了，好像也没有更多的理由去逃避了，这周六就开始恢复练习吧 ，也不枉费自己其实也练习了挺久的素振练习。再者，自己的这身肉，我也是扛不住了，在下真的是太肥了 。</p><p>现在是2020年1月1日3:28分，一个并不完美的开局，却给我最好的感受，并没有过去的那种雄心壮志，也没有颓废的无法开始，学习，看书，记账，把自己整理的井井有条，在衣着和品味上也不断的提升。一个全方面提升的自己令自己感到安心，当然，我还是可以做的更好一点，但是如果陷入这种可以更好的思维，反而容易泥足不前。每一天1.01，要远比0.99好的多，要牢牢记住。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在开始这一篇的日记的时候，我居然因为今年一个倒霉催的开局，想到了这么二呼的一句话 ，其实吧，在这个时候，我也还在熬夜加班，等待着同事们在处理新疆网信办服务迁移的事情 。&lt;/p&gt;
&lt;p&gt;过去的每一年，我都特别期待每一年是一个全新的自己，而今年，就如我上一篇日记所说的我并没有特
      
    
    </summary>
    
    
      <category term="blog" scheme="http://bondaddy.github.io/categories/blog/"/>
    
    
      <category term="mood" scheme="http://bondaddy.github.io/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>年底的颓废状态</title>
    <link href="http://bondaddy.github.io/2019/12/18/----79/"/>
    <id>http://bondaddy.github.io/2019/12/18/----79/</id>
    <published>2019-12-18T09:08:48.000Z</published>
    <updated>2019-12-18T16:28:15.606Z</updated>
    
    <content type="html"><![CDATA[<p>每年的12月都是一个神奇的12月，都会陷入两种焦灼的状态在反复并行：</p><ul><li>其一：认为已经到了年底了，做什么事情都没有干劲，有事情等到明年再说吧。</li><li>其二：又过了一年了，不能再作为那个颓废的自己了，开始寻找各种工具，计划，目标，要把自己变成更厉害的那个自己。</li></ul><p>当然从结果上来看，很明显第二点是没有做到的，毕竟到现在的我，还是那个颓废的自己。只不过今年有一点点的变化就是，我变得有点老迈。这个老迈不是指身体上或者心理上的，而是念旧上的。开始整理自己的笔记，整理自己的周围，整理自己的财物，仿佛要把自己的一切都整理下来，保留下来，记录下来。这种东西，我称之为一种老。老是贪得无厌的开始，年轻的人，从来不怕失去，而且年轻的人特别希望卸下自己的负担，因为这个世界有太多的东西可以去争取，过去的东西只会成为自己的累赘，而老了，就觉得获取越来越难，对过往就越来越珍惜，越来越觉得无以为继。</p><a id="more"></a><p>面对2020年的期许，和过去还有一点不同的就是，过去总是从新的一年第一天开始，而现在，却是从上一年的最后一个月开始的。这个事情多还是有赖于我使用了国誉自我的手帐，虽然说到现在为止也不过坚持了三周多的时间，还有很多地方写的并不是那么让人满意。但这也是我这种没有耐心的人坚持最长的一本手帐了，真的也是特别的感慨。很多事情开始降低自己的期许，反而变得越发容易坚持，而坚持这件事情，本身就具备足够多的意义。今年如果我能完整的记录完一本手帐，那我算是给自己33岁的人生留下了一份记忆，后续的每一年我都可以坚持下去，这就是一本流水账，然而，谁又能说流水账没有意义呢，帝王的流水账就是起居注，我的流水账对于未来的我，也是一份财富。</p><p>而后对于生活我还确定了稳定的几项生活必备的工具：</p><ul><li><p>苹果全家桶体系：帮助我解决所有3c产品同步的问题，所有不具备这个基础条件的事物都会被排除且不用多做考虑</p></li><li><p>滴答清单：过去的我认为日程必须井井有条，必须满满当当。但是每次都会因为自己生活记录的都是琐碎的事情而放弃，我不是什么大人物，生活也没有紧张到那个份上。但是现在的滴答清单对于我来说，更多的是一种事务提醒，而非是把自己绑架成时间的奴隶。设置的也多是重复的事务，来保障自己不要忘记必须做的事情。这样对于自己的管理我认为是恰到好处，没必要增加自己无意义的负担。</p></li><li><p>mweb：挑选了多种工具之后，还是会感慨真的没有任何工具是特别完美的，都是有取舍的。mweb支持表格，支持快速导入图片等功能对我来说还是战胜了所谓的编辑多格式和导出多格式的ulysses。并且将自己qzone上所写的文章全部搬家到了github上，创建了自己的全新博客。断断续续其实过去还是写了不少文章，我一直以为我写文的巅峰时在10年前，后来发现自己10年之后的文章才尚且有点质量。现在我希望能继续保持这份，可能真的能磨练自己的文笔也说不清呢。而现在写的这篇，也是我在这个平台上第一篇博客。</p></li><li><p>国誉自我：前文已经提到了起居注形式的内容存在。每日的流水账记录最多的就是睡觉时间，每天都用来大段大段的时间来睡觉，这显得自己一点都没有出息，但是没有出息也要面对自己的没有出息，面对它，那就是真实的自己。</p></li><li><p>money pro：这个工具我还没有购买，也还在犹豫是否需要购买，但是过去这么多年对于金钱没有管控，而导致自己和老婆多年也并没有针对财务获得多大的益处。现在是否也需要认真的面对自己大手大脚的行为。无论最终是否决定是这个工具，也依然决定未来的一年我要对家庭经济的全面管控。如果发现最终消费最多的是自己，那我也要诚实的面对这个事实，然后加以改正。</p></li></ul><p>上述看了很多问题，其实最终发现很多事情无法坚持，其本质都是无法面对那个自己。对于自己充满了过多的期待而因为无法实现最终就会导致无法面对。而2020我还有很多很多的期许，比如剑道，比如早起，比如读书。这些事情都会慢慢的被安排上日程，虽然现在还在艰难爬行，但是启步艰难是每一次行进的必然。而开始了不要放弃才是后续对于自己的唯一心法，万物皆空，唯有一心不散。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每年的12月都是一个神奇的12月，都会陷入两种焦灼的状态在反复并行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;其一：认为已经到了年底了，做什么事情都没有干劲，有事情等到明年再说吧。&lt;/li&gt;
&lt;li&gt;其二：又过了一年了，不能再作为那个颓废的自己了，开始寻找各种工具，计划，目标，要把自己变成更厉害的那个自己。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然从结果上来看，很明显第二点是没有做到的，毕竟到现在的我，还是那个颓废的自己。只不过今年有一点点的变化就是，我变得有点老迈。这个老迈不是指身体上或者心理上的，而是念旧上的。开始整理自己的笔记，整理自己的周围，整理自己的财物，仿佛要把自己的一切都整理下来，保留下来，记录下来。这种东西，我称之为一种老。老是贪得无厌的开始，年轻的人，从来不怕失去，而且年轻的人特别希望卸下自己的负担，因为这个世界有太多的东西可以去争取，过去的东西只会成为自己的累赘，而老了，就觉得获取越来越难，对过往就越来越珍惜，越来越觉得无以为继。&lt;/p&gt;
    
    </summary>
    
    
      <category term="blog" scheme="http://bondaddy.github.io/categories/blog/"/>
    
    
      <category term="mood" scheme="http://bondaddy.github.io/tags/mood/"/>
    
  </entry>
  
  <entry>
    <title>对习惯的戒心</title>
    <link href="http://bondaddy.github.io/2010/11/06/----78/"/>
    <id>http://bondaddy.github.io/2010/11/06/----78/</id>
    <published>2010-11-05T22:06:32.000Z</published>
    <updated>2019-12-19T01:41:17.081Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-11-6 06:06</p></blockquote><p>这次互联网大战,其实是个很好的契机.能够让大家觉醒与依赖是一件多么可怕的事情,而这些依赖性不过是出于某种习惯,如果能脱离出某种工具本身来看待自身真是的需求,则会发现我们并非如此的依赖一个东西.</p><p>从无到有一直是如此容易,从有到无总是困难的.但其实身来就是无,为何我们的生活依旧过的很好.为何要被一种无聊经济绑架.最近常常反思自己在网页游戏上浪费的时间是多么的多.这种无聊经济创造的价值又被谁吸收的干干净净.</p><p>腾讯从过去的OICQ的瘦企鹅到现在肥头大耳的QQ.其实从来就没有摆脱抄袭的道路.只是学会了别人的技术还能做的比别人更好,这确实是本事.模仿不是罪孽,商人追逐利益最大化也没有错.可惜你的做法是错的.</p><p>我似乎天然就在追求一种自由,一种心境和精神上的自由.为此我很长时间都觉得身无长物是一件乐事.因为那样我不会患得患失,没有就从来不怕失去.但即使得到了,也不见得我无法承受失去的痛苦.因为束缚感令我很不愉快.其实绝大部分的人也许都是如此.我们对于整个世界的不满也许就在于世界束缚了我们不让我们随心所欲.我并不想世界按照我的指引去前进,我只是想世界不要过来指引我而已.</p><a id="more"></a><p>人总是充满了惰性,要主动去改变自己的生活习惯总是非常困难的,所以如果有人强迫你离开这种依赖,你应该欢呼雀跃.主动不够勇敢的时候,有人拿枪顶着你你就应该觉醒.不要把鸡蛋放在一个篮子里.这话不只适用于经济学.而对于自己生活上所依赖的东西,你也可以分散在不同的地方.那样一旦出现裂变,你的伤痛就比别人小的多.</p><p>其实又岂止是互联网,其实发生在生命中一切物欲上的依赖都应当有所警惕.你有可能一天失去这里的所有.有人说了在这个体制下没有人是安全的,其实在这个世界本就没有人是安全的.追求心境上的平和有多种方式.无欲则刚,这话真是浅显易懂.如果能因此事件,有所警惕.不得不说这是一件功德.世事的浮华侵蚀人群总是令人怵不及防.</p><p>这是在qzone最后一篇文字,以后我会移居一个极少人知道的地方继续写字.突然很想毫无意义的对着写了这么久的地方说当年聊天室里面/bye命令的话：青山不改 绿水长流 我们后会有期:)</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-11-6 06:06&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这次互联网大战,其实是个很好的契机.能够让大家觉醒与依赖是一件多么可怕的事情,而这些依赖性不过是出于某种习惯,如果能脱离出某种工具本身来看待自身真是的需求,则会发现我们并非如此的依赖一个东西.&lt;/p&gt;
&lt;p&gt;从无到有一直是如此容易,从有到无总是困难的.但其实身来就是无,为何我们的生活依旧过的很好.为何要被一种无聊经济绑架.最近常常反思自己在网页游戏上浪费的时间是多么的多.这种无聊经济创造的价值又被谁吸收的干干净净.&lt;/p&gt;
&lt;p&gt;腾讯从过去的OICQ的瘦企鹅到现在肥头大耳的QQ.其实从来就没有摆脱抄袭的道路.只是学会了别人的技术还能做的比别人更好,这确实是本事.模仿不是罪孽,商人追逐利益最大化也没有错.可惜你的做法是错的.&lt;/p&gt;
&lt;p&gt;我似乎天然就在追求一种自由,一种心境和精神上的自由.为此我很长时间都觉得身无长物是一件乐事.因为那样我不会患得患失,没有就从来不怕失去.但即使得到了,也不见得我无法承受失去的痛苦.因为束缚感令我很不愉快.其实绝大部分的人也许都是如此.我们对于整个世界的不满也许就在于世界束缚了我们不让我们随心所欲.我并不想世界按照我的指引去前进,我只是想世界不要过来指引我而已.&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>悬崖的三五步是安全的</title>
    <link href="http://bondaddy.github.io/2010/10/11/----77/"/>
    <id>http://bondaddy.github.io/2010/10/11/----77/</id>
    <published>2010-10-10T18:31:32.000Z</published>
    <updated>2019-12-19T01:41:19.743Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-10-11 02:31</p></blockquote><p>标题借用李敖的原话，近来看它的节目，发现自己对于这位老人过去的感触错的离谱。如果不能持续的看大量的他的节目，进行贯穿的话，很容易对他产生误会。就如他在节目外的原话一般，做李敖有话说就像是早泄，只有二十分钟的时间中要说的话实在太多，还没有说完，节目就结束了。所以他的很多言论，思想其实都散布在一个个节目当中。只有细细品味，才能感受到这个老人其实并不张狂，而只是真的有些话想要说而已。</p><p>宪法中保障的每个人都有言论自由，我们的国家加入联合国的时候在世界人权宣言里面所签字的就是赞成人们有言论自由。对于这一点，似乎大家都认为是笑话了。因为在这个国家中，感受到的就是无时无刻的不自由。我们不能随意发表自己的政治观感，不能随意的接受到世界的资讯，中国的互联网被称为世界最大的内联网，中国的搜索引擎的结果永远是关键词屏蔽的结果。在这个处处不自由的国度里，只有消费是自由的。只有你拥有金钱，你将可以享受到这个世界任何角落发达国家同等的消费自由，这也许就是我们这一代浮躁的盲目追求名利的原因之一吧。我们的国家的维持并非以民主选举来保持社会的稳定，而是以经济带动的模式在让这个国家向前走。在一个暂时不能谈“民主”的国家中，似乎言论自由也并非如此必要。</p><a id="more"></a><p>在此可以先讨论一个问题，言论的自由是否有一个标准。我们这样一个网络的时代里，并非戒严期间。就算每个人都感受到了诸多限制，但也必须得承认我们还是有一定说话的权利的。只是这个说话权利受到了一定的限制。这个限制的线又在何处？这条线是由谁规定的，如果有这条规定，那么究竟是中央政府，地方政府，还是某些机关单位自己的自作主张呢。说个大跃进时代的笑话吧，毛泽东出访苏联，苏联告诉他说我们国家花了二十年的时候就超过美国。毛泽东大受刺激，回来后对下面说，苏联老大哥花二十年就超过了资本主义国家的老大，我们怎么着也得超过资本主义的老二吧，我们必须十五年超过英国。这个任务下放到省，中央说十五年，你不好意思给中央丢脸吧，怎么的也得提前几年，那就十二年吧。这么层层的往下压，我市九年，我乡六年，我县三年，我村今年，之后便是错误的大跃进时代，在此亦不展开讨论。回归到正题，对于言论自由的标准，是否也有这种层层压制的可能，中央提出了一个概念，但落实到地方和机关甚至是人去操作的时候，不同的人对于一个概念就将有不同的诠释，这种诠释有时则有可能离经叛道。这种行为也许是善意的，只是为了他们的理念，维护国家的安定团结而做出的行为，但有时显得过于敏感和小心，言论越过悬崖的界限，其实并非处在你们限定的那条标准上。</p><p>言论自由是很重要的，但消息的传播的管制却也是必要的。新闻的传播是标准的有教无类，当你无法控制受众的群体时，你必然要从源头控制这个言论的自由。如果认为任何东西只要是真实的所有人就应当就有知情权，那么富士康的自杀事件和杀童报复社会事件就不会如此密集的出现的一段极短的时间之内。这种心理上的传播对于心中有异的人群，是让他们寻求到一种发泄的出口，而这种出口明显是错误的，但却由于没有管制，将这种错误的思想植入了那些人的心中，并暗示他们这可能是可以宣泄自己黑暗的一种方式时。传媒必将为这个所谓的言论自由付上责任。言论自由不等于胡说八道，言论自由也不等于肆无忌惮，前年环球时报上一篇文章，所阐述的观点即是：中国并非是个言论不自由的国度，而是言论自由过甚的国度。当然写这样的文章必然遭到很多的人反对和嘲笑。但很多人都没有细细品味这篇文章的含义。我们国家有太多了借着言论自由而胡说八道不负责任的人。文章列举了很多事例来比对中外同样情况发生之时，我国的人们并不为此付出任何责任，而外国却要为此道歉乃至下台。对于言论要负责的并非全是政治言论，对于经济，社会等等难道就不要负责任吗？想想我们国家有多少砖家放出的疯语，他们可以说：为了拉动内需，这个时候买房就是爱国。也可以说：查处低房价，是为百姓负责。还可以说：春运的一票难求是由于票价太低。这些昏话比比皆是，那么要在这个国度阐述自由主义和言论自由，这些人是否应当优先拿板砖将自己拍死？</p><p>我说这些并非是要因噎废食，只是想说，在谈论言论自由这个议题的时候，是否视野应该放的更广一些。不能强求这个国家一步到位的走向胡说八道的地步，这样的言论自由其实才是真正的言论不自由。因为当自由成为一种乱流的时候，真正正确的声音往往难以被听到，难以被发现，当需要我们真正凝结成一股力量的时候，我们却因为很多似是而非的言论而导引向错误的方向。如果你们真的言论那么重要，是否首先能够加强自己的知识以及修养，然后在大家需要你们的时候，发出正确的声音。当每个人都可以谨慎的发出自己的声音，并将为自己的声音负责的时候，那么言论自由对于这个国度将有着更加积极的意义。也请到时候我们的朝廷能够明白，那个叫言论自由的悬崖，悬崖边的两三步并不危险，不要如此的急于“保护”我们，那个地方非常的安全，不要妄自的给予我们限定界限，我们也必将懂得哪里才是真正的悬崖，并在那里闲庭信步。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-10-11 02:31&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;标题借用李敖的原话，近来看它的节目，发现自己对于这位老人过去的感触错的离谱。如果不能持续的看大量的他的节目，进行贯穿的话，很容易对他产生误会。就如他在节目外的原话一般，做李敖有话说就像是早泄，只有二十分钟的时间中要说的话实在太多，还没有说完，节目就结束了。所以他的很多言论，思想其实都散布在一个个节目当中。只有细细品味，才能感受到这个老人其实并不张狂，而只是真的有些话想要说而已。&lt;/p&gt;
&lt;p&gt;宪法中保障的每个人都有言论自由，我们的国家加入联合国的时候在世界人权宣言里面所签字的就是赞成人们有言论自由。对于这一点，似乎大家都认为是笑话了。因为在这个国家中，感受到的就是无时无刻的不自由。我们不能随意发表自己的政治观感，不能随意的接受到世界的资讯，中国的互联网被称为世界最大的内联网，中国的搜索引擎的结果永远是关键词屏蔽的结果。在这个处处不自由的国度里，只有消费是自由的。只有你拥有金钱，你将可以享受到这个世界任何角落发达国家同等的消费自由，这也许就是我们这一代浮躁的盲目追求名利的原因之一吧。我们的国家的维持并非以民主选举来保持社会的稳定，而是以经济带动的模式在让这个国家向前走。在一个暂时不能谈“民主”的国家中，似乎言论自由也并非如此必要。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>百花缭乱</title>
    <link href="http://bondaddy.github.io/2010/10/06/----76/"/>
    <id>http://bondaddy.github.io/2010/10/06/----76/</id>
    <published>2010-10-06T06:14:32.000Z</published>
    <updated>2019-12-19T01:41:19.727Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-10-6 14:14</p></blockquote><p>从现在这一分钟起,可以学习如何耐的住寂寞.</p><p>记仇什么的最没意思了,我才不记仇.我只是会忘记对你的好,忘掉就好了,记仇是很难的,但仇恨的那一刻对自己植入一个想法就可以忘掉如何对你好,这样看来是不是很方便的方式.我看起来不错嘛~~那就这么做,从这一刻忘掉如何对你好.开始记起如何对自己好.</p><p>昨天才觉得生活好的连多愁善感的时间都没有,今天却有大把时间可以用来多愁善感.以此看来是否多愁善感不过是牵动的那一丝联系上.联系着你我的生活让我没有感觉到飘浮不定的情绪.而今天却全部回溯到身体的每一个细胞.这种飘忽啊飘忽的情绪.靠别人来怜悯是没有作用的.在每个街头的争执也不会换来下一次面对生活更加优越的快感.不如节省点这点情绪.</p><p>要读的书堆积如山.要做的事也一样.但想做的事情却只有一样,就是现在没有办法做的事情.这种矛盾只能跟随着耳机的嘶吼来缓解.或者在这里胡言乱语来抒发情绪.下一刻我一定会把这满纸荒唐给忘的干干净净.明显,我的记忆力不好.如果记忆力太好,就会自己绕不过自己.但是记忆力太不好.再想起来就无法原谅自己的愚蠢.这点,真矛盾啊.</p><a id="more"></a><p>140字的限制真是讨厌,连一句完整的话都没法表述.140字的限制真是讨厌,原来不是我不是没有140字的埋怨要发泄.是那140字根本装不完我的苦闷.微博什么的，我还是没有入门学习去如何玩。所以我还会继续写我的qzone..写我的闲篇,不知所云.没有开头,没有结尾.没有指代,没有意义.</p><p>话说我公司楼下有一只独眼猫霸.一般猫遇人均争相躲避.唯独它一只横在路中间动都不动.如果你抬起脚来驱赶它.它也只会给你让开几步.然后再慵懒的趴在那里不理世人.下班回家,偶然会碰到一小女孩从家中拿出牛奶来专喂猫霸,让其余的猫都羡慕不已.不知道猫霸那略显惊悚的长相是如何吸引到小女孩的特殊对待.也许是猫霸身上的气质让这个小女孩和我一样对猫霸着迷不已.这个世界仿佛都欠着猫霸的,它趴在路中间享受着它的阳光,周围的人群熙熙攘攘,但却和它无关.它不用像狗一样对人主动示好,也不像一般猫一样对人敬而远之.它走在属于自己的道路上,印下那一路的梅花印,还有它的桀骜不驯.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-10-6 14:14&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从现在这一分钟起,可以学习如何耐的住寂寞.&lt;/p&gt;
&lt;p&gt;记仇什么的最没意思了,我才不记仇.我只是会忘记对你的好,忘掉就好了,记仇是很难的,但仇恨的那一刻对自己植入一个想法就可以忘掉如何对你好,这样看来是不是很方便的方式.我看起来不错嘛~~那就这么做,从这一刻忘掉如何对你好.开始记起如何对自己好.&lt;/p&gt;
&lt;p&gt;昨天才觉得生活好的连多愁善感的时间都没有,今天却有大把时间可以用来多愁善感.以此看来是否多愁善感不过是牵动的那一丝联系上.联系着你我的生活让我没有感觉到飘浮不定的情绪.而今天却全部回溯到身体的每一个细胞.这种飘忽啊飘忽的情绪.靠别人来怜悯是没有作用的.在每个街头的争执也不会换来下一次面对生活更加优越的快感.不如节省点这点情绪.&lt;/p&gt;
&lt;p&gt;要读的书堆积如山.要做的事也一样.但想做的事情却只有一样,就是现在没有办法做的事情.这种矛盾只能跟随着耳机的嘶吼来缓解.或者在这里胡言乱语来抒发情绪.下一刻我一定会把这满纸荒唐给忘的干干净净.明显,我的记忆力不好.如果记忆力太好,就会自己绕不过自己.但是记忆力太不好.再想起来就无法原谅自己的愚蠢.这点,真矛盾啊.&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>三坊七巷是什么？</title>
    <link href="http://bondaddy.github.io/2010/10/02/----75/"/>
    <id>http://bondaddy.github.io/2010/10/02/----75/</id>
    <published>2010-10-01T17:14:32.000Z</published>
    <updated>2019-12-19T01:41:19.735Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-10-2 01:14</p></blockquote><p>星巴克入驻从很久以前就开始炒作，直到几天前正式营业。各种各样的粉丝和猎奇者在其门口排起了长龙，据传闻还有星巴克的铁杆粉丝穿梭于各地的新开张的星巴克秒杀各种城市杯的传闻，对此唏嘘不已。</p><p>我必须承认的一个事实就是，我一点都不懂咖啡，不懂的程度到，只要你给我加足奶和糖，不让我忍受过多的酸苦，我就已经很满意。但是对于星巴克这样名目的进入我们所谓的文化古街，不得不有微词。三坊七巷的仿古建筑本身透露的就是一股子低俗的品位，执政者似乎完全没有艺术品位和文化涵养。一味的追求于看起来像是古代建筑这种风格在走形式。而其中不得不悲哀的就是这种造假造谣的建筑立面还充斥着各式各样令人恶心的内在。从地方特产到酒吧咖啡屋，好似全无主张和规划。有人说我们现在已经面临了一个新的破坏古迹高峰的时代。犹如第二次文化大革命，其区别只在于当时的人们破坏古迹还是为了理想，而现在的人们为的只是利益。而面对这样的行为无能为力的我，只能每每走过都找不到自己小时候住家的悲凉。</p><a id="more"></a><p>对于文化的保存，很能看出一个地方执政者的涵养和品位。在这里也许我们会炮轰星巴克为何变得如此不伦不类，但却不应该忽略其一个基础问题，就是场地的管理者为何会放星巴克进驻三坊七巷。在商言商，星巴克只是追逐人流的开在人流量多的地方，这本无可厚非。这并非是单纯的星巴克不伦不类，而是管理部门究竟想三坊七巷塑造出何种文化形象。一家商家会选择自己适合的地段，以配合自己商家的形象和品位。北京的半岛酒店不会让永和豆浆进去开业，香港的置地广场也容不下麦当劳，哪怕其能够出到再贵的租金。三坊七巷从重建开始就没有一个较为有远见的思想和意识，本身并无限定其应有的形象和文化符号，而只是单纯的看到谋利二字，且是非常肤浅的短线操作。福州人对其的态度也不过是哄骗外来游客的一条街道而已。只是面对现在全国这种古街造假成风的现象，不知道这种同类质的造假又能哄骗的了谁。是否当谁也无法哄骗的时候，就让星巴克入驻其中为本地消费市场打开一条新的道路。</p><p>三坊七巷的现状，并非一家星巴克的问题，而是整条街存在都与这个城市格格不入。它的存在并非是一条黄金地段的商业街如此简单，而是承载了福州人对它更多的期待。在这份期待之下，三坊七巷表现如此，不过是它根本不知道自己究竟是何物，究竟是条繁荣的商业街道，抑或是标准的文化古街？在商业利益和文化期待面前，三坊七巷也只能不伦不类的继续存活下去。只有等到哪一天真正有远略的执政者，推翻一切从新来过，也许才能还苟延残喘的三坊七巷以本来面目。当然，不排除推翻重来也不过是另外一次的不伦不类罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-10-2 01:14&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;星巴克入驻从很久以前就开始炒作，直到几天前正式营业。各种各样的粉丝和猎奇者在其门口排起了长龙，据传闻还有星巴克的铁杆粉丝穿梭于各地的新开张的星巴克秒杀各种城市杯的传闻，对此唏嘘不已。&lt;/p&gt;
&lt;p&gt;我必须承认的一个事实就是，我一点都不懂咖啡，不懂的程度到，只要你给我加足奶和糖，不让我忍受过多的酸苦，我就已经很满意。但是对于星巴克这样名目的进入我们所谓的文化古街，不得不有微词。三坊七巷的仿古建筑本身透露的就是一股子低俗的品位，执政者似乎完全没有艺术品位和文化涵养。一味的追求于看起来像是古代建筑这种风格在走形式。而其中不得不悲哀的就是这种造假造谣的建筑立面还充斥着各式各样令人恶心的内在。从地方特产到酒吧咖啡屋，好似全无主张和规划。有人说我们现在已经面临了一个新的破坏古迹高峰的时代。犹如第二次文化大革命，其区别只在于当时的人们破坏古迹还是为了理想，而现在的人们为的只是利益。而面对这样的行为无能为力的我，只能每每走过都找不到自己小时候住家的悲凉。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>谓之纯真</title>
    <link href="http://bondaddy.github.io/2010/09/20/----74/"/>
    <id>http://bondaddy.github.io/2010/09/20/----74/</id>
    <published>2010-09-20T02:06:32.000Z</published>
    <updated>2019-12-19T01:41:19.712Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-9-20 10:06<br>对于我的电影审美，用最简单的形容方式就是：bin-bon-bian-bon-bon.所以像山楂树之恋这样的片子，我实在是看不进去的。不过这个号称“史上最干净的爱情故事”倒是确实值得玩味。</p></blockquote><p>对于纯爱这个名词，要定义似乎并不困难。列举再多的条件，其可以总结在四个字之上：“超凡脱俗”。当你的爱情一切与世俗隔离的时候，不再考虑性，金钱，门第之类存在于世俗层面上的东西，再配以精神上对于爱情恒古不变的追求和忠贞，那么也许你就能达到一个纯爱的标准。那以一名著的人物来看待这种纯粹追求爱情，似乎贾宝玉很合适吧。但是做这样的人物是要有资本的，而且有极大的资本。首先不用谋生，这点自不必多说，其次天赋异丙，谁能出生就含块玉呢？再则，社会体系中最高的当局必须支持你，红楼梦中的贾母是支持宝玉的。处在这么几个条件之下，你才有可能去追求所谓的纯爱。然则试问，一个人处在如此优越的条件之下，他也并非不在世俗之中，而是世俗达到某种极致之后，也就是纯爱出现之时。那么纯爱，不过是一种奢侈品。纯爱一点都不能成为批判社会爱情观沦落的象征，反而是爱情观沦落到极致的一种表现。当一切生理，物质的追求都得到满足了，就开始追求精神上难以满足的一种追求。这种难以满足的追求，让那些不为世俗所扰的人孜孜不倦罢了。</p><a id="more"></a><p>其实生活中，我们一直很现实。这种现实，并不会被灌输上不道德的层面。然则对于爱情过度的崇拜，却把很多生活中正常的事物归类于不道德的产物。精神追求不应该和物质追求是处在一个对立面之上，而是一种相互填补的过程。正常人的需求都不会单纯的是物质或者精神这么单纯。那么既然这是一种硬币的两面，都是一种需求，又为何会被冠以道德不道德的名义。一般而言，精神追求是一种较物质追求更深层次的追求。而批判这种层次追求的人又分为两类，一种是已经满足浅层需求，一种则没有。满足的人对于还未满足的人说三道四，这明显缺乏厚道。而后一种则更加有趣，出于嫉妒的心理，去指责别人世俗，而自己却又不愿意依靠努力去实现这种浅层追求。于是就搬出更深层次追求的高度来对人横加指责。仿佛是要体现出自己出于道德制高点上的优越感。俗不知两种追求本身就没有高低之分，只有内外之别。每当此时，我都会想再次引用那段话：长久的沙漠生活,只使人学到一点好处,任何一点点现实生活上的享受,都附带的使心灵得到无限的满足和升华.换句话说,我们注重自己的胃胜于自己的脑筋.——三毛《素人渔夫》</p><p>这几年，社会失去了很多玉女偶像。且不谈这种玉女偶像是否本身年龄界限对于维护这个玉女的形象已经接近崩溃的边缘，就接连在于他们身上发生的事情，也足以使这种形象破灭。网络上最可笑的言论就是：她们居然也有这一面。这句话到底什么意思呢？是否作为一个偶像，她将不再吃喝拉撒，她将不再交往，做爱，结婚，生子。无论一个人身份为何，都还是建立在一个人的基础之上。八卦杂志就以拍明星的某个瞬间丑态为乐，每个人都或多或少会碰到某些状况，而这些照片却能满足八卦读者平衡心理的良药，相较之下八卦读者应该是这个世界最好满足的一群读者了。因为只要给他们看一些“人之常情”，就能够带来他们精神无限的升华和满足。如此道来，八卦的杂志也算是一门功德事业了。只不过为何有这么多人存在于这种幻想的迷思之中，需要八卦这么浅显的杂志来点醒人的心智，让我十分疑惑。</p><p>回溯到这部电影，与其说塑造一个精神上的“纯”，不如说塑造了一个现实中的“伪”。也许这种纯真只可能存在于父母辈中被美化的记忆里面，却留给了我们后世无限的哀思和遐想。为了这份本不存在的场景，只好去虚构当年一份纯真美好的画面。只是这份“纯”，已经离“真”很远而已。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-9-20 10:06&lt;br&gt;对于我的电影审美，用最简单的形容方式就是：bin-bon-bian-bon-bon.所以像山楂树之恋这样的片子，我实在是看不进去的。不过这个号称“史上最干净的爱情故事”倒是确实值得玩味。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于纯爱这个名词，要定义似乎并不困难。列举再多的条件，其可以总结在四个字之上：“超凡脱俗”。当你的爱情一切与世俗隔离的时候，不再考虑性，金钱，门第之类存在于世俗层面上的东西，再配以精神上对于爱情恒古不变的追求和忠贞，那么也许你就能达到一个纯爱的标准。那以一名著的人物来看待这种纯粹追求爱情，似乎贾宝玉很合适吧。但是做这样的人物是要有资本的，而且有极大的资本。首先不用谋生，这点自不必多说，其次天赋异丙，谁能出生就含块玉呢？再则，社会体系中最高的当局必须支持你，红楼梦中的贾母是支持宝玉的。处在这么几个条件之下，你才有可能去追求所谓的纯爱。然则试问，一个人处在如此优越的条件之下，他也并非不在世俗之中，而是世俗达到某种极致之后，也就是纯爱出现之时。那么纯爱，不过是一种奢侈品。纯爱一点都不能成为批判社会爱情观沦落的象征，反而是爱情观沦落到极致的一种表现。当一切生理，物质的追求都得到满足了，就开始追求精神上难以满足的一种追求。这种难以满足的追求，让那些不为世俗所扰的人孜孜不倦罢了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>与天使打交道</title>
    <link href="http://bondaddy.github.io/2010/09/12/----73/"/>
    <id>http://bondaddy.github.io/2010/09/12/----73/</id>
    <published>2010-09-11T22:48:32.000Z</published>
    <updated>2019-12-19T01:41:19.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-9-12 06:48</p></blockquote><p>长久以来，我都觉得小孩是最接近天使的生物。现在想来，这几乎是一种偏见的思想。很多研究都表明小孩生来就会骗人，会观察父母的脸色来哭闹来达到自己的要求。而为什么对孩子会对此有如此的好感，可能是对于那份直率有着莫名的好感。长大了之后我们已经有很多事情不再敢说，不再敢表达了，不过这是否因为这个社会本身就给予了孩子直率的空间才使得孩子能够如此“放肆”？我们更加容易原谅孩子的莽撞和冒失，而对于身边的成年人会更加的苛求而已。</p><p>在多数的时候，我们似乎总会忽视一个特性，就是小孩的残忍性。前段日子看到有个QQ投票写的就是小时候做过的残忍事情，八成以上你都做过。回头想起来发现自己孩时做过残忍的事不胜枚举，而现在想来如此残酷的对待一条生命近乎于不可思议？在当时并不自觉。轰动的校园杀童案件有着一个非常明显的特征，就是那些疯狂的人专门对着孩子下手，犯罪现场是有成年人在场的，如果只是报复社会的无差别杀人，并不会忽略这些人，但这个杀人狂可以直接选择略过大人而直取小孩。这一点从心理上是对比自己弱势生物的一种凶残，而这份凶残在小孩身上同样有体现，孩子会天然的对于昆虫等这种比自己还要弱小的生物表现出凶残而缺乏怜悯。不清楚这种算不算人的一种本性，孟子曰：人性之善也，犹水之就下也。然而这个逻辑之中有一个天然的缺陷就是，人性之恶也，犹水之就下也。也就是这句话反过来说的时候是同样成立的，如果一个两面的观点都能成立的例子，是否还能够支持一个如此基础性的哲学思想。诸子们对于论述并不在行，习惯于举例子来印证道理，但有些引用的也并非恰当。</p><a id="more"></a><p>最近看少年犯罪的书籍，对于法律产生了新的迷惑。我们在孩时都拿到过一张叫做未成年人保护卡（证？），当时未成年人保护法的创立被誉为法律的一大进步。而我拿到这张卡的时候对此是非常疑惑的，我并没有记住这中间可以为我带来多少的保护，而我深深的记得是它把未成年人分割成不同的年龄。而这个年龄是犯罪的年龄，你于多少岁以下犯罪不受罚，多少岁以下轻罚。十三岁的时候我会对着这张卡片默念叨，如果这个时候我要杀人的话，我是不用负责任的，十四岁的时候我会遗憾，我已经十四岁了，我已经开始要负一部分责任了，乃至快到十八岁的时候，我会告诫自己，不能做出任何出格的事情，因为你马上就面临着全部的刑罚。回过头来看这个法律，结合我上面提到的，小孩的凶残更习惯于对待比自己更弱小的生物进行施加。那么少年犯罪有相当大一部分，被施加犯罪的对象同样是未成年人。法律对于成年人施加在未成年人身上的犯罪是要重罚的，而同样是未成年人对于未成年人的时候，这个惩罚却显得非常微薄。这一点上是否有着严重的矛盾？其实未成年人保护法的存在本身就很值得玩味，因为任何人伤害别人的时候，都应该受到法律的制裁。那么为什么要产生一个未成年人保护法这样的东西，如果深入思考一下就可以明白，这部法律居然不是用来保护受害者的，而是用来保护加害者的。就是说，这部法律更着重于让未成年人有改过自新的机会，让他们生命重新走上正常的生活轨迹而存在的，也就是一部少有的站在加害者一边的法律。对此也许会有人对我的论调不以为然，因为未成年人本身就不属于完全行为能力的人，所以他们对自己行为并不能完全负责，应该给予更多的宽容。然而就像我说的，这种法律问题不只是如此，这还挑战了我对于法律的一个神经：即法律面前人人平等。这个法律有很明显的间隔，就是14岁，16岁，18岁。这种划分从我的角度来看是相当不负责任的，因为可操作性能问题，犯罪的时候单纯的以年龄划分，其实不过是一个偷懒的方式而已，举个例子，一个差三天十六岁的孩子犯罪和满十六岁的孩子犯罪，他们面临着刑罚就是完全不同的。而谁有告诉我他们在行为能力上有着多少的差别呢？其实这点上并非不能区隔，我们在判定成年人犯罪的时候都应该去区分成年人的心理状况，但我们对于未成年人却简单的用年龄一刀切割，是否显得如此草率？我们难道不能够正确的区隔一下孩子犯罪时的动机是否属于自主意识的行为？说孩子不懂法律那更是扯淡，成年人非专业人士的也不懂法律。如果这点都可以说事那么大家都可以以此为借口来逃避法律的制裁，顺带一提的是，我对于精神疾病患者犯罪就不受罚也有微词，但这个不属于本文讨论的范畴了。</p><p>对于这样的法律存在，我感到一丝隐忧。这是否像我们纵容孩子天真那样在纵容孩子的犯罪呢？再过个三四年，我应该也会当上父亲，如果有别人家的孩子对我的孩子做出不可饶恕的罪行。我是否能够用他是未成年人这样的理由来说服自己？我很清楚国家的暴力机关是为维护法律的，因为法律是可能代表“正义”。但是法律是可以被不断修改的，由于能够被修改，就说明这并不是一个相对完善的“正义”。为了一个并不相对完善的事物而让有些人付出了惨痛的代价是否合理。请不要告诉我冤冤相报何时了这样轻松的话语，我认为法律应该更多的站在弱者和受害者的角度上看待问题，不是过多的去考虑加害者是否有改过自新的机会。过多的讲述饶恕，却忽略了那些被害者的心情。有些伤痛，是永远也弥补不回来的。而我对于加害者的心态是很简单的，如果你不明白别人的痛苦，那么就让你感受一次同样的彻骨之痛就好。</p><p>　　如果法律不可以制裁你们，请别得意忘形。因为正义的利刃从来都不会生锈，只是它将由不同的方式从天而降罢了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-9-12 06:48&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;长久以来，我都觉得小孩是最接近天使的生物。现在想来，这几乎是一种偏见的思想。很多研究都表明小孩生来就会骗人，会观察父母的脸色来哭闹来达到自己的要求。而为什么对孩子会对此有如此的好感，可能是对于那份直率有着莫名的好感。长大了之后我们已经有很多事情不再敢说，不再敢表达了，不过这是否因为这个社会本身就给予了孩子直率的空间才使得孩子能够如此“放肆”？我们更加容易原谅孩子的莽撞和冒失，而对于身边的成年人会更加的苛求而已。&lt;/p&gt;
&lt;p&gt;在多数的时候，我们似乎总会忽视一个特性，就是小孩的残忍性。前段日子看到有个QQ投票写的就是小时候做过的残忍事情，八成以上你都做过。回头想起来发现自己孩时做过残忍的事不胜枚举，而现在想来如此残酷的对待一条生命近乎于不可思议？在当时并不自觉。轰动的校园杀童案件有着一个非常明显的特征，就是那些疯狂的人专门对着孩子下手，犯罪现场是有成年人在场的，如果只是报复社会的无差别杀人，并不会忽略这些人，但这个杀人狂可以直接选择略过大人而直取小孩。这一点从心理上是对比自己弱势生物的一种凶残，而这份凶残在小孩身上同样有体现，孩子会天然的对于昆虫等这种比自己还要弱小的生物表现出凶残而缺乏怜悯。不清楚这种算不算人的一种本性，孟子曰：人性之善也，犹水之就下也。然而这个逻辑之中有一个天然的缺陷就是，人性之恶也，犹水之就下也。也就是这句话反过来说的时候是同样成立的，如果一个两面的观点都能成立的例子，是否还能够支持一个如此基础性的哲学思想。诸子们对于论述并不在行，习惯于举例子来印证道理，但有些引用的也并非恰当。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>挥之不去的伤感</title>
    <link href="http://bondaddy.github.io/2010/09/05/----72/"/>
    <id>http://bondaddy.github.io/2010/09/05/----72/</id>
    <published>2010-09-05T05:23:32.000Z</published>
    <updated>2019-12-19T01:41:19.704Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-9-5 13:23</p></blockquote><p>受到好多负面情绪的冲击，有些不值一提，但有些却值得铭记。</p><p>向所有为这片土地洒过热血的先烈们，后生在这里向你们叩首，阿Q并不代表民族性，狼图腾那种法西斯也不值得学习，而你们我抱以深深的致敬。谁认为中国缺乏尚武的精神？希腊人还在做梦在神话里交配的时候，我们已经在几十万的战场上互相坑杀了，这是个早熟的民族，什么样的腥风血雨没有经历，什么样的权谋斗争没有使过。过早的流干了鲜血，过早的见识了这份残酷。当然会变得谨慎，当然会变得惧怕。人命不再是数字的概念，每一个生命都值得尊重。自上而下的教育应该埋葬，不要再喊为了集体的利益而牺牲个人，如果总是如此，那么到底什么是集体的利益？是否满足某些少数的私欲就是所谓的集体利益？集体中包含着每一个个人的利益，只有当所有人的利益都得到了保障，才有所谓集体利益的存在。没有什么大公无私，只有确保了每个人的“私”，才能实现所谓的“公”。</p><a id="more"></a><p>国虽大,好战必亡,天下虽安,忘战必危。前几天韩国货轮撞沉我国的渔船，我们的外交部继续和播报器一样说着：我们严重关切，我们严重交涉。永远都是这种话让人感觉外交部是否做的太容易，没事就慰问，有事就关切。翻来覆去如此，如何不让国人认为这是种无能的表现。即便做了什么具体工作，却也觉得这些不足以对国人说道。总是认为政府是保姆型的政府，可惜却不明白要做保姆型的政府，那么对于政府的道德要求是非常高的。如果你要做保姆，那么你就必须是圣贤型的，问题是现在国家混乱不断，正道消息从不流露，那么小道传闻自然漫天遍野。这些传闻自然有损于人民对国家的信心，对国家的期待。现在国民有种意识，我们强大了，我们不再受欺负了，百年积弱总算轮到我了，就像有人穷了一辈子的人突然中了五百万，其心理问题是必然补偿过去所有的辛苦，将所有没做过事情都做一次，“好你个高丽棒子敢撞我们船，不揍你不知道谁是爷了”。这种思想的危险，这种情绪的浅薄。但是又是谁教导了人民这种土财主的思想呢？不就是所谓的正统传媒天天报道的祖国强盛了，祖国领导都很忙，祖国想揍谁就揍谁。愤青就没想过一旦开战，石油管道立刻会被切断，我们的石油储备只能坚持七天，我国石油战略储备计划根本没有完成。汉武帝集六十年之力才敢言犯我强汉者，虽远必诛。我朝有什么，改革开放三十年前二十年在梦游开会，后十年在生产裤衩娃子和芭比娃娃。GDP全是没有国防力量的GDP。号称世界第二的GDP？美国的科技，英国的金融，德国的工业，中国的芭比娃娃。如果这也能并列的话我只能说最后我们依旧要靠我们的血肉继续组成我们新的长城，然后再忘恩负义的对战后可怜的老兵不闻不问。只是有了现在心寒的境遇之后，不知道我们民族是否还有像先烈一般的人愿意挺身而出去组建血肉的长城了。</p><p>一寸山河一寸血。最近看民国史，学生的游行，工人的罢工，花魁的宣传，军阀的抗争，全都是最最普通的面孔，虽然被人有种无意识的导向，唆使。但是满腔的血性，则让我看到了中华的魂魄。我绝不认同什么抗日战争如此艰苦是因为汉奸太多，更不觉得我们的先烈打的战争是可耻而失败的战争。我们在抗战换取了世界的尊重，就是但这样的尊重，又是建立在怎样地基础上？成千上万的士兵阵亡，成队成队的士兵殉国。一寸山河一寸血，这是民族最悲壮的口号，是无数国军用生命换来的。而我们到现在为止不要说没有搞清楚他们每个人的名字了，连我们的数字都没有搞清楚。日本的靖国神社你可以仇恨，但他们每一个阵亡将士的名字，事迹全部的记录在案。而我们连数字自己都能吵的不可开交，南京大屠杀日本根本不承认有过这种罪行，因为你说我杀这么多人那你统计出名字来告诉我确实死亡这么多人，而这个工作又有谁去实现了。国家在抗战中直到美国参战后才对日宣战，而根据日内瓦公约，没有宣战的国家是没有战俘这一说法的，所以在很长的时间以来我们的被俘的将士都被日本人虐杀到死。而这里到底有多少人根本不清楚，不清楚到精确到百万这个计量单位都精确不到。为什么没有去做，是不能，还是不想？为什么不想？数十年过去了，孟良崮那还写着“击毙张灵甫之地”，每闻与此，只能伤感。</p><p>九月三日那天，QQ消息弹出对每个抗日老兵补助三千多元。我轻笑了一下，思维很自然的反应是每个月不足三百，还不是年年都有。现在还有多少的抗日老兵呢？真的是走一个就少一个了。我们造个铁裤衩一百亿，公款吃喝每年九千亿，我们的老兵补助三千块。呵呵，Good Job !</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-9-5 13:23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;受到好多负面情绪的冲击，有些不值一提，但有些却值得铭记。&lt;/p&gt;
&lt;p&gt;向所有为这片土地洒过热血的先烈们，后生在这里向你们叩首，阿Q并不代表民族性，狼图腾那种法西斯也不值得学习，而你们我抱以深深的致敬。谁认为中国缺乏尚武的精神？希腊人还在做梦在神话里交配的时候，我们已经在几十万的战场上互相坑杀了，这是个早熟的民族，什么样的腥风血雨没有经历，什么样的权谋斗争没有使过。过早的流干了鲜血，过早的见识了这份残酷。当然会变得谨慎，当然会变得惧怕。人命不再是数字的概念，每一个生命都值得尊重。自上而下的教育应该埋葬，不要再喊为了集体的利益而牺牲个人，如果总是如此，那么到底什么是集体的利益？是否满足某些少数的私欲就是所谓的集体利益？集体中包含着每一个个人的利益，只有当所有人的利益都得到了保障，才有所谓集体利益的存在。没有什么大公无私，只有确保了每个人的“私”，才能实现所谓的“公”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>你好，花脸道</title>
    <link href="http://bondaddy.github.io/2010/08/25/----71/"/>
    <id>http://bondaddy.github.io/2010/08/25/----71/</id>
    <published>2010-08-24T21:22:32.000Z</published>
    <updated>2019-12-19T01:41:19.696Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-8-25 05:22</p></blockquote><p>为见证时间的过去，为见证自己的成长，干杯欢呼。我和你比，你已经死了，我却超越了。</p><p>这么写好像和前天的说法完全的相反，不过当我回顾《你好，花脸道》的时候，发现现在穿越真是一个好东西。当然基本都是穿越过去，而不是穿越未来。因为未来在几年内就会被彻底的实现，而过去却从来不会被改写。一个简陋的校园社区，居然让我当年流了口水和心生向往。这充分说明了我当年的纯情和天真。而现在属于伪业内人士的我，看到这个webx.x的年代，不得不感慨一下。发展的效率几乎让我连回味往事的时间都没有，我自然的在几个网络社区之间切换来切换去。并且提供了让我寻求符合自己交友需求的一切便利。前几天在人人网上看到各位小学同学的近照时，不得不说，福州这么小，我们永远碰不到，网络这么广，我想找谁就找谁。这么看来我是否应该发帖求助一些事情，比如当年我们魔居的同仁们，我知道你们都比我大上十岁，但是一把年岁的玩QQ也多的是，别在网海里装了，出来冒个泡如何，在我难过的人生一个阶段里，感谢你们和我胡扯瞎掰，以及那个轻狂岁月的一切。</p><p>话说回来，现在的变迁不回首则毫无感触，一回首才发现真是一日千里。在我已经开始混网络的初始，我还穷极无聊的在一本杂志中寻找可以交往笔友的对象。当然由于自己的字被人说太“丫”，所以收到的回信真是寥寥无几。但即使在这个情况之下，我也依旧还是有几个笔友。笔友这个词对现在是有多么陌生。一个月内才可能有一次的交流，必然会格外的珍惜里面留下的话语给对方的印象。而当年的见识却让我很难说出新奇的事物和有趣的话语。所以就会一遍遍的打稿，然后再尽量公正的抄正。走到邮箱前投递的那一份感触，现在想来骚包不已。要恢复那种悠哉悠哉的心情，一份不知何时来自远方的惊喜和投递出去后那一份真诚的期待，无论如何也追不回来了。</p><a id="more"></a><p>人和人的距离到底是近了还是远了，很多道学人士都在担心我们这代人。但就是这个让我们感觉冷漠的世界，我们用网络的各种社区联系着彼此，而这样社区的火爆不正显现了我们对和人交流的渴望。人是社会性的动物，这个话近乎于白烂的常识，但是这个社会是现实社会抑或是网络社会其本质已经不在重要。因为人天然就有和别人分享自己生命的渴望，人还是必须由投射在别人身上自己的影子来寻求自身的一种存在感的，而这种存在感在被一个社区所认可的时候，其程度就会骤然提升到一个高度。以至于满足了时候就会容易疏离对现实世界的渴望。当然任何方式都是在相互转换的过程，现实和网络已经变得模糊起来，也难以像过去一般单纯的区分网络和现实了。开始父母还老是由于社会上的报道对我再三警告不要和网友见面，而现在各种社区组织活动的见面形式几乎已经不值得进行讨论，而父母们自己走进网络的时候也自然而然的从网络社区发展成车友，酒友等等现实社会团体。网络的浪潮来的时候，近乎于所有人都逃不掉，不像过去的某种事物，带着强烈的年龄断层和时代感。这充分的表明了网络的包容性能满足各种类型的人。将来我们的世界再往哪个方向走我是看不到，因为即使看到了端倪，也会很快被超越成为生活的一个习惯，而面对飞速进展的时代时，还在怀念着过去笔友一封封鬼扯的我，年华老去…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-8-25 05:22&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为见证时间的过去，为见证自己的成长，干杯欢呼。我和你比，你已经死了，我却超越了。&lt;/p&gt;
&lt;p&gt;这么写好像和前天的说法完全的相反，不过当我回顾《你好，花脸道》的时候，发现现在穿越真是一个好东西。当然基本都是穿越过去，而不是穿越未来。因为未来在几年内就会被彻底的实现，而过去却从来不会被改写。一个简陋的校园社区，居然让我当年流了口水和心生向往。这充分说明了我当年的纯情和天真。而现在属于伪业内人士的我，看到这个webx.x的年代，不得不感慨一下。发展的效率几乎让我连回味往事的时间都没有，我自然的在几个网络社区之间切换来切换去。并且提供了让我寻求符合自己交友需求的一切便利。前几天在人人网上看到各位小学同学的近照时，不得不说，福州这么小，我们永远碰不到，网络这么广，我想找谁就找谁。这么看来我是否应该发帖求助一些事情，比如当年我们魔居的同仁们，我知道你们都比我大上十岁，但是一把年岁的玩QQ也多的是，别在网海里装了，出来冒个泡如何，在我难过的人生一个阶段里，感谢你们和我胡扯瞎掰，以及那个轻狂岁月的一切。&lt;/p&gt;
&lt;p&gt;话说回来，现在的变迁不回首则毫无感触，一回首才发现真是一日千里。在我已经开始混网络的初始，我还穷极无聊的在一本杂志中寻找可以交往笔友的对象。当然由于自己的字被人说太“丫”，所以收到的回信真是寥寥无几。但即使在这个情况之下，我也依旧还是有几个笔友。笔友这个词对现在是有多么陌生。一个月内才可能有一次的交流，必然会格外的珍惜里面留下的话语给对方的印象。而当年的见识却让我很难说出新奇的事物和有趣的话语。所以就会一遍遍的打稿，然后再尽量公正的抄正。走到邮箱前投递的那一份感触，现在想来骚包不已。要恢复那种悠哉悠哉的心情，一份不知何时来自远方的惊喜和投递出去后那一份真诚的期待，无论如何也追不回来了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>No thanks</title>
    <link href="http://bondaddy.github.io/2010/08/23/----70/"/>
    <id>http://bondaddy.github.io/2010/08/23/----70/</id>
    <published>2010-08-22T18:33:32.000Z</published>
    <updated>2019-12-19T01:41:19.689Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-8-23 02:33 </p></blockquote><p>回来突然有了点失落，这份失落简直不可思议，好像一直对生活满意，对工作满意，对家庭满意。那到底是对什么开始不满意的，想了半天开始发现是对自己不满意了。</p><p>似乎对自己的要求有点低了，说着话似乎应该脸红了。因为其实我对自己的要求一直很低，除了偶尔会反省自己和自己的期望相去甚远，其余大部分的时候我都在喜欢自己。喜欢自己的慵懒，喜欢自己的思想，喜欢自己的选择。在这个喜欢的过程中，却也可以慢慢的走向不喜欢自己的路。果然那个结论下的很对，就是不断肯定自己和不断否定自己的过程，这条路纠结下去，感觉是泥泞交错。</p><p>满意也好，不满意也好，似乎不是能力的变化，而是心态的转变。有时候我觉得这些都没有所谓，那我就满意了。当有所谓的时候就不满意了，那我的满意是不是只是在放纵自己而已。我应该对自己有要求的，起码我笑着谈的话也是好好活着。最近好像连这一点也没有认真的去做到。保持健康，我的生活健康吗？八点睡到十一点，玩到三点，再睡到八点。我的自律性在哪里，是跟随着别人不认可的道路也一样走上自律的道路。但在正常的时间轨迹里并不是我能左右一切的。比如八点到十一点我总会有很多时间拖延或者妨碍我的轨迹，换句话说，当有冲突的时候，我并不容易的遵守轨迹。按部就班的道路也许不适合我，但适合我的道路产生迷惑的时候是否就要退回到按部就班。</p><a id="more"></a><p>今天玩狼人杀的时候，星月牌翻出了长辈不参与投票的效果。突然发现自己已经老掉了。我由于早于一般人读书，在自己的圈子里从来没有过这种感受，今天感受到自己在圈子里平均年龄之上的时候，感觉时间真的不多了。我一直觉得没有时间了，一直又在浪费着自己的时间。当今天举手的感触突然冲击到了自己脆弱的神经。是啊，我也不小了。不能在那么自我安慰自己的按部就班自己的道路。我确定要这么蜗牛吗？我确定自己还年轻吗？三天后我二十四。拍拍自己，确实不小了。</p><p>做什么事情就专心去做吧，珍惜时间吧，时间真的不够的，对的，就像你说的那样，我之所以时间不够是因为我要浪费很多时间才开始变得有动力。那样成长太慢了，浪费的时间第一次让我心慌。此时此刻，你会笑着和我说差不多时间到了吗？那么就约定好时间到了就应该怎么走。不要浪费时间了。没有时间了，时间太少了。天天追逐你的，开始流逝了。你和那些四十岁的人差多少，你和那些三十岁的人差多少，你和你同年龄的人又差多少。开始恐惧了吧，呵呵。</p><p>知耻而后勇还是好同志？但我现在没有为自己的过去感觉到耻辱，我却只是单纯的对着自己的将来感觉到恐惧。每天的进步真的太慢了，我是否离你越来越远了。如果要研究心学就去研究吧，如果要去考察隋唐政治史就去考察吧。你眼前的事情怎么那么多，随着那个雨季突然下来的瓢泼，一切是否都如预期的那样回流呢。我连雨季都没等到，就要出发了，舔舔嘴唇是不是不敢迈出去这个步伐？我不会再错过你了。你将不再是麻烦，你将不再是恐惧，你会是回流我生命的勇气，一点点的浸透我的灵魂。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-8-23 02:33 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回来突然有了点失落，这份失落简直不可思议，好像一直对生活满意，对工作满意，对家庭满意。那到底是对什么开始不满意的，想了半天开始发现是对自己不满意了。&lt;/p&gt;
&lt;p&gt;似乎对自己的要求有点低了，说着话似乎应该脸红了。因为其实我对自己的要求一直很低，除了偶尔会反省自己和自己的期望相去甚远，其余大部分的时候我都在喜欢自己。喜欢自己的慵懒，喜欢自己的思想，喜欢自己的选择。在这个喜欢的过程中，却也可以慢慢的走向不喜欢自己的路。果然那个结论下的很对，就是不断肯定自己和不断否定自己的过程，这条路纠结下去，感觉是泥泞交错。&lt;/p&gt;
&lt;p&gt;满意也好，不满意也好，似乎不是能力的变化，而是心态的转变。有时候我觉得这些都没有所谓，那我就满意了。当有所谓的时候就不满意了，那我的满意是不是只是在放纵自己而已。我应该对自己有要求的，起码我笑着谈的话也是好好活着。最近好像连这一点也没有认真的去做到。保持健康，我的生活健康吗？八点睡到十一点，玩到三点，再睡到八点。我的自律性在哪里，是跟随着别人不认可的道路也一样走上自律的道路。但在正常的时间轨迹里并不是我能左右一切的。比如八点到十一点我总会有很多时间拖延或者妨碍我的轨迹，换句话说，当有冲突的时候，我并不容易的遵守轨迹。按部就班的道路也许不适合我，但适合我的道路产生迷惑的时候是否就要退回到按部就班。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>嘿，好久不见</title>
    <link href="http://bondaddy.github.io/2010/08/10/----69/"/>
    <id>http://bondaddy.github.io/2010/08/10/----69/</id>
    <published>2010-08-09T17:32:32.000Z</published>
    <updated>2019-12-19T01:41:19.681Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-8-10 01:32</p></blockquote><p>我曾经说过，我们是最好的朋友，这一点，我到现在也和以前那么想着。虽然我们已经相形渐远，这一点一直都没有改变。</p><p>今天听到你的消息了，搞坏了我的心情，有些事情我也不明白该怎么去判断，懂得越多，对于下判断就越发谨慎。我曾经也单纯的认为你是崇洋媚外的小孩，但现在我也会无聊的喊着崇尚美国的自由。这一切还有那一切都是一种讽刺，现在的学识在讽刺着过去的无知，而将来的成熟又在嘲笑现在的轻狂。所以我相信现在的我，会比过去更加理解你的心情。</p><p>对于你的事情我不知道如何你规劝，因为我不希望你丧失对生活反抗的勇气。如果你对现在生活已经不再满意，那应该懂得如何去反抗。你还年轻，你还可以的。看看镜子中的自己，是否还那么朝气蓬勃呢。犹如那个企鹅一样继续摇摇摆摆。也许我现在还这么看你就代表的我已经离你的生活很远的。但是我觉得人在什么时候保持一份赤子之心并不是一件坏的事情。起码我们对生活还有希望，最近有人说前面都是阴影请不要担心，因为你的后面就是光。我一直不反对任何形式的幸福，哪怕这种幸福带着许多人的不解。但是这个幸福请确实是你自己的幸福，不抱怨。站在外面指教别人的幸福是件容易的事情。这样说着话的我多少有点不负责任，我只能说我的心情你应该能理解的吧。当你踏上征途的时候你就该知道前面一定是千难万险，然而走到现在是否还没有偏离你最初的梦想，如果你还向往着自由，那你是否还能仰望星空放声歌唱。</p><a id="more"></a><p>人生一世，犹如白驹过隙，我知道你是很信神的人。但这份信仰是否真实的换来心灵的安定呢，还是像着过去那样赌博式的听天由命。请把生活掌握在自己手里吧。这个话我即使说无数次你可能也听不进去。我能理解你对生活的那份不安，但是因为这一点实在太过于重要。所以我唯有重复重复再重复。直到你明白这一点，我才会觉得有那么一点点心安。</p><p>某些时候我确实是很贱的人，我和朋友的交际真的很少。我可以和朋友老死不相往来，但是我不能容忍我的朋友和我不在一个城市里面，因为我觉得在仰望同样一片星空的时候。我们都会一直在一起，只有你在离我最远的地方，此时此刻我不再关心外国的月亮是否圆润。我只是厌恶这份距离带来的恐惧。我尝试的笑的知道你离开的消息，那是因为我希望在时间的下一刻让我等到你回来，然后我也会笑着对你说：嘿，好久不见。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-8-10 01:32&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我曾经说过，我们是最好的朋友，这一点，我到现在也和以前那么想着。虽然我们已经相形渐远，这一点一直都没有改变。&lt;/p&gt;
&lt;p&gt;今天听到你的消息了，搞坏了我的心情，有些事情我也不明白该怎么去判断，懂得越多，对于下判断就越发谨慎。我曾经也单纯的认为你是崇洋媚外的小孩，但现在我也会无聊的喊着崇尚美国的自由。这一切还有那一切都是一种讽刺，现在的学识在讽刺着过去的无知，而将来的成熟又在嘲笑现在的轻狂。所以我相信现在的我，会比过去更加理解你的心情。&lt;/p&gt;
&lt;p&gt;对于你的事情我不知道如何你规劝，因为我不希望你丧失对生活反抗的勇气。如果你对现在生活已经不再满意，那应该懂得如何去反抗。你还年轻，你还可以的。看看镜子中的自己，是否还那么朝气蓬勃呢。犹如那个企鹅一样继续摇摇摆摆。也许我现在还这么看你就代表的我已经离你的生活很远的。但是我觉得人在什么时候保持一份赤子之心并不是一件坏的事情。起码我们对生活还有希望，最近有人说前面都是阴影请不要担心，因为你的后面就是光。我一直不反对任何形式的幸福，哪怕这种幸福带着许多人的不解。但是这个幸福请确实是你自己的幸福，不抱怨。站在外面指教别人的幸福是件容易的事情。这样说着话的我多少有点不负责任，我只能说我的心情你应该能理解的吧。当你踏上征途的时候你就该知道前面一定是千难万险，然而走到现在是否还没有偏离你最初的梦想，如果你还向往着自由，那你是否还能仰望星空放声歌唱。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>小撰</title>
    <link href="http://bondaddy.github.io/2010/07/19/----68/"/>
    <id>http://bondaddy.github.io/2010/07/19/----68/</id>
    <published>2010-07-19T01:13:32.000Z</published>
    <updated>2019-12-19T01:41:19.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-7-19 09:13</p></blockquote><p>我国的城管一直都以一个负面形象在人民的心中,甚至于”城管”这个词汇就已经是单纯的贬义词.我不以为这是城管这个编制的错误,而纯粹是我国法律的悲哀.城管所”管辖”的,往往都是社会最下层的人民.他们靠着自己艰辛在城市中寻求一点生存的出路.但这点在法律的规定下是不允许的,很多时候时候我为此感到惋惜.我们的法律在对于弱势的群体制裁一向快速有效.但对于更多的社会毒瘤,却只能视而不见.这种轻软怕硬的执法群体,就只能执行着这些片面性的法律.在人民的白眼下做着等同于犯罪的行为.</p><p>我们的宪法保障了人民的私有财产不被侵占的权利.我们的宪法保障了人民有不受他人伤害的权利.作为法盲,我想有个基本常识就是,宪法是国家的根本大法,所有与宪法违背的法律均将视为无效.更何况我到现在都无法查到天桥摆摊一样的行为究竟触犯了哪条法律.就算触发了相关的法规,也应当有相应的处罚条例来惩处,城管应该没有代行处罚的权利.但我每当看到那些被砸烂的货物,被打伤的人民,被没收的货车.我都为这些人们以后的生活担忧.他们真的很坚强.但是为了这份坚强他们究竟又付出了多少血汗.</p><a id="more"></a><p>人们有活下去的权利.而国家应该有义务让所有人活下去.如果有人说国家没有这个义务.那国家又何必在意失业率这个”没有意义”的问题.但当我们刻苦耐劳的人民已经没有办法用正常的渠道获取一份报酬的时候,他们只好用自己微薄的力量去开辟一条游走在法律边缘的道路.也许这些都不值得称道.但是否应该给予一定的宽容.他们只是想活下去而已.并没有过分的要求.如果只是减少了一些人的”方便性”.那么,是否可以让一些步.我们已经拥有了比他们多的多的社会资源可以使用,而他们却在那份出生就带来的不平等之中寻求生存而已.</p><p>总理说新的一年让人民活的更有尊严一点,我听了很感动,因为我相信国家不是没有明白人.但心里却暗暗的想着:很难.即得利益者是不会放开手中的任何一点利益.而那些贫苦人民依旧要在生活线上苦苦挣扎.尊严在很多时候成为了一个奢侈品.在我们的国家里面.我们要面对着太多太多的不确定性,这种不确定性丧失了祖国的温暖.并让绝大多数人永远的暂住在了自己的国家.但却不因为很难,就变得没有努力的必要,没有努力的方向.CharlesdeSecondat．BarondeM Ontesquieu永远是我心中最伟大的人物之一,他的不朽著作&lt;&lt;论法的精神&gt;&gt;里面不断传诵的话语在这里献给我爱的国家,我希望您真的在成长,成长到我们都将以你为我们的骄傲.</p><p>　　</p><p>　<strong>一个公民的自由是一种心境的平安状态,这种心境的平安状态是从人人认为他本身是安全的这个角度出发的,要想享有这样的自由,就必须建立一个这样的政府:在它的统治下,一个公民不惧怕另一个公民. — &lt;&lt;论法的精神&gt;&gt;</strong>                                                                                                                                                                   　　　　　　　　　　　　　　　　　　　　　　　　　</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-7-19 09:13&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我国的城管一直都以一个负面形象在人民的心中,甚至于”城管”这个词汇就已经是单纯的贬义词.我不以为这是城管这个编制的错误,而纯粹是我国法律的悲哀.城管所”管辖”的,往往都是社会最下层的人民.他们靠着自己艰辛在城市中寻求一点生存的出路.但这点在法律的规定下是不允许的,很多时候时候我为此感到惋惜.我们的法律在对于弱势的群体制裁一向快速有效.但对于更多的社会毒瘤,却只能视而不见.这种轻软怕硬的执法群体,就只能执行着这些片面性的法律.在人民的白眼下做着等同于犯罪的行为.&lt;/p&gt;
&lt;p&gt;我们的宪法保障了人民的私有财产不被侵占的权利.我们的宪法保障了人民有不受他人伤害的权利.作为法盲,我想有个基本常识就是,宪法是国家的根本大法,所有与宪法违背的法律均将视为无效.更何况我到现在都无法查到天桥摆摊一样的行为究竟触犯了哪条法律.就算触发了相关的法规,也应当有相应的处罚条例来惩处,城管应该没有代行处罚的权利.但我每当看到那些被砸烂的货物,被打伤的人民,被没收的货车.我都为这些人们以后的生活担忧.他们真的很坚强.但是为了这份坚强他们究竟又付出了多少血汗.&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>跟不上的时代</title>
    <link href="http://bondaddy.github.io/2010/07/14/----67/"/>
    <id>http://bondaddy.github.io/2010/07/14/----67/</id>
    <published>2010-07-14T01:39:32.000Z</published>
    <updated>2019-12-19T01:41:19.662Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-7-14 09:39</p></blockquote><p>突然发现时代的变化已经让我应接不暇，这似乎是一个我老了的讯号，其实像我这种偏自闭的人，世界怎么变化我是不太去管的。我关心的我记录，我不关心的我无视。不过这么大的变化不加以记录的话，实在说不上是一个观察者应有的态度。</p><p>微博其实不算个新鲜事物了，但像我这种后知后觉的人，也是到了今年年初的时候才去很傻逼的百度了一下什么叫微博。诚然我当初认为这是一个很牛逼的东西，一个随时随地让自己与世界同在的东西。具体做什么，为什么，牛什么。我没研究，也没时间研究。而到了我真正看到微博的时候，我对其是很失望的，我根本不了解里面的意义。一个只有140字的聊天模式的东西，为什么就如此红火。140字，对于我这样混BBS回复都不只这点含字量的人实在是不够用，但是无数人却可以使用这140字表达出了自己很多很多的想法，虽然在我眼中都是水贴般的废话以及不着边际的空话。但依旧让人们乐此不疲。我明白人都有表达的欲望和分享的欲望。一个随时随地让你和朋友分享的东西，确实能极大的满足自己的表达欲。而这个表达欲的及时性和传播的扩张性也让人们很快摈弃了旧有分享的模式。有事微博没下，没事看别人微博一下。从那一刻起我们超越了时间，空间，我们让网络融入了生活的毛细血管中。无时无刻的出卖了自己的生活，无时无刻的窥探别人的生活。而这种窥探在于新型手机的帮衬下，我们甚至超越了地域的限制。小妞，别反抗了，我是有背景的人。大爷，别逗了，我是有微博的人。为什么我是个有微博的人，因为我不在这里，我有微博，我将不在这里，我将于大家同在，而且我将把你拉得与大家同在，在大家同在的时代，我们就是裸露下黑夜下的躯体，追逐着暗藏在黑夜里的光束，默默的明处注视着别人的一举一动，并出卖着自己的一举一动。我们不能通过毁灭世界达成的灵魂共有，却在网络之间慢慢的融合起来。将自己的灵魂投散在各个灵魂之间，达成共鸣。</p><a id="more"></a><p>我知道豆瓣其实相当的早，但是我个人对于一切豆类以及类豆类植物的排斥，乃至于眼中掉对豆这个字眼都极度的敏感，甚至于反感，记得小时候还有一个词令我反感，就是豆蔻年华，所以我一直没有加入豆瓣的社区。不过我了解豆瓣的道路却很新颖。从豆瓣的网络编程技术角度去了解豆瓣的。敏捷型开发模式也曾经让我醉心不已。但这不是重点，重点在于豆瓣的模式。虽然现在看起来豆瓣的模式已经不算新颖。但是在当时，作为web2.0的进化者，在我眼中它是个将共享内容发挥的很好的站点。在参与信息产品的创造、传播和分享的过程中创造价值。而不同的人抱着不同的心理来构建的世界将线下和线上的世界结合起来确实令我觉得值得玩味。用更简单的方式来说，豆瓣就是BBS的进化版本，它将集群模式更便捷的提供给网站的使用者，将本身由网站的开发者需要寻求的主题开放给大众来开发。这样集结了更多的思维，创造出了更多新颖的团体和社群，让更多的受众都在一个网站中达成了自己创立团队的目的，也让更多人在同一个网站中更容易的寻求到了自己志同道合的伙伴。在伴以三条明线（电影，音乐，读书）和一条暗线（同城）加以连接各个独立的团体。这个产品对于生活在自己城市本身就有完善一套生活圈子的人来说可能并不是最重要的，但是对于那些生活在异地或者心灵本身就相对空虚的人们来说，寻求自己的团队就极其的重要，人毕竟还是社会性的动物，在一个群体当中找到自己的存在感是很重要的事情，而这个事情在于生活中寻求认同已经越来越不容易的时候。就转而到网络之间寻找更容易接纳彼此的团队。由于更容易，大家更愿意加入，也由于这份容易，使得这份接纳变得如此的廉价。混豆瓣的人都有着无时无刻显现的伪小资范。在伪小资范的阴霾下，格局未免就小了很多，这点可以从三条明线之间展露无遗，其本质既是神色犬马和纸醉金迷的产物，而在那条暗线下达成一种契机在现实中实例化。若寻求这之间有多少人与人之间抱着不正当的心态在社区的伪装下想着猥亵的勾当，就应当能明白这份格局的脆弱。</p><p>世间的变化确实很快，李开复的那句：世界因你而不同让我看出了一个人对自己自信的极致。但由于我的专业问题，所以看待网络的发展却有着自己独道的角度和看法。网络的发展从根上就是一个共享。而我们不管是web X.X的版本概念，都是将这个共享的概念发展到极致。而这些不断改变我们生活形态的事物，其实就是一步步的走向网络最后的理想：我们共享了我们的全部。从服饰，饮食，居家到理念，创意，梦想，乃至我们的一切一切。全部都被这个网络肢解，共享。如果将这些信息全部收集起来，足以构建出一个强壮的世界。而这个健壮的世界足以慢慢的架空我们现实的世界。我们经常可以看到一群人坐在一桌子里，各自拿着各自的手机，玩着类型不等却又极其相似的游戏。将自己投射在网络上空而无视了现实的存在的空间。虽然现在，无数人还会把网络世界发展到线下的世界以获得感官上最大的冲击。不过以这个世界的发展，如果感官都可以100%的投入网络的时候，是否就会真正进入那个可怕的科幻世界，我们躺在一个个机器当中，将自己的身体的全部都分享成网络的信息，我们的睡眠欲，食欲，性欲都将在网络中被彻底的实现。我们是否就将不再期盼这个令人厌倦的世界有什么而彻底的沉迷在这个网络的世界之中。一旦网络世界的倒塌，我们从破损的机器之中爬出来的时候，看着身上腐烂的躯壳，是否会认为这是现实世界的末日？我想这并不是危言耸听，已经有很多人离开网络就会感觉自己的世界开始不完整。而这个时候，网络还没有实现我们种种的原始欲，一旦这些原始欲都已满足，就必须寄希望于网络的世界足够健壮了。虽然我认为世界如果因此而毁灭也没有什么不好的，起码，他们在毁灭的时候，还是幸福的吧。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-7-14 09:39&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;突然发现时代的变化已经让我应接不暇，这似乎是一个我老了的讯号，其实像我这种偏自闭的人，世界怎么变化我是不太去管的。我关心的我记录，我不关心的我无视。不过这么大的变化不加以记录的话，实在说不上是一个观察者应有的态度。&lt;/p&gt;
&lt;p&gt;微博其实不算个新鲜事物了，但像我这种后知后觉的人，也是到了今年年初的时候才去很傻逼的百度了一下什么叫微博。诚然我当初认为这是一个很牛逼的东西，一个随时随地让自己与世界同在的东西。具体做什么，为什么，牛什么。我没研究，也没时间研究。而到了我真正看到微博的时候，我对其是很失望的，我根本不了解里面的意义。一个只有140字的聊天模式的东西，为什么就如此红火。140字，对于我这样混BBS回复都不只这点含字量的人实在是不够用，但是无数人却可以使用这140字表达出了自己很多很多的想法，虽然在我眼中都是水贴般的废话以及不着边际的空话。但依旧让人们乐此不疲。我明白人都有表达的欲望和分享的欲望。一个随时随地让你和朋友分享的东西，确实能极大的满足自己的表达欲。而这个表达欲的及时性和传播的扩张性也让人们很快摈弃了旧有分享的模式。有事微博没下，没事看别人微博一下。从那一刻起我们超越了时间，空间，我们让网络融入了生活的毛细血管中。无时无刻的出卖了自己的生活，无时无刻的窥探别人的生活。而这种窥探在于新型手机的帮衬下，我们甚至超越了地域的限制。小妞，别反抗了，我是有背景的人。大爷，别逗了，我是有微博的人。为什么我是个有微博的人，因为我不在这里，我有微博，我将不在这里，我将于大家同在，而且我将把你拉得与大家同在，在大家同在的时代，我们就是裸露下黑夜下的躯体，追逐着暗藏在黑夜里的光束，默默的明处注视着别人的一举一动，并出卖着自己的一举一动。我们不能通过毁灭世界达成的灵魂共有，却在网络之间慢慢的融合起来。将自己的灵魂投散在各个灵魂之间，达成共鸣。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>现在是五点零八分</title>
    <link href="http://bondaddy.github.io/2010/07/14/----66/"/>
    <id>http://bondaddy.github.io/2010/07/14/----66/</id>
    <published>2010-07-13T21:14:32.000Z</published>
    <updated>2019-12-18T09:58:38.875Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-7-14 05:14</p></blockquote><p>我一晚上没睡，并非来自突如其来的自省。</p><p>突然感觉自己自制力很差，总是挥霍，然后弥补。欠你的人生，欠他的人生，欠我的人生，我眼睛已经开始花了。</p><p>我已经不打算睡了，但是我还是有点困，这么矛盾，其实我还能睡两个小时左右。</p><p>我看着他们笑笑的样子，说着反正天亮了，就不要睡了。我感觉我看到了偶像。</p><p>打算切实的按照自己的计划去做，不要赖在床上什么都不做，就算我去了，也只会有好事发生，要相信这一点。</p><p>迷迷糊糊，迷迷糊糊的，感觉还有微笑的力量，这个时候，应该可以怀着感恩的心情继续下去。</p><p>现在是五点十四分，你好七月十四号的早晨，希望你今天并不太热。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;写于  2010-7-14 05:14&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我一晚上没睡，并非来自突如其来的自省。&lt;/p&gt;
&lt;p&gt;突然感觉自己自制力很差，总是挥霍，然后弥补。欠你的人生，欠他的人生，欠我的人生，我眼睛已经开始花了。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>看着悲伤的故事 听着温暖的歌</title>
    <link href="http://bondaddy.github.io/2010/06/26/----65/"/>
    <id>http://bondaddy.github.io/2010/06/26/----65/</id>
    <published>2010-06-25T20:43:32.000Z</published>
    <updated>2019-12-19T01:41:19.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-6-26 04:43</p></blockquote><p>拼命的在抹去着白夜行里的苦涩.我讨厌悲伤,讨厌罪恶,讨厌离别.这样的时候我就反问这样的自己为什么会喜欢的推理小说呢.那里面充满了离别的苦涩和生死的悲伤.而我却拼命在里面寻求阅读的快感.这本该是件很悲伤的事情,是很悲伤的事情.我总是喃喃的说道.在这一刻,我明白了.我该很庆幸我看的那些书的作者手下留情.你们没有把生命的罪恶刻画的如此深刻.那些略带平凡的写作.却挽救了多年以来我看推理小说的兴趣.因为你们的肤浅,所以我对于死掉的人没有任何感触,因为你们的肤浅,我对活下来的人没有任何庆幸.谢谢,真的谢谢你们.</p><p>手纸～拝启 十五の君へ～,这首歌在涛发给我的时候我没有感触,虽然曲子很流畅让人很温暖.也许在公司那样的环境本就不适合品味任何东西.而回家后回味起这首歌的味道时,我一遍遍的反复的获取着里面的温暖.如果没有这首歌.我甚至会看不下去白夜行吧..或者我能够看的下去,只是到结尾的时候无法接受那样的一切.在我咀嚼里面冲突的滋味时,我在幻想自己是不是该写篇书评.可是我发现我的生活还是太阳光了.我不想和那些豆瓣的书友一般.把焦点针对在雪穗到底爱不爱亮这个没有意义的焦点上.我尝试着去接近那样的心理,却发现我的幻想都是越发幼稚.我甚至认为他们那时候能听到我现在的歌就会好起来吧..有着这样幼稚想法的我连自己都开始取笑自己了.你要如何告诉一个拥有阳光的人,其实你们的阳光是很宝贵的呢.坏人坏的那么情有可原,是因为我们连什么是真正的罪恶都已经分不清楚了.而之所以分不清楚,是因为我们离的太阳太近了.任何一点的瑕疵都觉得那么刺眼.</p><a id="more"></a><p>彻底的黑暗，恍如白昼。这样的字眼冲击着我的心里.不是对阳光没有渴望,不是对世界没有憧憬.而是被夺走了,被碾碎了.不会因为你是谁而妥协,不会因为你在哪而消失,不会因为你觉得够了而停止,我告诉很多人被动的委屈是无止境的.没有什么时候是够.说这话的时候我自己都觉得很阴暗.爱有时候是奢侈的.也许会连爱的能力都失去了.剩下的只有一份执念.拼了命也要达成的执念.在这中间发生的一切罪恶或者不罪恶的都已经无所谓了.只要两个人还在这份执念的轨道上就好了.也许只有这样才是活下去的动力.不知道为什么活着,只是知道那份轨道却一定要把他们走完.她不会回头看他的.最后一点光都已经暗了.也就没有回头的必要了.因为没有光,她也就不存在了.”我的天空里没有太阳,总是黑夜,但并不暗,因为有东西代替了太阳.虽然没有太阳那么明亮,但对我来说已经足够了,凭借着这份光,我便能把黑夜当成白天.我从来就没有太阳,所以不怕失去.”.雪穗不是不怕黑夜,而是因为有光.凭借着这份光.她还是可以走下去的.她还是可以在装作幸福的轨道给亮看着的.而这盏光已经灭了.她的幸福又要给谁看呢.</p><p>他们都已经累了.最后的亮已经无力再为雪穗发光了.雪穗在亮的身体面前发出冰冷的声音.背过扶梯,那也许是她为亮做的最后一次坚强.一切都结束了.他们的轨道终于还是到此为止.留下的只有男孩牵着女孩手的剪纸.还在寄托着他们卑微的梦想.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-6-26 04:43&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拼命的在抹去着白夜行里的苦涩.我讨厌悲伤,讨厌罪恶,讨厌离别.这样的时候我就反问这样的自己为什么会喜欢的推理小说呢.那里面充满了离别的苦涩和生死的悲伤.而我却拼命在里面寻求阅读的快感.这本该是件很悲伤的事情,是很悲伤的事情.我总是喃喃的说道.在这一刻,我明白了.我该很庆幸我看的那些书的作者手下留情.你们没有把生命的罪恶刻画的如此深刻.那些略带平凡的写作.却挽救了多年以来我看推理小说的兴趣.因为你们的肤浅,所以我对于死掉的人没有任何感触,因为你们的肤浅,我对活下来的人没有任何庆幸.谢谢,真的谢谢你们.&lt;/p&gt;
&lt;p&gt;手纸～拝启 十五の君へ～,这首歌在涛发给我的时候我没有感触,虽然曲子很流畅让人很温暖.也许在公司那样的环境本就不适合品味任何东西.而回家后回味起这首歌的味道时,我一遍遍的反复的获取着里面的温暖.如果没有这首歌.我甚至会看不下去白夜行吧..或者我能够看的下去,只是到结尾的时候无法接受那样的一切.在我咀嚼里面冲突的滋味时,我在幻想自己是不是该写篇书评.可是我发现我的生活还是太阳光了.我不想和那些豆瓣的书友一般.把焦点针对在雪穗到底爱不爱亮这个没有意义的焦点上.我尝试着去接近那样的心理,却发现我的幻想都是越发幼稚.我甚至认为他们那时候能听到我现在的歌就会好起来吧..有着这样幼稚想法的我连自己都开始取笑自己了.你要如何告诉一个拥有阳光的人,其实你们的阳光是很宝贵的呢.坏人坏的那么情有可原,是因为我们连什么是真正的罪恶都已经分不清楚了.而之所以分不清楚,是因为我们离的太阳太近了.任何一点的瑕疵都觉得那么刺眼.&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>一个侦探题 还有我的推理</title>
    <link href="http://bondaddy.github.io/2010/06/20/----64/"/>
    <id>http://bondaddy.github.io/2010/06/20/----64/</id>
    <published>2010-06-19T17:27:32.000Z</published>
    <updated>2019-12-19T01:41:19.647Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-6-20 01:27</p></blockquote><p>有一个男人是上班族      性格很孤僻     但是他有一个爱好就是加班      而且是加班到很晚      直到公司一个人没有的时候才回家      这一天他照旧在公司加班到很晚     两点的时候他从公司出来     往家走（他家里公司很近     步行20来分钟就到了）     走着走着他突然想上厕所     这时正好在路边上有一个公共厕所      他就走进去上厕所      他看见一个男的     那个男的跟他说了一句话      这个上班族当时就昂了一声      但是并没有感觉什么特别的或者异样      就进去上完厕所回家了      回家后     他洗了个澡     躺在床上想起那个男人和他说的那句话      突然从床上跳了起来     把家里的门窗都锁好关好      在沙发上一夜未睡     胆战心惊的过了一夜      第二天早上他给警察局打了个电话      说那个厕所可能发生了凶杀案      警察赶到那个厕所     在女厕所发现了一具长发女尸     问     那个杀人凶手对那个上班族说了什么<br>         提示一：是在半夜的公共厕所<br>         提示二：一具长发女尸<br>         提示三：这句话在白天说一点问题都没有     但是在晚上说就很奇怪   </p><p>大部分答案：那个人说 小心地滑，我在拖地。  </p><a id="more"></a><p>疑问：</p><ol><li><p>如果是这个答案，为什么这句话晚上说就很奇怪  </p></li><li><p>为什么他想到那句话突然跳起来把门窗关好  </p></li><li><p>为什么他当时不打电话，而是第二天早上才打  </p></li><li><p>如果是这个答案，为什么他说可能发生凶杀案而不是有一具女尸  </p></li><li><p>“性格很孤僻””但是他有一个爱好就是加班      而且是加班到很晚      直到公司 一个人没有的时候才回家””回家后，洗了个澡”感觉和答案有什么关系</p></li></ol><hr><p>以下是我的推理：</p><p>1.关于灯的问题，我想说应该是有灯的。如果没有灯，那么互相双方都看不清楚对方的长相，那么就更谈不上杀人灭口的必要。毕竟相互都看不清楚状况就算此人第二天不报案,在厕所里面有女尸在白天也一样会被发现的.所以报案不是关键,关键的是加班男应该看到了凶手的长相,而凶手也看到了加班男的长相.所以加班男才恐惧被杀人灭口.</p><p>2.同上所述,厕所里面有灯,那么都能看的清楚对方长相的情况下,不可能把尸体看作是拖把.还有一点可以证明这点就是,加班男打电话报警说的是凶杀案,而不提女尸,则女性长发这个特征并没有被加班男看到,也就表示加班男应该是没有看到尸体.只是从侧面了解到了一场凶杀的事实.</p><p>3.关于小心地滑,我在拖地这句话.我以为在晚上说并没有什么不妥,公共设施的清理工作总会避开人流要使用的期间,虽然可以说半夜两点有可能太晚,但这也不至于让人联想到谋杀,只会让人感觉意外.要往谋杀方面联想则要有更确切的表现.</p><p>4.同上,这里应该要有个更清楚的迹象表现和凶杀案有关系,所以我以为最直接的联系应该是血.所以说加班男看到这个人的时候,这个人身上一定有着血.而这个男人就是在解释身上血迹的缘由.我估计这话可能是:别害怕,我是杀猪的,来这里洗洗.而加班男此时则礼貌性的回了一句.也就是此时他没有反应过来对方言语的真实性.回家之后加班男对血的印象越来越深刻,而对半夜屠宰牲畜这个事情开始产生怀疑.</p><p>5.最后他就全副武装起来.至于为什么在沙发上,是由于床上容易睡着.而加班男希望自己不要入睡.为什么没有立刻打电话,是由于夜晚的恐怖压迫到了他自己没有立刻行动.当然这些并不是特别重要.主要的还是加班男在厕所里看到了什么.所以我的推论就是,加班男一定是看到了血迹.一个没有任何案件背景的人,只有看到最直观的东西才有可能联想到凶案.至于别的东西,则是不可以站在我们已经知道这是凶杀案的角度来展开的.</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-6-20 01:27&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有一个男人是上班族      性格很孤僻     但是他有一个爱好就是加班      而且是加班到很晚      直到公司一个人没有的时候才回家      这一天他照旧在公司加班到很晚     两点的时候他从公司出来     往家走（他家里公司很近     步行20来分钟就到了）     走着走着他突然想上厕所     这时正好在路边上有一个公共厕所      他就走进去上厕所      他看见一个男的     那个男的跟他说了一句话      这个上班族当时就昂了一声      但是并没有感觉什么特别的或者异样      就进去上完厕所回家了      回家后     他洗了个澡     躺在床上想起那个男人和他说的那句话      突然从床上跳了起来     把家里的门窗都锁好关好      在沙发上一夜未睡     胆战心惊的过了一夜      第二天早上他给警察局打了个电话      说那个厕所可能发生了凶杀案      警察赶到那个厕所     在女厕所发现了一具长发女尸     问     那个杀人凶手对那个上班族说了什么&lt;br&gt;         提示一：是在半夜的公共厕所&lt;br&gt;         提示二：一具长发女尸&lt;br&gt;         提示三：这句话在白天说一点问题都没有     但是在晚上说就很奇怪   &lt;/p&gt;
&lt;p&gt;大部分答案：那个人说 小心地滑，我在拖地。  &lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>合理中的不合理，或者不合理中的合理</title>
    <link href="http://bondaddy.github.io/2010/06/18/----63/"/>
    <id>http://bondaddy.github.io/2010/06/18/----63/</id>
    <published>2010-06-18T07:13:32.000Z</published>
    <updated>2019-12-19T01:41:19.638Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-6-18 15:13</p></blockquote><p>前文序：推理小说的书评难写，因为会剧透，不想被剧透的请别看此文</p><p>阿加莎·克里斯蒂作为推理女王的地位不容置疑，而他作为本格推理的创意也同样被赋予了很高的评价。作为其代表作之一，显然《东方快车谋杀案》不会失去应有的水准。 看完小说给我最深的感触就如我标题所说的，一切都在合理与不合理之间纠缠在一起了。这本小说在一般人看来最出人意料的就是我们面对一本推理作品，即便不会去做严谨的推理，也会在看书的过程中不断的猜测凶手是谁来增加推理小说阅读时候的乐趣。而这样的心理会使得推理迷们看多了同质性的解密后，难有其意外性可言。而此时推理的创作就要剑走偏锋，例如像《嫌疑犯X的献身》这样开始就告诉你凶手是谁，又或者像《无人永生》所有人都会被杀，都是创作时候增强这样意外性的一个创举。而《东方快车谋杀案》同样有了一个新颖的创举，所有的嫌疑人都是凶手。让读者在阅读之后惊叹作者的想象力和创造力。本格推理的生命就是谜题。而推理的过程往往是最精彩的，阿加莎的小说可以说是写的比较公平的小说。很多小说会由于作者水平的限制不敢将很多的线索公开与小说的进程之中，而往往解密的时候拿出了很多案件进展过程中根本没有出现的线索或者证据。这样不公平的小说往往让推理迷们很失望，但看阿加莎的小说就不会出现这样的问题。所以可以说解密的趣味是可以贯穿全书的。</p><a id="more"></a><p>《东方快车谋杀案》秉承阿加莎的特色，出场的人物较多，这样的写法增强了小说的复杂性。但这之间让我最困扰的反而不是众多的人物搞乱了其间的线索，而是难以逾越的不在场证明。所有人的不在场证明都过于完美，我一直有一个概念就是不在场证明是给傻子看的。因为在合理的时间内没有不在场证明远比在不合理的时间之中有很充足的不在场证明要高明的多。当然这要排除推理剧中总是扮演很2角色的警察同志们。而适时的作者抛出了全部人都是凶手这个答案。也许这个答案非常精妙。他非常符合推理界的那句名言：When you have eliminated the impossible, whatever remains,however improbable,must be the truth! 但在我看来却有很深的致命伤，其一就是大雪封山，致使火车无法开动，这是一个很大的前提，这个前提却是作者的矛盾和死结。本格推理有一个套路就是用某种手段让凶手无法逃脱，且没有嫌疑犯从外突然加入。那么不管什么时候读者都会默认凶手就在嫌疑人之中。而过于完美的不在场证明致使这些证词的可信度越来越低。而本书没有运用过多的谜题，只有一个谜题就是没有人有作案时间，让人认为这一定是外人所为，但即使不管大雪封山这个前提，本格推理迷们也不会对外人入侵这个结果满意，而这个矛盾点维系之间，这让人隐约感觉出了凶手的模样。简言之，阿加莎在创作的时候有个问题就是写死了可能性。12个人之中应当有嫌疑人和非嫌疑人的阵营组合才更容易让谜题精彩起来，也容易使读者误入歧途。而12个人都没有嫌疑则和12个人都有嫌疑形成了同样的局面。线索越多越好，但线索却不该是那种一查就明了的线索，那样和少数的线索就没有过多的差别。还好阿加莎对小说的节奏把握的很好，本书的简短反而没有时间让读者反应过来这种很简单的诡计，小说就直接进入精彩的推理。这点也不得不说是作者的写作功力的体现，使得小说收尾的时间恰到好处。其二则是参与杀人的参与性，这里面藏着一个很巧妙的心理我先按下不表。单谈杀人是件隐秘性的工作，参与杀人这个行为的人应当越少越好，因为人心的不可控不论有多么强的牵绊，在面对真实的死亡时，必然有很多的不确定性和各人心理承受能力的差异。越多的参与者虽然模糊了嫌疑犯的焦点，但却使得只要攻破其一点，则全盘皆破。故事的波洛就是这么做的，抓住其动机一点就如抓住了首尾相接的田鼠，一拉就拉出了一串的犯罪者。而各人身份的过于牵强以及最重要的纸片没有燃烧尽的关键程度，使我对这种偶然性大大的不满。因为没有燃尽的纸片署名让整个犯罪动机缺乏更多的可能性，而一切都围绕着阿姆斯特朗事件的身份安插不免的让人觉得有牵强附会之嫌。但这里却要谈到凶手们一个巧妙的心理，十二人陪审团以及十二刀这个暗示，使得行凶的手法上有了更合理的解释，所有人都亲手执行这个步骤，所有人都无法逃脱这个共同犯罪的事实，而在面对真实的死亡面前，所有人却又都可以逃脱自己是凶手的心理谴责。因为没有人明白死者到底是死于哪一刀，这点相当的高明，既然大家都无法逃脱了犯罪的事实，又使所有人都没有确切的感受到杀人的恐怖。再套以十二陪审团这个光明的影子。一切的一切都安排的恰到好处，可以说阿加莎在写这本书最最精彩的部分凶手是所有人的意外性，也不是不在证词线索的复杂性。而是这种犯罪心理上的双重暗示让我惊叹不已，在有人性的影子下，本格推理才有了新的高度，而不是单纯必须存在手法而创造出一个手法来挑战趣味。但凡在出现人的小说里，脱离了人性的范畴，一切都变得空洞起来，而在这份空洞之下，是无法让人回味小说的美好的，而这点上在我看来就是大师和普通写手最大的区别。</p><p> 结尾很符合国人的心理，国人并没有认为法制是个好东西，而国情一直是人治高于法制的。当然从情感上讲不管是哪个国家都同样的受用，对于我也很受用，罪犯受到了正义的制裁，比他受到法律的制裁更让我们大快人心。这不得不说侧面体现了我们从心底就没有认为法律代表了正义。在这个法律不能代表正义的时代，我们就需要福尔摩斯，波洛等这样的名侦探为我们主持正义，而向往正义的美好愿望，也会随时随地的流淌在人们心底最干净的地方，我们都在等待，等待着由自己来主持正义的一天。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-6-18 15:13&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前文序：推理小说的书评难写，因为会剧透，不想被剧透的请别看此文&lt;/p&gt;
&lt;p&gt;阿加莎·克里斯蒂作为推理女王的地位不容置疑，而他作为本格推理的创意也同样被赋予了很高的评价。作为其代表作之一，显然《东方快车谋杀案》不会失去应有的水准。 看完小说给我最深的感触就如我标题所说的，一切都在合理与不合理之间纠缠在一起了。这本小说在一般人看来最出人意料的就是我们面对一本推理作品，即便不会去做严谨的推理，也会在看书的过程中不断的猜测凶手是谁来增加推理小说阅读时候的乐趣。而这样的心理会使得推理迷们看多了同质性的解密后，难有其意外性可言。而此时推理的创作就要剑走偏锋，例如像《嫌疑犯X的献身》这样开始就告诉你凶手是谁，又或者像《无人永生》所有人都会被杀，都是创作时候增强这样意外性的一个创举。而《东方快车谋杀案》同样有了一个新颖的创举，所有的嫌疑人都是凶手。让读者在阅读之后惊叹作者的想象力和创造力。本格推理的生命就是谜题。而推理的过程往往是最精彩的，阿加莎的小说可以说是写的比较公平的小说。很多小说会由于作者水平的限制不敢将很多的线索公开与小说的进程之中，而往往解密的时候拿出了很多案件进展过程中根本没有出现的线索或者证据。这样不公平的小说往往让推理迷们很失望，但看阿加莎的小说就不会出现这样的问题。所以可以说解密的趣味是可以贯穿全书的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
  <entry>
    <title>两天的特权</title>
    <link href="http://bondaddy.github.io/2010/06/08/----62/"/>
    <id>http://bondaddy.github.io/2010/06/08/----62/</id>
    <published>2010-06-07T17:07:32.000Z</published>
    <updated>2019-12-19T01:41:19.627Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>写于  2010-6-8 01:07 </p></blockquote><p>又是一年春来到，好吧。是夏来到。</p><p>高考应该是生命中很美好的两天不是吗？这一天警车开道，花车净街，仿佛一切都是为你们准备的，而父母也会为了这两天的日子极尽“谄媚”之能事。吃好睡好就为了一个好成绩，一个好分数，一个好出路。这两天的日子仿佛一切都让那些和高考有关的人变得愚蠢。警察忘记了自己的职责不是为了给某些人开特权，学生忘记了应试教育的悲哀和可恶，父母忘记了人生的路很长其实很多时候和高考无关。高考的两天，和愚蠢相关的两天，在这两天中，一批人找到了生活的指标。一切都美的不像话，那么的有目标，那么的万众一心。</p><p>其实我都不是很理解为什么我会在这里说风凉话。只是一边看着这些孩子为了高考前仆后继，而手头上的新闻写着新增考生多少人，新增学位多少人。不免的有些悲凉。已经再也没有人会谈论大学生是天之骄子。而硕士多如狗，博士满街走之类的笑语早就不是现在这个时代的标语了。而是我上大学时代的标语了。就这么不值钱的东西，还是有那种盲目的追从。人应该是很难从习惯中走出来。而我们报考的专业还是那么的可笑。不管过了多少年，哲学系，考古系依旧那么冷门。种田种菜的能换钱的行当还比较吃香。大学不是精神升华的场所，而是可以换钱的交易。陈先生说的独立之精神 自由之思想不要说学生早就不知为何物，就算是那些专家和教授应该也不知道为何物了。前段时间听说高考在某些地方的报名率下降了，很多农民的孩子不再高考。因为高考的投资和回报不成正比。我心中嗤笑，谁告诉你们高考是投资的，就算是一种投资，它也不是能马上换成钱的东西。大学也许是一种观念，一种思想，一种理念的投资。但这些和你们说有用吗？换钱吧，孩子们，你们到大学的第一课还是学不会做人的，因为你们要开始职场规划了。其实聪明如你们的还发现不了这是个局吗？人生就是关关难过关关过。欢呼的时间是有的，不过留不给你们什么。</p><a id="more"></a><p>我朝从来不是考知识的，永远都在考技巧，这些点你答到了没，这些方法你用上没。这不怪你们，要怪就要怪教你们的老师本身就那点水平，你们答出点花火来他们就不知道怎么改卷了。他们只知道对着答案勾勾叉叉就是本事了。然后发给你们订正出他们从教学参考书读出来的正确答案。风言福州这次作文题目很范，很多孩子暗自叫苦。这种猜心的游戏当然叫苦，因为你不知道改卷的老师是什么喜好，你就拿不准自己写的东西符合不符合阅卷老师high点。满足她的high点，你的作文成绩自然就高了。多听话的孩子，大笔挥一挥，一切好商量。天才的学生就别祈祷遇到天才的老师了。你能遇到知道自己是庸才的老师就已经是万幸了。因为那个庸才的老师是没那个自信抹灭超出他理解范围的文章的。</p><p>还有一天，好好享受人生少有的特权日吧。过了这一天，一切又平等了，当你们失去准考证的那一刻，这个世界对你们而言又是平的了。因为社会的机器又开始照着往常的样子运转起来了，齿轮的咔咔声碾碎了一切的无谓，往后的日子，该亮爪子的亮爪子，该呲牙的呲牙，从你们的卷子开始。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;写于  2010-6-8 01:07 &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;又是一年春来到，好吧。是夏来到。&lt;/p&gt;
&lt;p&gt;高考应该是生命中很美好的两天不是吗？这一天警车开道，花车净街，仿佛一切都是为你们准备的，而父母也会为了这两天的日子极尽“谄媚”之能事。吃好睡好就为了一个好成绩，一个好分数，一个好出路。这两天的日子仿佛一切都让那些和高考有关的人变得愚蠢。警察忘记了自己的职责不是为了给某些人开特权，学生忘记了应试教育的悲哀和可恶，父母忘记了人生的路很长其实很多时候和高考无关。高考的两天，和愚蠢相关的两天，在这两天中，一批人找到了生活的指标。一切都美的不像话，那么的有目标，那么的万众一心。&lt;/p&gt;
&lt;p&gt;其实我都不是很理解为什么我会在这里说风凉话。只是一边看着这些孩子为了高考前仆后继，而手头上的新闻写着新增考生多少人，新增学位多少人。不免的有些悲凉。已经再也没有人会谈论大学生是天之骄子。而硕士多如狗，博士满街走之类的笑语早就不是现在这个时代的标语了。而是我上大学时代的标语了。就这么不值钱的东西，还是有那种盲目的追从。人应该是很难从习惯中走出来。而我们报考的专业还是那么的可笑。不管过了多少年，哲学系，考古系依旧那么冷门。种田种菜的能换钱的行当还比较吃香。大学不是精神升华的场所，而是可以换钱的交易。陈先生说的独立之精神 自由之思想不要说学生早就不知为何物，就算是那些专家和教授应该也不知道为何物了。前段时间听说高考在某些地方的报名率下降了，很多农民的孩子不再高考。因为高考的投资和回报不成正比。我心中嗤笑，谁告诉你们高考是投资的，就算是一种投资，它也不是能马上换成钱的东西。大学也许是一种观念，一种思想，一种理念的投资。但这些和你们说有用吗？换钱吧，孩子们，你们到大学的第一课还是学不会做人的，因为你们要开始职场规划了。其实聪明如你们的还发现不了这是个局吗？人生就是关关难过关关过。欢呼的时间是有的，不过留不给你们什么。&lt;/p&gt;
    
    </summary>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/categories/qzone/"/>
    
    
      <category term="qzone" scheme="http://bondaddy.github.io/tags/qzone/"/>
    
  </entry>
  
</feed>
