<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Scala实用指南读书笔记（一） | heros come back</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="heros come back">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Scala实用指南第一部分 小试牛刀Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。 1. 探索scala1.1. scala的特殊性scala的关键特性信息：  同时支持命令式风格和函数式风格 纯面向对象 强制合理的静态类型和类型推断 简洁而富有表现力 能和 Java 无缝地互操作 基于精小的内核构建 高度的伸缩性，仅用少量代码就可以创建">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala实用指南读书笔记（一）">
<meta property="og:url" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;02&#x2F;----81&#x2F;index.html">
<meta property="og:site_name" content="heros come back">
<meta property="og:description" content="Scala实用指南第一部分 小试牛刀Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。 1. 探索scala1.1. scala的特殊性scala的关键特性信息：  同时支持命令式风格和函数式风格 纯面向对象 强制合理的静态类型和类型推断 简洁而富有表现力 能和 Java 无缝地互操作 基于精小的内核构建 高度的伸缩性，仅用少量代码就可以创建">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;02&#x2F;----81&#x2F;media&#x2F;15773763608881&#x2F;15773793874093.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;02&#x2F;----81&#x2F;media&#x2F;15773763608881&#x2F;15774317263759.jpg">
<meta property="og:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;02&#x2F;----81&#x2F;media&#x2F;15773763608881&#x2F;15777817957416.jpg">
<meta property="article:published_time" content="2020-01-01T18:08:48.000Z">
<meta property="article:modified_time" content="2020-01-02T03:47:08.080Z">
<meta property="article:author" content="bon爸">
<meta property="article:tag" content="software programming">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;02&#x2F;----81&#x2F;media&#x2F;15773763608881&#x2F;15773793874093.jpg">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
<meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="heros come back" type="application/atom+xml">
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				heros come back
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-----81"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/2020/01/02/----81/">
    	Scala实用指南读书笔记（一）
    </a>
  </h2>
	<time>
	  1月 2, 2020
	</time>
	
    
    <div class='cats'>
        <a href="/categories/professional-skill/">professional skill</a>
    </div>

	</section>
	
		<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Scala实用指南"><span class="toc-number">1.</span> <span class="toc-text">Scala实用指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一部分-小试牛刀"><span class="toc-number">1.1.</span> <span class="toc-text">第一部分 小试牛刀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-探索scala"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. 探索scala</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-scala的特殊性"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">1.1. scala的特殊性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-以少胜多"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">1.2. 以少胜多</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-函数式编程"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">1.3 函数式编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-体验-Scala"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. 体验 Scala</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-使用-REPL"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">2.1 使用 REPL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-命令行上的-Scala"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">2.2 命令行上的 Scala</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-以独立脚本方式运行-Scala-代码"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">2.3 以独立脚本方式运行 Scala 代码</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-1-在类-Unix-系统上以独立脚本方式运行"><span class="toc-number">1.1.2.3.1.</span> <span class="toc-text">2.3.1. 在类 Unix 系统上以独立脚本方式运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-2-在-Windows-上以独立脚本方式运行"><span class="toc-number">1.1.2.3.2.</span> <span class="toc-text">2.3.2. 在 Windows 上以独立脚本方式运行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-3-3-Scala-的-IDE-支持"><span class="toc-number">1.1.2.3.3.</span> <span class="toc-text">2.3.3 Scala 的 IDE 支持</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-3-1-Maven依赖配置"><span class="toc-number">1.1.2.3.3.1.</span> <span class="toc-text">2.3.3.1. Maven依赖配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-3-2-Maven打包插件配置"><span class="toc-number">1.1.2.3.3.2.</span> <span class="toc-text">2.3.3.2. Maven打包插件配置</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-3-3-编译sdk配置"><span class="toc-number">1.1.2.3.3.3.</span> <span class="toc-text">2.3.3.3. 编译sdk配置</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-从-Java-到-Scala"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. 从 Java 到 Scala</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-Scala-简洁的-Java"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">3.1. Scala:简洁的 Java</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-1-减少样板代码"><span class="toc-number">1.1.3.1.1.</span> <span class="toc-text">3.1.1. 减少样板代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-2-更多便利特性"><span class="toc-number">1.1.3.1.2.</span> <span class="toc-text">3.1.2. 更多便利特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-1-3-转向函数式风格"><span class="toc-number">1.1.3.1.3.</span> <span class="toc-text">3.1.3. 转向函数式风格</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-Java-原始类型对应的-Scala-类"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">3.2. Java 原始类型对应的 Scala 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-元组和多重赋值"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">3.3. 元组和多重赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-灵活的参数和参数值"><span class="toc-number">1.1.3.4.</span> <span class="toc-text">3.4. 灵活的参数和参数值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-1-传递变长参数值"><span class="toc-number">1.1.3.4.1.</span> <span class="toc-text">3.4.1 传递变长参数值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-2-为参数提供默认值"><span class="toc-number">1.1.3.4.2.</span> <span class="toc-text">3.4.2. 为参数提供默认值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-4-3-使用命名参数"><span class="toc-number">1.1.3.4.3.</span> <span class="toc-text">3.4.3. 使用命名参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-隐式参数"><span class="toc-number">1.1.3.5.</span> <span class="toc-text">3.5. 隐式参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-6-字符串和多行原始字符串"><span class="toc-number">1.1.3.6.</span> <span class="toc-text">3.6. 字符串和多行原始字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-7-字符串插值"><span class="toc-number">1.1.3.7.</span> <span class="toc-text">3.7 字符串插值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-8-合理的约定"><span class="toc-number">1.1.3.8.</span> <span class="toc-text">3.8 合理的约定</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-9-操作符重载"><span class="toc-number">1.1.3.9.</span> <span class="toc-text">3.9. 操作符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-10-Scala-与-Java-的差异"><span class="toc-number">1.1.3.10.</span> <span class="toc-text">3.10. Scala 与 Java 的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-1-赋值的结果"><span class="toc-number">1.1.3.10.1.</span> <span class="toc-text">3.10.1. 赋值的结果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-2-Scala-的"><span class="toc-number">1.1.3.10.2.</span> <span class="toc-text">3.10.2. Scala 的&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-3-可有可无的分号"><span class="toc-number">1.1.3.10.3.</span> <span class="toc-text">3.10.3. 可有可无的分号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-10-4-避免显式-return"><span class="toc-number">1.1.3.10.4.</span> <span class="toc-text">3.10.4. 避免显式 return</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-11-默认访问修饰符"><span class="toc-number">1.1.3.11.</span> <span class="toc-text">3.11. 默认访问修饰符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-11-1-定制访问修饰"><span class="toc-number">1.1.3.11.1.</span> <span class="toc-text">3.11.1. 定制访问修饰</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-11-2-Scala-的-protected"><span class="toc-number">1.1.3.11.2.</span> <span class="toc-text">3.11.2. Scala 的 protected</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-11-3-细粒度的访问控制"><span class="toc-number">1.1.3.11.3.</span> <span class="toc-text">3.11.3. 细粒度的访问控制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-处理对象"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. 处理对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-创建并使用类"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">4.1 创建并使用类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-1-创建实例"><span class="toc-number">1.1.4.1.1.</span> <span class="toc-text">4.1.1. 创建实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-2-创建类"><span class="toc-number">1.1.4.1.2.</span> <span class="toc-text">4.1.2. 创建类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-1-3-定义字段、方法和构造器"><span class="toc-number">1.1.4.1.3.</span> <span class="toc-text">4.1.3. 定义字段、方法和构造器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-遵循-JavaBean-惯例"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">4.2. 遵循 JavaBean 惯例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-类型别名"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">4.3. 类型别名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-扩展一个类"><span class="toc-number">1.1.4.4.</span> <span class="toc-text">4.4. 扩展一个类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-参数化类型"><span class="toc-number">1.1.4.5.</span> <span class="toc-text">4.5. 参数化类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-单例对象和伴生对象"><span class="toc-number">1.1.4.6.</span> <span class="toc-text">4.6 单例对象和伴生对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-1-单例对象"><span class="toc-number">1.1.4.6.1.</span> <span class="toc-text">4.6.1. 单例对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-2-独立对象和伴生对象"><span class="toc-number">1.1.4.6.2.</span> <span class="toc-text">4.6.2. 独立对象和伴生对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-6-3-Scala-中的-static"><span class="toc-number">1.1.4.6.3.</span> <span class="toc-text">4.6.3. Scala 中的 static</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-7-创建枚举类"><span class="toc-number">1.1.4.7.</span> <span class="toc-text">4.7. 创建枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-8-包对象"><span class="toc-number">1.1.4.8.</span> <span class="toc-text">4.8. 包对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-善用类型"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. 善用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-类型推断"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">5.1. 类型推断</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-简单类型的类型推断"><span class="toc-number">1.1.5.1.1.</span> <span class="toc-text">5.1.1. 简单类型的类型推断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-针对泛型和集合的类型推断"><span class="toc-number">1.1.5.1.2.</span> <span class="toc-text">5.1.2. 针对泛型和集合的类型推断</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-基础类型"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">5.2 基础类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-1-Any-类型"><span class="toc-number">1.1.5.2.1.</span> <span class="toc-text">5.2.1. Any 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-2-关于-Nothing"><span class="toc-number">1.1.5.2.2.</span> <span class="toc-text">5.2.2. 关于 Nothing</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-3-Option-类型"><span class="toc-number">1.1.5.2.3.</span> <span class="toc-text">5.2.3. Option 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-2-4-Either-类型"><span class="toc-number">1.1.5.2.4.</span> <span class="toc-text">5.2.4 Either 类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-返回值类型推断"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">5.3 返回值类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-参数化类型的型变"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">5.4 参数化类型的型变</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-协变和逆变"><span class="toc-number">1.1.5.4.1.</span> <span class="toc-text">5.4.1 协变和逆变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-支持协变"><span class="toc-number">1.1.5.4.2.</span> <span class="toc-text">5.4.2 支持协变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-支持逆变"><span class="toc-number">1.1.5.4.3.</span> <span class="toc-text">5.4.3. 支持逆变</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-定制集合的型变"><span class="toc-number">1.1.5.4.4.</span> <span class="toc-text">5.4.4 定制集合的型变</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-隐式类型转换"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">5.5 隐式类型转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-1-隐式函数"><span class="toc-number">1.1.5.5.1.</span> <span class="toc-text">5.5.1 隐式函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-5-2-隐式类"><span class="toc-number">1.1.5.5.2.</span> <span class="toc-text">5.5.2 隐式类</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<h1 id="Scala实用指南"><a href="#Scala实用指南" class="headerlink" title="Scala实用指南"></a>Scala实用指南</h1><h2 id="第一部分-小试牛刀"><a href="#第一部分-小试牛刀" class="headerlink" title="第一部分 小试牛刀"></a>第一部分 小试牛刀</h2><p>Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。</p>
<h3 id="1-探索scala"><a href="#1-探索scala" class="headerlink" title="1. 探索scala"></a>1. 探索scala</h3><h4 id="1-1-scala的特殊性"><a href="#1-1-scala的特殊性" class="headerlink" title="1.1. scala的特殊性"></a>1.1. scala的特殊性</h4><p>scala的关键特性信息：</p>
<ul>
<li>同时支持命令式风格和函数式风格</li>
<li>纯面向对象</li>
<li>强制合理的静态类型和类型推断</li>
<li>简洁而富有表现力</li>
<li>能和 Java 无缝地互操作</li>
<li>基于精小的内核构建</li>
<li>高度的伸缩性，仅用少量代码就可以创建高性能的应用程序</li>
<li>具有强大、易用的并发模型</li>
</ul>
<h4 id="1-2-以少胜多"><a href="#1-2-以少胜多" class="headerlink" title="1.2. 以少胜多"></a>1.2. 以少胜多</h4><p>用更少的代码解决更多的问题 — 简化日常编程<br>筛选出内部最高价格的股票</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span>(<span class="params">year: <span class="type">Int</span>, month: <span class="type">Int</span>, date: <span class="type">Int</span>, closePrice: <span class="type">BigDecimal</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">PrintMax</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getYearEndClosingPrice</span></span>(symbol: <span class="type">String</span>, year: <span class="type">Int</span>): <span class="type">BigDecimal</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">s"https://raw.githubusercontent.com/ReactivePlatform/"</span> +</span><br><span class="line">      <span class="string">s"Pragmatic-Scala-StaticResources/master/src/main/resources/"</span> + <span class="string">s"stocks/daily/daily_<span class="subst">$symbol</span>.csv"</span></span><br><span class="line">    <span class="keyword">val</span> data = io.<span class="type">Source</span>.fromURL(url).mkString</span><br><span class="line">    <span class="keyword">val</span> maxClosePrize = data.split(<span class="string">"\n"</span>)</span><br><span class="line">      .filter(record =&gt; record.startsWith(<span class="string">s"<span class="subst">$year</span>-12"</span>)).map(record =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(timestamp, open, high, low, close, volume) = record.split(<span class="string">","</span>)</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(year, month, date) = timestamp.split(<span class="string">"-"</span>)</span><br><span class="line">      <span class="type">Record</span>(year.toInt, month.toInt, date.toInt, <span class="type">BigDecimal</span>(close.trim))</span><br><span class="line">    &#125;).sortBy(_.date)(<span class="type">Ordering</span>[<span class="type">Int</span>].reverse).take(<span class="number">1</span>)</span><br><span class="line">      .map(_.closePrice)</span><br><span class="line">      .head</span><br><span class="line">    maxClosePrize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> symbols = <span class="type">List</span>(<span class="string">"AMD"</span>, <span class="string">"AAPL"</span>)</span><br><span class="line">    <span class="keyword">val</span> year = <span class="number">2017</span></span><br><span class="line">    <span class="keyword">val</span> (topStock, topPrice) = symbols.par.map &#123; ticker =&gt; (ticker, getYearEndClosingPrice(ticker, year)) &#125;</span><br><span class="line">      .maxBy &#123; stockPrice =&gt; stockPrice._2 &#125;</span><br><span class="line">    printf(<span class="string">s"Top stock of <span class="subst">$year</span> is <span class="subst">$topStock</span> closing at price $$<span class="subst">$topPrice</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个功能强大的专用迭代器— map() 函数和 maxBy()函数。在 Java 中，我们习惯用“方法”这个术语来指代类的成员，而“函 数”这个术语通常用于指代不属于类的过程(procedure)。然而，在 Scala 中这两个术语可交 换使用。</p>
<p>这两个迭代器分别行使了两种独立的职责。首先，我们使用 map()函数遍历股票代码， 以创建一个由股票代码及其 2017 年收盘价格组成的“对”或“元组”为元素的列表。最终结 果的元组列表形式为 List((股票代码 1，价格 1)，(股票代码 2，价格 2)，…)。</p>
<a id="more"></a>
<p>第二个迭代器处理第一个迭代器的结果。maxBy()函数是一个从列表中取出最大值的专 用迭代器。因为该列表中的值是元组(对)，所以我们需要告诉 maxBy()函数如何比较两个 值。在 maxBy()函数附带的代码块中，我们指定了一个包含两个元素的元组，我们感兴趣的 是第二个属性(代码块中的_2)— 价格。</p>
<p>可视化动作：<br><img src="media/15773763608881/15773793874093.jpg" alt="-w514"></p>
<p>在这个例子中，我们从 Web 获取每个股票代码的数据，这涉及多次访问网络的调用。假 设网络延迟是d秒，而我们要分析n支股票，那么顺序代码大概需要n × d秒。因为代码中 最大的延迟在于访问网络来获取数据，所以如果我们并行地执行代码以获取不同股票代码的 数据，那么我们可以将时间缩短到大约 d 秒。Scala 使得将顺序代码改成并行模式变得很简单， 只需一个很小的改动:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbols.par.map &#123; ticker =&gt; (ticker, getYearEndClosingPrice(ticker, year)) &#125; .maxBy &#123; stockPrice =&gt; stockPrice._2 &#125;</span><br></pre></td></tr></table></figure>

<p>插入了对 par 的调用，就是这么简单。这段代码现在已经是在并行地处理每一个股 票代码，而不是顺序迭代。</p>
<p><strong>强调一下这个例子的一些优点</strong>：</p>
<ul>
<li>代码很简洁。我们利用了Scala的许多强大特性，如函数值、(并行)集 合、专用迭代器、不可变值、不可变性和元组等</li>
<li>函数式风格，具体说来就是函数组合。我们使用 map()方法将股票代码 的列表转换为股票代码及其价格组成的元组的列表。然后我们使用 maxBy()方法将 其转换成所需的值。和使用命令式风格不同，我们将控制逻辑让渡给函数所在的标准 库以完成任务，而不是耗费精力在迭代的控制上。</li>
<li>无痛地使用并发。没有必要再使用 wait()和 notify()方法或者 synchronized 关键字了。</li>
</ul>
<p>更多的优点：</p>
<ul>
<li>Java 中的原始类型在 Scala 中被看作对象。例如，2.toString()在 Java 中将产生编译 错误，但在 Scala 中是有效</li>
<li>Scala 编译成了字节码，这样我们就可以使用运行 Java 程序的方式来运行 Scala 程序，也 可以用脚本的方式运行它。Scala 也可以很好地与 Java 互操作。</li>
<li>Scala是一门静态类型的编程语言，但与Java不同，它的静态类型更加合理— Scala会 尽可能地使用类型推断。我们可以依靠 Scala 本身来推断出类型，并将结果类型应用到其余 代码中，而不是重复又冗余地指定类型。我们不应该为编译器工作，而应该让编译器为我们 工作。例如，当我们定义var i = 1时，Scala将立即推断出变量i的类型为Int。</li>
</ul>
<h4 id="1-3-函数式编程"><a href="#1-3-函数式编程" class="headerlink" title="1.3 函数式编程"></a>1.3 函数式编程</h4><p>Scala 本质上是一门混合型编程语言，我们既可以使用命令式风格也可以使用函数式风 格，这是把双刃剑。其优点在于，当使用 Scala 编写代码时，我们可以先使其工作，然后再 做优化。对于刚刚接触函数式编程的程序员，他们可以先用命令式风格写好代码，然后再将 代码重构成函数式风格。</p>
<p>函数式编程提倡<strong>不可变性</strong>、<strong>高阶函数</strong>和<strong>函数组合</strong>。这些特性合在一起就能使代码简洁、 富有表现力、易于理解和修改。不可变性还有助于减少那些由于状态改变而悄然滋生的错误。</p>
<p><strong>Java和Scala代码风格对比</strong></p>
<p>命令式风格的 Java 代码1，用于从给定日期开始的一系列温度中计算出最大值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findMax</span><span class="params">(List&lt;Integer&gt; temperatures)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> highTemperature = Integer.MIN_VALUE; </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> temperature : temperatures) &#123;</span><br><span class="line">        highTemperature = Math.max(highTemperature, temperature);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> highTemperature; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Scala 也支持命令式风格，下面是 Scala 版本的代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMax</span></span>(temperatures: <span class="type">List</span>[<span class="type">Int</span>]) = &#123; </span><br><span class="line">    <span class="keyword">var</span> highTemperature = <span class="type">Integer</span>.<span class="type">MIN_VALUE</span> </span><br><span class="line">    <span class="keyword">for</span> (temperature &lt;- temperatures) &#123;</span><br><span class="line">        highTemperature = <span class="type">Math</span>.max(highTemperature, temperature) </span><br><span class="line">    &#125;</span><br><span class="line">    highTemperature </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了可变变量 highTemperature，并在循环中持续修改它。我们必须确保正确 地初始化可变变量，并在正确的地方把它们修改为正确的值。</p>
<p>函数式编程是一种声明式风格，我们只要指定做什么而不用指定如何去做。XSLT、规则 引擎和 ANTLR 这些工具都普遍使用声明式风格。让我们把前面的代码用不带可变参数的函 数式风格重写一下。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMax</span></span>(temperatures: <span class="type">List</span>[<span class="type">Int</span>]) = &#123; </span><br><span class="line">    temperatures.foldLeft(<span class="type">Integer</span>.<span class="type">MIN_VALUE</span>) &#123; <span class="type">Math</span>.max &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-体验-Scala"><a href="#2-体验-Scala" class="headerlink" title="2. 体验 Scala"></a>2. 体验 Scala</h3><h4 id="2-1-使用-REPL"><a href="#2-1-使用-REPL" class="headerlink" title="2.1 使用 REPL"></a>2.1 使用 REPL</h4><p>相当多的编程语言都提供了REPL(read-eval-print loop)工具，使用REPL可以便捷地 键入代码片段，并以交互方式立即看到代码运行结果。除了执行代码片段外，REPL 往往还 提供一些在运行时不方便获取的细节。这使得 REPL 成为一个特殊工具，可以用来做试验， 也可以用来学习 Scala 推断变量或函数类型的方法。</p>
<p>要启动 REPL，应在命令行(在终端窗口或命令提示符下)键入 scala。启动后会打印 出一些介绍信息，紧跟着一个提示符:</p>
<h4 id="2-2-命令行上的-Scala"><a href="#2-2-命令行上的-Scala" class="headerlink" title="2.2 命令行上的 Scala"></a>2.2 命令行上的 Scala</h4><p>和Java最大的差异，直接写代码就可以得到最终的反馈结果，而不需要像java一样必须使用 main()方法的 Main 类</p>
<h4 id="2-3-以独立脚本方式运行-Scala-代码"><a href="#2-3-以独立脚本方式运行-Scala-代码" class="headerlink" title="2.3 以独立脚本方式运行 Scala 代码"></a>2.3 以独立脚本方式运行 Scala 代码</h4><h5 id="2-3-1-在类-Unix-系统上以独立脚本方式运行"><a href="#2-3-1-在类-Unix-系统上以独立脚本方式运行" class="headerlink" title="2.3.1. 在类 Unix 系统上以独立脚本方式运行"></a>2.3.1. 在类 Unix 系统上以独立脚本方式运行</h5><p>在类 Unix 系统上，在脚本中设置 shebang 前缀如下。键入并运行chmod + x hello.sh以确保文件hello.sh具有可执行权限，然后在 命令行上键入如下命令以运行:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env </span></span><br><span class="line">scala println(<span class="string">"Hello "</span> + args(0))</span><br></pre></td></tr></table></figure>
<p>./hello.sh Buddy<br>Buddy 是传递给脚本的参数。下面是运行结果: Hello Buddy</p>
<h5 id="2-3-2-在-Windows-上以独立脚本方式运行"><a href="#2-3-2-在-Windows-上以独立脚本方式运行" class="headerlink" title="2.3.2. 在 Windows 上以独立脚本方式运行"></a>2.3.2. 在 Windows 上以独立脚本方式运行</h5><p>忽略不计，不在windows上进行代码操作</p>
<h5 id="2-3-3-Scala-的-IDE-支持"><a href="#2-3-3-Scala-的-IDE-支持" class="headerlink" title="2.3.3 Scala 的 IDE 支持"></a>2.3.3 Scala 的 IDE 支持</h5><p>根据Intellij Idea 配置</p>
<h6 id="2-3-3-1-Maven依赖配置"><a href="#2-3-3-1-Maven依赖配置" class="headerlink" title="2.3.3.1. Maven依赖配置"></a>2.3.3.1. Maven依赖配置</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-compiler<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-reflect<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-actors<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.11.8<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-tools<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-scala-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="2-3-3-2-Maven打包插件配置"><a href="#2-3-3-2-Maven打包插件配置" class="headerlink" title="2.3.3.2. Maven打包插件配置"></a>2.3.3.2. Maven打包插件配置</h6><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;!-- 这是个编译java代码的 --&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span>&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;source&gt;<span class="number">1.8</span>&lt;/source&gt;</span><br><span class="line">        &lt;target&gt;<span class="number">1.8</span>&lt;/target&gt;</span><br><span class="line">        &lt;encoding&gt;<span class="type">UTF</span><span class="number">-8</span>&lt;/encoding&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;phase&gt;compile&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;!-- 这是个编译scala代码的 --&gt;</span><br><span class="line">    &lt;groupId&gt;net.alchim31.maven&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;scala-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">3.2</span><span class="number">.1</span>&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;scala-compile-first&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;process-resources&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;add-source&lt;/goal&gt;</span><br><span class="line">                &lt;goal&gt;compile&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-assembly-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">2.5</span><span class="number">.5</span>&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;archive&gt;</span><br><span class="line">            &lt;manifest&gt;</span><br><span class="line">                &lt;mainClass&gt;pro.simba.<span class="type">Main</span>&lt;/mainClass&gt;</span><br><span class="line">            &lt;/manifest&gt;</span><br><span class="line">        &lt;/archive&gt;</span><br><span class="line">        &lt;descriptorRefs&gt;</span><br><span class="line">            &lt;descriptorRef&gt;jar-<span class="keyword">with</span>-dependencies&lt;/descriptorRef&gt;</span><br><span class="line">        &lt;/descriptorRefs&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;make-assembly&lt;/id&gt;</span><br><span class="line">            &lt;phase&gt;<span class="keyword">package</span>&lt;/phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;single&lt;/goal&gt;</span><br><span class="line">            &lt;/goals&gt;</span><br><span class="line">        &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>

<h6 id="2-3-3-3-编译sdk配置"><a href="#2-3-3-3-编译sdk配置" class="headerlink" title="2.3.3.3. 编译sdk配置"></a>2.3.3.3. 编译sdk配置</h6><p><img src="media/15773763608881/15774317263759.jpg" alt=""></p>
<h3 id="3-从-Java-到-Scala"><a href="#3-从-Java-到-Scala" class="headerlink" title="3. 从 Java 到 Scala"></a>3. 从 Java 到 Scala</h3><p>你可以在使用 Scala 的同时运用自己的 Java 技能。在某些方面 Scala 与 Java 类似，但在 许多其他方面又彼此不同。Scala 青睐纯面向对象，但它又尽可能将类型和 Java 的类型对应 起来。Scala 在支持熟悉的命令式编程风格的同时，也支持函数式编程风格。因此，你可以使 用最熟悉的风格立即开始编程，而不用承受陡峭的学习曲线。</p>
<h4 id="3-1-Scala-简洁的-Java"><a href="#3-1-Scala-简洁的-Java" class="headerlink" title="3.1. Scala:简洁的 Java"></a>3.1. Scala:简洁的 Java</h4><p>Java代码中通常充斥着很多样板代码— getter、setter、访问修饰符、处理受检异常的代 码等。这些样板还在不断增多，使代码不断膨胀。在后面我们会了解到，Scala 编译器做了一 些额外的工作，这样就不用耗费精力编写并维护那些本可以生成的代码上了。</p>
<h5 id="3-1-1-减少样板代码"><a href="#3-1-1-减少样板代码" class="headerlink" title="3.1.1. 减少样板代码"></a>3.1.1. 减少样板代码</h5><p>Scala 具有非常高的代码密度— 输入少量代码就可以完成许多功能。作为对比，我们来 看一个 Java 代码的例子。例如：字符串插值(语法形如 s”…${expression}…”)，避免了Java的拼凑字符串。</p>
<h5 id="3-1-2-更多便利特性"><a href="#3-1-2-更多便利特性" class="headerlink" title="3.1.2. 更多便利特性"></a>3.1.2. 更多便利特性</h5><p>使用 val 或 var 定义变量。使用 val 定 义的变量是不可变的，即初始化后不能更改。然而，那些使用 var 定义(不推荐使用)的变 量是可变的，可以被改任意次。</p>
<p>scala中 ，循环所使用的 to()是一个方法，这一点很容易被忽略。to()方法和 until()方法实际上都是 RichInt 上的方法— 我们将在 3.2 节中讨论富封装器(rich wrapper)。变量 i 的类型为 Int， 被隐式转换为 RichInt，因此在这个变量上可以调用这个方法。这两个方法都返回 Range 的实例。因此，1 to 3等价于1.to(3)，但是前者更优雅。</p>
<h5 id="3-1-3-转向函数式风格"><a href="#3-1-3-转向函数式风格" class="headerlink" title="3.1.3. 转向函数式风格"></a>3.1.3. 转向函数式风格</h5><p>使用偏向函数式风格的 foreach()方法来实现循环：<code>(1 to 3).foreach(i =&gt; print(s&quot;$i,&quot;))</code><br>上面这个例子很简洁，且没有赋值操作。我们使用了 Range 类的 foreach()方法。这 个方法接受函数值作为参数。所以，在括号中，我们提供了一个接受一个参数的代码主体， 在这个例子中参数为 i。=&gt;符号将左侧的参数列表与右侧的实现分开。</p>
<h4 id="3-2-Java-原始类型对应的-Scala-类"><a href="#3-2-Java-原始类型对应的-Scala-类" class="headerlink" title="3.2. Java 原始类型对应的 Scala 类"></a>3.2. Java 原始类型对应的 Scala 类</h4><p>Java 的世界观是分裂的— 其原始类型(如 int 和 double)和对象截然不同。从 Java 5 开始，利用自动装箱(autoboxing)机制，可以将原始类型视为对象。然而，Java 的原始类 型不允许方法调用，如 2.toString()。另外，自动装箱还涉及类型转换的开销，会带来一 些负面的影响。<br>和 Java 不同，Scala 将所有的类型都视为对象。这就意味着，和调用对象上的方法一样， 也可以在字面量上进行方法调用。在下面的代码中，我们创建了一个 Scala 中的 Int 的实例， 并将它传给 java.util.ArrayList 的 ensureCapacity()方法，其参数类型为 Java 的 原始类型 int。</p>
<h4 id="3-3-元组和多重赋值"><a href="#3-3-元组和多重赋值" class="headerlink" title="3.3. 元组和多重赋值"></a>3.3. 元组和多重赋值</h4><p>在 Java 中，方法可以接受多个参数，但是只能返回一个结果。在 Java 中返回多个结果 需要使用拙劣的变通方案。例如，为了返回用户的姓、名和电子邮箱地址，我们不得不引入 Person 类，或者返回一个 String 数组或一个 ArrayList。Scala 的元组，与多重赋值(multiple assignment)结合，可以将返回多个值变成小菜一碟。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPersonInfo</span></span>(primaryKey: <span class="type">Int</span>) = &#123;</span><br><span class="line">    <span class="comment">// 假定primaryKey是用来获取用户信息的主键</span></span><br><span class="line">    <span class="comment">// 这里响应体是固定的</span></span><br><span class="line">    (<span class="string">"Venkat"</span>, <span class="string">"Subramaniam"</span>, <span class="string">"venkats@agiledeveloper.com"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> (firstName, lastName, emailAddress) = getPersonInfo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p> 除了直接赋值，还可以直接访问元组中的单个元素。例如，如果运行 val info = getPersonInfo(1)，那么随后就可以采用 info._1 这种语法形式访问其中的第一个元 素，第二个元素则是 info._2，以此类推。</p>
<h4 id="3-4-灵活的参数和参数值"><a href="#3-4-灵活的参数和参数值" class="headerlink" title="3.4. 灵活的参数和参数值"></a>3.4. 灵活的参数和参数值</h4><p>参数的定义和参数值的传递在任何编程语言中都是最常见的编程任务。Scala 提供了一些 便利的特性来定义变长参数、声明参数的默认值以及定义命名参数。</p>
<h5 id="3-4-1-传递变长参数值"><a href="#3-4-1-传递变长参数值" class="headerlink" title="3.4.1 传递变长参数值"></a>3.4.1 传递变长参数值</h5><p><strong>只有最后一个 参数可以接受变长参数值</strong>。我们可以在最后一个参数类型后面<strong>加上星号</strong>，以表明该参数 (parameter)可以接受可变长度的参数值(argument)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max</span></span>(values: <span class="type">Int</span>*) = values.foldLeft(values(<span class="number">0</span>)) &#123; <span class="type">Math</span>.max &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-2-为参数提供默认值"><a href="#3-4-2-为参数提供默认值" class="headerlink" title="3.4.2. 为参数提供默认值"></a>3.4.2. 为参数提供默认值</h5><p>使用参数默认值的例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mail</span></span>(destination: <span class="type">String</span> = <span class="string">"head office"</span>, mailClass: <span class="type">String</span> = <span class="string">"first"</span>): <span class="type">Unit</span> = println(<span class="string">s"sending to <span class="subst">$destination</span> by <span class="subst">$mailClass</span> class"</span>)</span><br></pre></td></tr></table></figure>

<p>调用 mail()方法的几个样例</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mail(<span class="string">"Houston office"</span>, <span class="string">"Priority"</span>) </span><br><span class="line">mail(<span class="string">"Boston office"</span>)</span><br><span class="line">mail()</span><br></pre></td></tr></table></figure>
<p>为省略的参数补上默认值这个操作是在编译时完成的。不过在重载方法的时候，需要特 别小心。如果一个方法在基类中用了一个默认值，而在其派生类的相应重载方法中却使用了 另一个默认值，就会让人感到困惑，到底选用哪个默认值。对于多参数的方法，如果对于其中一个参数，你选择使用它的默认值，你就不得不让这 个参数后面的所有参数都使用默认值。</p>
<h5 id="3-4-3-使用命名参数"><a href="#3-4-3-使用命名参数" class="headerlink" title="3.4.3. 使用命名参数"></a>3.4.3. 使用命名参数</h5><p>使用命名参数时，必须注意以下几点:</p>
<ul>
<li>对于所有没有默认值的参数，必须要提供参数的值。</li>
<li>对于那些有默认值的参数，可以选择性地使用命名参数传值。</li>
<li>一个参数最多只能传值一次。</li>
<li>在重载基类的方法时，应该保持参数名字的一致性。如果不这样做，编译器就会优先使用基类中的参数名，就可能会违背最初的目的。</li>
<li>如果有多个重载的方法，它们的参数名一样，但是参数类型不同，那么函数调用就很有可能产生歧义。在这种情况下，编译器会严格报错，就不得不切换回基于位置的参数形式。</li>
</ul>
<p>调用方式：<code>mail(mailClass = &quot;Priority&quot;)</code></p>
<h4 id="3-5-隐式参数"><a href="#3-5-隐式参数" class="headerlink" title="3.5. 隐式参数"></a>3.5. 隐式参数</h4><p>函数的定义者首先需要把参数标记为 implicit。针对这种场景，Scala 要求我们把隐式 参数放在一个单独的参数列表而非常规的参数列表中(6.4 节将详细介绍 Scala 支持多参数列 表)。如果一个参数被定义为 implicit，那么就像有默认值的参数，该参数的值传递是可然而，如果没有传值，Scala 会在调用的作用域中寻找一个隐式变量。这个隐式变量必 须和相应的隐式参数具有相同的类型，因此，在一个作用域中每一种类型都最多只能有一个 隐式变量。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wifi</span>(<span class="params">name: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectToNetwork</span></span>(user: <span class="type">String</span>)(<span class="keyword">implicit</span> wifi: <span class="type">Wifi</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">s"User: <span class="subst">$user</span> connected to WIFI <span class="subst">$wifi</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atOffice</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"--- at the office ---"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">officeNetwork</span></span>: <span class="type">Wifi</span> = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"office-network"</span>)</span><br><span class="line">  <span class="keyword">val</span> cafeteriaNetwork = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"cafe-connect"</span>)</span><br><span class="line">  connectToNetwork(<span class="string">"guest"</span>)(cafeteriaNetwork) </span><br><span class="line">  connectToNetwork (<span class="string">"Jill Coder"</span>) </span><br><span class="line">  connectToNetwork (<span class="string">"Joe Hacker"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">atJoesHome</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(<span class="string">"--- at Joe's home ---"</span>)</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">homeNetwork</span></span>: <span class="type">Wifi</span> = <span class="keyword">new</span> <span class="type">Wifi</span>(<span class="string">"home-network"</span>)</span><br><span class="line">  connectToNetwork(<span class="string">"guest"</span>)(homeNetwork)</span><br><span class="line">  connectToNetwork(<span class="string">"Joe Hacker"</span>)</span><br><span class="line">&#125;</span><br><span class="line">atOffice() </span><br><span class="line">atJoesHome()</span><br></pre></td></tr></table></figure>

<p>connectToNetwork()函数拥有两个参数列表，一个是类型为 String 的常规参数， 另一个是类型为 Wifi 的隐式参数。</p>
<p>在 atOffice()函数中，我们定义了 Wifi 类的两个实例，并将其中一个标记为 implicit。我们调用了 connectToNetwork()方法 3 次，但只在第一次调用时为参数 wifi 提供了值。其他两次调用编译器都会自动填入参数的值。如果参数有一个默认值，那么编译 器会在函数的定义中寻找该值。然而，因为这里的参数 wifi 是隐式参数，所以编译器会在 这个函数调用的作用域中寻找定义为 implicit 的值。</p>
<p>在 atJoesHome()函数中，我们只定义了一个 Wifi 实例，并标记为 implicit。给connectToNetwork()方法传递参数是可选的。例如，客人可能想要知道自己连接到了哪个网络，但是这个网络很有可能就是常驻者日常隐式使用的 。在这种情况下，显式指定一个隐式定义的参数是正确的。</p>
<p> 运行这段脚本可以观察到如下输出:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--- at the office ---</span><br><span class="line">User: guest connected to WIFI cafe-connect</span><br><span class="line">User: Jill Coder connected to WIFI office-network </span><br><span class="line">User: Joe Hacker connected to WIFI office-network</span><br><span class="line">--- at Joe&#39;s home ---</span><br><span class="line">User: guest connected to WIFI home-network</span><br><span class="line">User: Joe Hacker connected to WIFI home-network</span><br></pre></td></tr></table></figure>


<p>输出结果表明，在省略参数值时，相应作用域中的隐式变量就会被使用。尽管在不同的 函数中调用的是同一个函数，但是所传入的被省去的参数却不是同一个。虽然参数默认值和 隐式参数都可以让调用者省去参数，但是编译器绑定到参数的值却完全不同。</p>
<h4 id="3-6-字符串和多行原始字符串"><a href="#3-6-字符串和多行原始字符串" class="headerlink" title="3.6. 字符串和多行原始字符串"></a>3.6. 字符串和多行原始字符串</h4><p>在 Scala 中创建一个跨行的字符串非常简单，完全不需要用乱七八糟的+=，只要将多行的 字符串放在一对 3 个双引号之中(“””…”””)就可以了。这是 Scala 对所谓的 here 文档2(或 heredoc)的支持。我们创建一个跨行的字符串来举例说明。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str = <span class="string">""</span><span class="string">"In his famous inaugural speech, John F. Kennedy said</span></span><br><span class="line"><span class="string">"</span><span class="type">And</span> so, my fellow <span class="type">Americans</span>: ask not what your country can do <span class="keyword">for</span> you-ask what you can do <span class="keyword">for</span> your country.<span class="string">"</span></span><br><span class="line"><span class="string">He then proceeded to speak to the citizens of the World..."</span><span class="string">""</span></span><br><span class="line">println(str)</span><br></pre></td></tr></table></figure>

<h4 id="3-7-字符串插值"><a href="#3-7-字符串插值" class="headerlink" title="3.7 字符串插值"></a>3.7 字符串插值</h4><p>在 Java 中以输出或者消息的形式创建一个字符串非常混乱。例如，要创建一条这样的消 息”A discount of 10% has been applied”，其中的数值10来自一个名为discount 的变量，就十分费力。我们可以这样写:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String message = <span class="string">"A discount of "</span> + discount + <span class="string">"% has been applied"</span>;</span><br></pre></td></tr></table></figure>

<p>同样烦琐。Scala 提供了简洁而流畅的语法，使用表达式来创建字符串字面量。下面 是在 Scala 中用于创建所需要的消息的等价方式:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message = <span class="string">s"A discount of <span class="subst">$discount</span>% has been applied"</span></span><br></pre></td></tr></table></figure>

<p>字符串字面量中可以有零个或者多个内嵌表达式。如果表达式是最简单的一个变量，那 么在它的前面加上美元符号($)。而对于更复杂的表达式，可以把它们放在大括号中，如下 例所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> price = <span class="number">90</span></span><br><span class="line"><span class="keyword">val</span> totalPrice = <span class="string">s"The amount of discount is <span class="subst">$&#123;price * discount / 100&#125;</span> dollars"</span></span><br></pre></td></tr></table></figure>

<h4 id="3-8-合理的约定"><a href="#3-8-合理的约定" class="headerlink" title="3.8 合理的约定"></a>3.8 合理的约定</h4><p>Scala 中有一些约定，可以让代码简洁且易于阅读、编写。下面是这些特性的示例。</p>
<ul>
<li>支持脚本。不是所有的代码都需要放在一个类中。如果一个脚本就能满足需求，就直 接将可执行的代码放在一个文件中，没有必要都堆在一个类中。</li>
<li>return 是可选的。假定最后一个求值的表达式能够匹配方法所声明的返回类型，那 么这个表达式的求值结果将会自动作为方法调用的结果值返回。无须加入显式的 return 语句可以简化代码，尤其是在将一个闭包传递为方法参数时。</li>
<li>分号是可选的。不需要使用分号来标识每一个语句或者表达式的结束(参见 3.10.3 节)这个特性能够去除代码中的噪声。如果要多个语句放在同一行上面，可以使用分 号来分隔。没有分号，Scala 也能智能地推断出一个语句或者表达式是否是完整的， 如果不是，那么 Scala 将会接着在下一行读取剩余的代码。</li>
<li>类和方法默认就是公开的，所以你无须显式使用 public 关键字。</li>
<li>Scala 提供轻便的语法以创建 JavaBeans— 它用很少的代码就能创建变量和不可变的属性(参见 4.1.2 节)。</li>
<li>对于我们不关心的那些异常，Scala不会强制要求进行捕获(参见10.1节)，这样做能够缩减代码体积，同时也能够避免不合理的异常处理。</li>
<li>括号和点号也是可选的，我们在 3.1.2 节讨论过。</li>
</ul>
<p>除此之外，Scala 默认会导入两个包、scala.Predef 对象以及它们相应的类和成员。 只用类名就可以从这些预导入的包中引用相应的类。Scala 按照顺序导入下面的包和类:</p>
<ul>
<li>java.lang</li>
<li>scala</li>
<li>scala.Predef</li>
</ul>
<h4 id="3-9-操作符重载"><a href="#3-9-操作符重载" class="headerlink" title="3.9. 操作符重载"></a>3.9. 操作符重载</h4><p>不常用，不实际 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Complex</span>(<span class="params">val real: <span class="type">Int</span>, val imaginary: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">+</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">    println(<span class="string">"Calling +"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Complex</span>(real + operand.real, imaginary + operand.imaginary)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">*</span></span>(operand: <span class="type">Complex</span>): <span class="type">Complex</span> = &#123;</span><br><span class="line">    println(<span class="string">"Calling *"</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Complex</span>(</span><br><span class="line">      real * operand.real - imaginary * operand.imaginary,</span><br><span class="line">      real * operand.imaginary + imaginary * operand.real)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sign = <span class="keyword">if</span> (imaginary &lt; <span class="number">0</span>) <span class="string">""</span> <span class="keyword">else</span> <span class="string">"+"</span></span><br><span class="line">    <span class="string">s"<span class="subst">$real</span><span class="subst">$sign</span><span class="subst">$&#123;imaginary&#125;</span>i"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> c1 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">1</span>, <span class="number">4</span>) </span><br><span class="line"><span class="keyword">val</span> c2 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">2</span>, - <span class="number">3</span>) </span><br><span class="line"><span class="keyword">val</span> c3 = <span class="keyword">new</span> <span class="type">Complex</span> (<span class="number">2</span>, <span class="number">2</span>) </span><br><span class="line">println (c1 + c2 * c3)</span><br></pre></td></tr></table></figure>

<h4 id="3-10-Scala-与-Java-的差异"><a href="#3-10-Scala-与-Java-的差异" class="headerlink" title="3.10. Scala 与 Java 的差异"></a>3.10. Scala 与 Java 的差异</h4><p>在你开始感受到 Scala 设计上的优雅和简洁时，你也应该注意到一些细微差别。例如， 在处理赋值、等价性检查、函数返回值的时候，Scala 和 Java 有语义上的不同。因为这些特 性的处理与我们在 Java 中已经习惯的方式有显著的不同，很容易犯错。请花一点时间了解它 们以避免各种“惊喜”。</p>
<h5 id="3-10-1-赋值的结果"><a href="#3-10-1-赋值的结果" class="headerlink" title="3.10.1. 赋值的结果"></a>3.10.1. 赋值的结果</h5><p>在Java中，赋值操作(像a = b)的值就是a的值，因此像x = a = b这样的多重 赋值就可以出现，但是在 Scala 中不能这样做。在 Scala 中赋值操作的结果值是一个 Unit— 大概等价于一个 Void。从结果上讲，将这种值赋值给另外一个变量有可能造成类型不匹配。 看一看下面这个例子。</p>
<h5 id="3-10-2-Scala-的"><a href="#3-10-2-Scala-的" class="headerlink" title="3.10.2. Scala 的=="></a>3.10.2. Scala 的==</h5><p>对于基于值的比较，在 Scala 中，可以使用简洁的==而不是 equals()方法。如果要对 引用做基于身份1的比较，那么可以使用 Scala 中的 eq()方法。</p>
<h5 id="3-10-3-可有可无的分号"><a href="#3-10-3-可有可无的分号" class="headerlink" title="3.10.3. 可有可无的分号"></a>3.10.3. 可有可无的分号</h5><p>在涉及语句或者表达式的终止时，Scala 很厚道— 分号(;)是可选的，这就能够减少 代码中的噪声。我们可以在语句或者表达式的末尾放置一个分号，特别是，如果想要在同一 行上放置多个语句或者表达式的话，但一定要小心。在同一行上写多个语句或者表达式可能 会降低代码的可读性，就像下面这个例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sample = <span class="keyword">new</span> <span class="type">Sample</span>;</span><br><span class="line">println(sample)</span><br></pre></td></tr></table></figure>
<p>如果一行的末尾没有以一个中缀标记1(如+、*、. )结尾，且不在括号或者方括号中， 那么 Scala 会自动补上分号。如果下一行的起始处能够开始一个语句或者表达式，那么这一 行的末尾也会自动补上分号。</p>
<h5 id="3-10-4-避免显式-return"><a href="#3-10-4-避免显式-return" class="headerlink" title="3.10.4. 避免显式 return"></a>3.10.4. 避免显式 return</h5><p>使用 return 语句从方法返回结果，而这在 Scala 中却不是一个好的实 践。return 语句在 Scala 中是隐式的，显式地放置一个 return 命令会影响 Scala 推断返回 类型的能力。</p>
<h4 id="3-11-默认访问修饰符"><a href="#3-11-默认访问修饰符" class="headerlink" title="3.11. 默认访问修饰符"></a>3.11. 默认访问修饰符</h4><p>Scala 的访问修饰符(access modifier)和 Java 有如下不同点: </p>
<ul>
<li>如果不指定任何访问修饰符，那么 Java 会默认为包内部可见，而 Scala 则默认为公开。</li>
<li>Java 主张全有或全无，也就是说，对当前包的所有类可见或者对所有都不可见。而Scala 对可见性的控制是细粒度的。</li>
<li>Java 的 protected 是宽泛的，其作用域包括在任意包中的派生类和当前包中的任意类，而 Scala 的 protected 与 C++和 C#的类似，只有派生类能够访问。然而，在Scala 中 protected 还有相当自由和灵活的用法。</li>
<li>Java 的封装是类级别的。可以在一个类的实例方法中访问该类的任何实例的所有私有字段和方法，在 Scala 中也一样，不过，在 Scala 中也可以进行定制，让其只能在当 前的实例方法中访问，这样就和 Ruby 比较像了。</li>
</ul>
<h5 id="3-11-1-定制访问修饰"><a href="#3-11-1-定制访问修饰" class="headerlink" title="3.11.1. 定制访问修饰"></a>3.11.1. 定制访问修饰</h5><p>在不使用任何访问修饰符的情况下，Scala 默认认为类、字段和方法都是公开的。如 果想将一个成员标记为 private 或者 protected，只要像下面这样用相应的关键字标 记即可。</p>
<h5 id="3-11-2-Scala-的-protected"><a href="#3-11-2-Scala-的-protected" class="headerlink" title="3.11.2. Scala 的 protected"></a>3.11.2. Scala 的 protected</h5><p>在 Scala 中，protected 让所修饰的成员仅对自己和派生类可见。对于其他类来说，即 使正好和所定义这个类处于同一个包中，也无法访问这些成员。更进一步，派生类在访问 protected 成员的时候，成员的类型也需要一致。让我们用下面的例子做检验。</p>
<h5 id="3-11-3-细粒度的访问控制"><a href="#3-11-3-细粒度的访问控制" class="headerlink" title="3.11.3. 细粒度的访问控制"></a>3.11.3. 细粒度的访问控制</h5><p>可以为 private 和 protected 修饰符指定额外的参数。故而，除了简单地将一个成员 标记为 private，还可以标记为 private[AccessQualifier]，其中 AccessQualifier 可以是任何封闭类名、一个封闭的包名或者是 this(即实例级别的可见性)。</p>
<p>访问修饰符上的限定词告诉 Scala，对于所有类该成员都是私有的，除了以下情况。</p>
<ul>
<li>如果没有指定 AccessQualifier(在默认情况下)，那么该成员只能在当前类或者 其伴生对象中访问(第 4 章中将讨论伴生对象)。</li>
<li>如果 AccessQualifier 是一个类名，那么该成员可以在当前类、伴生对象以及 AccessQualifier 对应的封闭类和其伴生对象中可访问。</li>
<li>如果 AccessQualifier 是一个封闭的包名，那么该成员可以在当前类、伴生对象 以及所提到的包下面的所有类中访问。</li>
<li>如果 AccessQualifier 是 this，那么将会限制该成员只能在该实例中访问，对 于同一个类的其他实例，也是不可见的，这是所有选项中限制最严格的。</li>
</ul>
<h3 id="4-处理对象"><a href="#4-处理对象" class="headerlink" title="4. 处理对象"></a>4. 处理对象</h3><p>我们将从最熟悉的基础开始，快速深入 Scala 面向对象的方方面面。让我们把一个简单 的 Java 类移植到 Scala，然后再深入研究 Scala 的能力。首先构造器就很有意思，因为 Scala 代码往往会比 Java 代码更加简洁，然后我们会见到 Scala 为对象的创建提供的便利。</p>
<h4 id="4-1-创建并使用类"><a href="#4-1-创建并使用类" class="headerlink" title="4.1 创建并使用类"></a>4.1 创建并使用类</h4><p>在 Scala 中创建类表意清晰且高度简洁。我们先探索如何创建实例，然后探索如何创建 类，最后才是如何定义字段和方法。</p>
<h5 id="4-1-1-创建实例"><a href="#4-1-1-创建实例" class="headerlink" title="4.1.1. 创建实例"></a>4.1.1. 创建实例</h5><p>在 Scala 中创建类的实例和在 Java 中创建实例差不太多。例如，我们创建 StringBuilder 的一个实例:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">StringBuilder</span>(<span class="string">"hello"</span>)</span><br></pre></td></tr></table></figure>
<h5 id="4-1-2-创建类"><a href="#4-1-2-创建类" class="headerlink" title="4.1.2. 创建类"></a>4.1.2. 创建类</h5><p>在 Java 的版本中，我们为属性 year 显式定义了字段和方法，并显式定义了构造器。而 在 Scala 中，类构造器(我们非正式地用其指代类)的参数定义了字段，并自动生成了访问 器方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">var</span> milesDriven: <span class="type">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">miles</span></span>: <span class="type">Int</span> = milesDriven</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">drive</span></span>(distance: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    milesDriven += <span class="type">Math</span>.abs(distance)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-定义字段、方法和构造器"><a href="#4-1-3-定义字段、方法和构造器" class="headerlink" title="4.1.3. 定义字段、方法和构造器"></a>4.1.3. 定义字段、方法和构造器</h5><p>如果类定义没有主体，就没有必要使用大括号({})。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditCard</span>(<span class="params">val number: <span class="type">Int</span>, var creditLimit: <span class="type">Int</span></span>)</span></span><br></pre></td></tr></table></figure>

<p>除了用主构造器参数声明的字段，还可以定义其他字段、方法和辅助构造器(auxiliary constructor)。在下面的代码中，this()方法就是一个辅助构造器。另外，我们定义了变量 position 并且重载了 toString()方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">val firstName: <span class="type">String</span>, val lastName: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> position: <span class="type">String</span> = _</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$toString</span>"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(firstName: <span class="type">String</span>, lastName: <span class="type">String</span>, positionHeld: <span class="type">String</span>) &#123; <span class="keyword">this</span>(firstName, lastName)</span><br><span class="line">    position = positionHeld</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = &#123;<span class="string">s"<span class="subst">$firstName</span> <span class="subst">$lastName</span> holds <span class="subst">$position</span> position"</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与类定义结合的主构造器接收两个参数，即 firstName 和 lastName。如果需要，可 以很容易就把主构造器设置为 private，详见 4.6.2 节。<br>除了主构造器，我们还有一个辅助构造器，使用名为 this()的方法定义。它接收 3 个 参数:前两个和主构造器相同，第三个是 positionHeld。在辅助构造器中，我们调用主构 造器来初始化与名字相关的字段。Scala 强制规定:辅助构造器的第一行有效语句必须调用主 构造器或者其他辅助构造器。</p>
<h4 id="4-2-遵循-JavaBean-惯例"><a href="#4-2-遵循-JavaBean-惯例" class="headerlink" title="4.2. 遵循 JavaBean 惯例"></a>4.2. 遵循 JavaBean 惯例</h4><p>大部分 Java 框架已经认定了 JavaBean 惯例，不遵循该惯例会 让我们在那些框架中使用 Scala 类非常困难。别着急，用一个注解就能轻松解决这个问题。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dude</span>(<span class="params">@<span class="type">BeanProperty</span> val firstName: <span class="type">String</span>, val lastName: <span class="type">String</span></span>) </span>&#123; </span><br><span class="line">  <span class="meta">@BeanProperty</span> <span class="keyword">var</span> position: <span class="type">String</span> = _</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用该注解，我们让 Scala 创建了访问器方法 getFirstName()、getPosition()和 setPosition()，还有两个参数和一个声明字段上的 Scala 风格的访问器。因为我们没有用 该注解标记参数 lastName，所以 Scala 不会为它生成 JavaBean 风格的访问器。</p>
<h4 id="4-3-类型别名"><a href="#4-3-类型别名" class="headerlink" title="4.3. 类型别名"></a>4.3. 类型别名</h4><p>Cop 就能概括这一切，也更容易输入。下面演示了如何给 PoliceOfficer 取别名，且不失其身份。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PoliceOfficer</span>(<span class="params">val name: <span class="type">String</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">CopApp</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">type</span> <span class="title">Cop</span> </span>= <span class="type">PoliceOfficer</span></span><br><span class="line">  <span class="keyword">val</span> topCop = <span class="keyword">new</span> <span class="type">Cop</span>(<span class="string">"Jack"</span>)</span><br><span class="line">  println(topCop.getClass)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Scala 标准库中很多类都取了别名。有时候别名是为了使用更合适的名字，有时候是为了 在指定包中引用某些类。例如，Set 就是一个别名，它指向 immutable 包中的 Set 版本， 而不是 mutable 包中的版本。</p>
<h4 id="4-4-扩展一个类"><a href="#4-4-扩展一个类" class="headerlink" title="4.4. 扩展一个类"></a>4.4. 扩展一个类</h4><p>在 Scala 中扩展一个基类和 Java 中很像，只是多了两个非常好的限制:其一，方法的重 载必须用 override 关键字;其二，只有主构造器能传递参数给基类的构造器。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vehicle</span>(<span class="params">val id: <span class="type">Int</span>, val year: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"ID: <span class="subst">$id</span> Year: <span class="subst">$year</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>(<span class="params">override val id: <span class="type">Int</span>, override val year: <span class="type">Int</span>, var fuelLevel: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Vehicle</span>(<span class="params">id, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"<span class="subst">$&#123;super.toString&#125;</span> Fuel Level: <span class="subst">$fuelLevel</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> car = <span class="keyword">new</span> <span class="type">Car</span>(<span class="number">1</span>, <span class="number">2015</span>, <span class="number">100</span>)</span><br><span class="line">println(car)</span><br></pre></td></tr></table></figure>

<h4 id="4-5-参数化类型"><a href="#4-5-参数化类型" class="headerlink" title="4.5. 参数化类型"></a>4.5. 参数化类型</h4><p>在 Scala 中，可以创建单独的函数，也可以创建参数化的函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>[<span class="type">T</span>](input1: <span class="type">T</span>, input2: <span class="type">T</span>): <span class="type">Unit</span> = println(<span class="string">s"got <span class="subst">$input1</span> (<span class="subst">$&#123;input1.getClass&#125;</span>) <span class="subst">$input2</span> (<span class="subst">$&#123;input2.getClass&#125;</span>)"</span>)</span><br></pre></td></tr></table></figure>

<p>没有将 echo()函数的参数类型指定为 Int 或者 String 这样的具体类型，而是将 它们开放为参数化类型 T，留给程序员去决定(具体类型)。记号[T]告诉编译器后面提到的 类型 T 其实不是一个已经存在的命名风格糟糕的单字母类，而是一个参数化类型。</p>
<p>可以像调用别的函数一样调用这个函数，但是参数的类型必须在调用时决定。我们使用 两种不同类型的参数来调用 echo()函数。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo(<span class="string">"hello"</span>, <span class="string">"there"</span>) </span><br><span class="line">echo(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>创建一个参数化类和创建参数化函数一样简单。我们创建了一个类 Message，并延迟定义其字段的类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span>[<span class="type">T</span>](<span class="params">val content: <span class="type">T</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"message content is <span class="subst">$content</span>"</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">is</span></span>(value: <span class="type">T</span>): <span class="type">Boolean</span> = value == content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字段 content 的类型被参数化了，其类型会在类创建实例的时候决定。is()方法的参 数类型也是如此。和单独的函数不同，我们不需要在 is()方法的定义中放[T]标记。如果这 个方法接受的参数类型不是类层面指定的参数化类型 T，基于同样的理由，我们就必须和前 面提到的一样使用那个标记。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> message1: <span class="type">Message</span>[<span class="type">String</span>] = <span class="keyword">new</span> <span class="type">Message</span>(<span class="string">"howdy"</span>) </span><br><span class="line"><span class="keyword">val</span> message2 = <span class="keyword">new</span> <span class="type">Message</span>(<span class="number">42</span>)</span><br><span class="line">println(message1) </span><br><span class="line">println(message1.is(<span class="string">"howdy"</span>)) </span><br><span class="line">println(message1.is(<span class="string">"hi"</span>)) </span><br><span class="line">println(message2.is(<span class="number">22</span>))</span><br></pre></td></tr></table></figure>

<p>在 Java 中，<strong>尖括号(&lt;&gt;)被用于指定泛型。在 Scala 中我们使用方括号([])来替代</strong> 。然而，这不是唯一的差异。在 Java 中类型擦除会让范式变得相当脆弱，Scala 在参数化类型 上会做更加严谨的类型检查— 我们会在 5.1.2 节中看到这些内容。而且，我们可以在参数化 类型上加限制— 我们将会在 5.4 节中探索这个话题。</p>
<h4 id="4-6-单例对象和伴生对象"><a href="#4-6-单例对象和伴生对象" class="headerlink" title="4.6 单例对象和伴生对象"></a>4.6 单例对象和伴生对象</h4><p>在处理 static 字段和方法时，Scala 和 Java 有显著不同。此外，Scala 直接支持单例对 象。我们来探索一下单例对象和伴生对象，以及 Scala 对 static 的处理方法。</p>
<h5 id="4-6-1-单例对象"><a href="#4-6-1-单例对象" class="headerlink" title="4.6.1. 单例对象"></a>4.6.1. 单例对象</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span>(<span class="params">val color: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$&#123;this&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"marker color <span class="subst">$color</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">MarkerFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> markers = mutable.<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"red"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"red"</span>), <span class="string">"blue"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"blue"</span>), <span class="string">"yellow"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"yellow"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMarker</span></span>(color: <span class="type">String</span>): <span class="type">Marker</span> = markers.getOrElseUpdate(color, <span class="keyword">new</span> <span class="type">Marker</span>(color))</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-6-2-独立对象和伴生对象"><a href="#4-6-2-独立对象和伴生对象" class="headerlink" title="4.6.2. 独立对象和伴生对象"></a>4.6.2. 独立对象和伴生对象</h5><p>选择将一个单例关联到一个类。这样的单例，其名字和对应类的名字一致，因此被 称为伴生对象(companion object)。相应的类被称为伴生类。我们在后面可以看到这种方式 非常强大。</p>
<p>在前面的例子中，我们想规范 Marker 实例的创建。类与其伴生对象间没有边界— 它 们可以相互访问私有字段和方法。一个类的构造器，包括主构造器，也可以标记为 private。 我们可以结合这两个特性来解决前一节末尾特别提出的问题。下面是使用一个伴生对象对 Marker 这个例子进行的重写。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.collection._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Marker</span> <span class="title">private</span>(<span class="params">val color: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">s"Creating <span class="subst">$&#123;this&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span> </span>= <span class="string">s"marker color <span class="subst">$color</span>"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Marker</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> markers = mutable.<span class="type">Map</span>(</span><br><span class="line">    <span class="string">"red"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"red"</span>), <span class="string">"blue"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"blue"</span>), <span class="string">"yellow"</span> -&gt; <span class="keyword">new</span> <span class="type">Marker</span>(<span class="string">"yellow"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMarker</span></span>(color: <span class="type">String</span>): <span class="type">Marker</span> = markers.getOrElseUpdate(color, <span class="keyword">new</span> <span class="type">Marker</span>(color))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Marker 的构造器被声明为 private;然而，它的伴生对象可以访问它。因此，我们可 以在伴生对象中创建 Marker 的实例。如果试着在类或者伴生对象之外创建 Marker 的实例， 就会收到错误提示。</p>
<h5 id="4-6-3-Scala-中的-static"><a href="#4-6-3-Scala-中的-static" class="headerlink" title="4.6.3. Scala 中的 static"></a>4.6.3. Scala 中的 static</h5><p> 在 Scala 的未来版本中，将会引入@static 注解对静态方法和字段提供了支持。</p>
<h4 id="4-7-创建枚举类"><a href="#4-7-创建枚举类" class="headerlink" title="4.7. 创建枚举类"></a>4.7. 创建枚举类</h4><p>Scala 中创建枚举，要先从创建对象开始，这和创建一个单例的语法特别相像，但 可以赋予多个命名的实例，毕竟，单例模式并不强制只有一个实例，它只是一种对所选实例 的创建的控制方式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Currency</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Currency</span> </span>= <span class="type">Value</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">CNY</span>, <span class="type">GBP</span>, <span class="type">INR</span>, <span class="type">JPY</span>, <span class="type">NOK</span>, <span class="type">PLN</span>, <span class="type">SEK</span>, <span class="type">USD</span> = <span class="type">Value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-8-包对象"><a href="#4-8-包对象" class="headerlink" title="4.8. 包对象"></a>4.8. 包对象</h4><p>首先我们使用单例创建一个例子，然后将其转换成一个包对象，这样做可以帮助我们理解其中的好处。<br>在这个例子中，我们会复用之前创建的枚举 Currency 和类 Money。这是一个名为 Converter 的单例，带有一个 convert()方法，它能帮助我们将钱从一种货币换算成另一 种货币。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="type">Currency</span>._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Converter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(money: <span class="type">Money</span>, to: <span class="type">Currency</span>): <span class="type">Money</span> = &#123;</span><br><span class="line">    <span class="comment">// 获取当前的市场汇率......这里使用了模拟值</span></span><br><span class="line">    <span class="keyword">val</span> conversionRate = <span class="number">2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Money</span>(money.amount * conversionRate, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们在同一个包的类 Charge 中使用这个方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance.currencies</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Charge</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">chargeInUSD</span></span>(money: <span class="type">Money</span>): <span class="type">String</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">moneyInUSD</span> </span>= <span class="type">Converter</span>.convert(money, <span class="type">Currency</span>.<span class="type">USD</span>)</span><br><span class="line">    <span class="string">s"charged $$<span class="subst">$&#123;moneyInUSD.amount&#125;</span>"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们能够敏锐地观察到:convert()操作对于 finance.currencies 这个包非常基 础，但是 Converter 这个前缀没有增加任何价值。它是一个人工的占位符— 一种噪声。 我们可以用包对象来避免它。<br>包对象没什么特别的，就是一个单例，和 Converter 本身很像，只不过它有特殊的名 字和语法。它使用相应的包名作为名字，并用单词 package 标记。我们把 Converter 重 写为一个包对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> finance</span><br><span class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">currencies</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">Currency</span>._</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">convert</span></span>(money: <span class="type">Money</span>, to: <span class="type">Currency</span>): <span class="type">Money</span> = &#123; <span class="comment">// 获取当前的市场汇率......这里使用了模拟值</span></span><br><span class="line">    <span class="keyword">val</span> conversionRate = <span class="number">2</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">Money</span>(money.amount * conversionRate, to)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-善用类型"><a href="#5-善用类型" class="headerlink" title="5. 善用类型"></a>5. 善用类型</h3><h4 id="5-1-类型推断"><a href="#5-1-类型推断" class="headerlink" title="5.1. 类型推断"></a>5.1. 类型推断</h4><p>与任何静态类型的编程语言一样，Scala 在编译时验证对象的类型。同时，它不要求明确 标注显而易见的类型，它可以进行类型推断。无论是对于简单类型还是泛型，都可以使用类 型推断。</p>
<h5 id="5-1-1-简单类型的类型推断"><a href="#5-1-1-简单类型的类型推断" class="headerlink" title="5.1.1. 简单类型的类型推断"></a>5.1.1. 简单类型的类型推断</h5><p>以下几种情况下，必须要显式地指定类型:</p>
<ul>
<li>当定义没有初始值的类字段时;</li>
<li>当定义函数或方法的参数时;</li>
<li>当定义函数或方法的返回类型，仅当我们使用显式的 return 语句或者使用递归时1;</li>
<li>当将变量定义为另一种类型，而不是被直接推断出的类型时，如 val frequency: 2 Double = 1 。</li>
</ul>
<h5 id="5-1-2-针对泛型和集合的类型推断"><a href="#5-1-2-针对泛型和集合的类型推断" class="headerlink" title="5.1.2. 针对泛型和集合的类型推断"></a>5.1.2. 针对泛型和集合的类型推断</h5><p>定义 了几个 ArrayList 的实例，我们先使用显式的类型，然后再使用类型推断。</p>
<p><code>var list1: util.List[Int] = new util.ArrayList[Int]</code></p>
<h4 id="5-2-基础类型"><a href="#5-2-基础类型" class="headerlink" title="5.2 基础类型"></a>5.2 基础类型</h4><p>尽管可以在 Scala 中使用 Java 的任何类型，但同时也可以享受到由 Scala 提供的一些原生 类型。Scala 在值类型和引用类型之间进行了更加明确的划分，并且通过类型定义进一步增强 了类型验证和类型推断。让我们掌握这些基础类型，因为在 Scala 中，将会经常遇到这些类型。</p>
<h5 id="5-2-1-Any-类型"><a href="#5-2-1-Any-类型" class="headerlink" title="5.2.1. Any 类型"></a>5.2.1. Any 类型</h5><p>Scala 的 Any 类型是所有类型的超类型2，如图 5-1 所示。<br><img src="media/15773763608881/15777817957416.jpg" alt=""><br>Any 是一个抽象类1，定义了如下方 法:!=()、==()、asInstanceOf()、equals()、hashCode()、isInstanceOf() 和 toString()。</p>
<h5 id="5-2-2-关于-Nothing"><a href="#5-2-2-关于-Nothing" class="headerlink" title="5.2.2. 关于 Nothing"></a>5.2.2. 关于 Nothing</h5><p>在 Scala 中，Nothing 是一切类型的子类型。</p>
<h5 id="5-2-3-Option-类型"><a href="#5-2-3-Option-类型" class="headerlink" title="5.2.3. Option 类型"></a>5.2.3. Option 类型</h5><p>返回空集合，而不是 null 引用。如果遵循这个建议，我们就不必忍受 NullPointerException 了。即使结果 集合为空，迭代也会变得很容易。在使用集合的时候，这是很好的建议，但是在使用其他返 回类型时，我们也需要类似的内容。</p>
<p>Scala 进一步指定了可能的不存在性。使用 Scala 的 Option[T]，可以进行有意图的编 程，并指定打算不返回结果。Scala 以类型安全的方式实现了这一点，因此可以在编译时强制 进行检查。让我们来看一个使用了这个特殊类型的例子。</p>
<h5 id="5-2-4-Either-类型"><a href="#5-2-4-Either-类型" class="headerlink" title="5.2.4 Either 类型"></a>5.2.4 Either 类型</h5><p>当一个函数调用的结果可能存在也可能不存在时，Option 类型很有用。有时候，你可 能希望从一个函数中返回两种不同类型的值之一。这个时候，Scala 的 Either 类型就派上 用场了。</p>
<h4 id="5-3-返回值类型推断"><a href="#5-3-返回值类型推断" class="headerlink" title="5.3 返回值类型推断"></a>5.3 返回值类型推断</h4><p>Scala 是否自动推断取决于你如何定义函数。<strong>只有当你使用等号(=)将方法 的声明和方法的主体部分区分开时1，Scala 的返回值类型推断才会生效。否则，该方法将 会被视为返回一个 Unit，等效于 Java 中的 Void。</strong>让我们研究一下下面这些函数的返回值 类型。</p>
<h4 id="5-4-参数化类型的型变"><a href="#5-4-参数化类型的型变" class="headerlink" title="5.4 参数化类型的型变"></a>5.4 参数化类型的型变</h4><p>在 5.1.2 节中，Scala 阻止我们将一个指向 ArrayList[Int]的引用赋值给一个指向 Array List[Any]的引用。这是一件好事情。通常来说，一个派生类型的集合不应该赋值给一个基 类型的集合。然而，有时候我们需要放宽这一规则。在这些情况下，我们可以要求 Scala 允 许在其他情况下无效的转换。</p>
<h5 id="5-4-1-协变和逆变"><a href="#5-4-1-协变和逆变" class="headerlink" title="5.4.1 协变和逆变"></a>5.4.1 协变和逆变</h5><p>在期望接收一个基类实例的集合的地方，能够使用一个子类实例的集合的能力叫作协变 (covariance)。而在期望接收一个子类实例的集合的地方，能够使用一个超类实例的集合的能力叫作逆变(contravariance)。在默认的情况下，Scala 都不允许(即不变)。</p>
<h5 id="5-4-2-支持协变"><a href="#5-4-2-支持协变" class="headerlink" title="5.4.2 支持协变"></a>5.4.2 支持协变</h5><p>虽然 Scala 的默认行为总的来说是好事，但是我们还是想要小心地将派生类型的集合， 也就是 Dog 的集合，看作是其基类型的集合，也就是 Pet 的集合。考虑下面的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dogs = <span class="type">Array</span>(<span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"Rover"</span>), <span class="keyword">new</span> <span class="type">Dog</span>(<span class="string">"Comet"</span>))</span><br></pre></td></tr></table></figure>
<p>如果我们把 dogs 传递给前面的方法，我们将会得到一个编译错误:workWithPets(dogs) // 编译错误</p>
<p>不能将一个包含Dog的数组发送给一个接受 Pet 的数组的方法。但是，这个方法是无害的。然而，Scala 并不知道这一点，<br>所以它试图保护我们。我们必须要告诉 Scala，我们允许这样做。下面是一个我们如何能够做到这一点的例子 。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playWithPets</span></span>[<span class="type">T</span> &lt;: <span class="type">Pet</span>](pets: <span class="type">Array</span>[<span class="type">T</span>]): <span class="type">Unit</span> = println(<span class="string">"Playing with pets: "</span> + pets.mkString(<span class="string">", "</span>))</span><br></pre></td></tr></table></figure>
<p>我们使用一种特殊语法定义了playWithPets()方法。T &lt;: Pet表明由T表示的类 派生自 Pet 类。这个语法用于定义一个上界(如果可视化这个类的层次结构，那么 Pet 将 会是类型 T 的上界)，T 可以是任何类型的 Pet，也可以是在该类型层次结构中低于 Pet 的 类型。通过指定上界，我们告诉 Scala 数组参数的类型参数 T 必须至少是一个 Pet 的数组， 但是也可以是任何派生自 Pet 类型的类的实例数组。因此，现在我们可以执行下面的调用了。</p>
<h5 id="5-4-3-支持逆变"><a href="#5-4-3-支持逆变" class="headerlink" title="5.4.3. 支持逆变"></a>5.4.3. 支持逆变</h5><p>假设我们想要将宠物从一个集合复制到另外一个集合，那么我们可以编写一个名 为 copy()的方法，其接受两个类型为 Array[Pet]的参数。然而，这将不能帮助我们传递 一个 Dog 的数组。此外，我们应该能够从一个 Dog 的数组复制到一个 Pet 的数组。换句话 说，在这个场景下，接收数组中元素类型是源数组中元素类型的超类型也是可以的。这里我们需要的是一个下界 。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyPets</span></span>[<span class="type">S</span>, <span class="type">D</span> &gt;: <span class="type">S</span>](fromPets: <span class="type">Array</span>[<span class="type">S</span>], toPets: <span class="type">Array</span>[<span class="type">D</span>]): <span class="type">Unit</span> = &#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="keyword">val</span> pets = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Pet</span>](<span class="number">10</span>) </span><br><span class="line">copyPets(dogs, pets)</span><br></pre></td></tr></table></figure>

<h5 id="5-4-4-定制集合的型变"><a href="#5-4-4-定制集合的型变" class="headerlink" title="5.4.4 定制集合的型变"></a>5.4.4 定制集合的型变</h5><p>如果你是一个集合类的作者， 你也可以控制这一行为，也就是说，如果你假定派生类型的集合可以被看作是其基类型的集 合。你可以通过将参数化类型标记为+T 而不是 T 来完成这项操作，如下所示。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyList</span>[+<span class="type">T</span>] <span class="title">//</span>...</span></span><br><span class="line"><span class="class"><span class="title">var</span> <span class="title">list1</span> </span>= <span class="keyword">new</span> <span class="type">MyList</span>[<span class="type">Int</span>] </span><br><span class="line"><span class="keyword">var</span> list2: <span class="type">MyList</span>[<span class="type">Any</span>] = _ </span><br><span class="line">list2 = list1 <span class="comment">// 编译正确</span></span><br></pre></td></tr></table></figure>

<h4 id="5-5-隐式类型转换"><a href="#5-5-隐式类型转换" class="headerlink" title="5.5 隐式类型转换"></a>5.5 隐式类型转换</h4><p>实现类型转换有两种不同的方式— 编写隐式函数和创建隐式类。第一种方法在 Scala 中由来已久，而隐式类则是相对较新的。让我们一起来探索一下吧。</p>
<h5 id="5-5-1-隐式函数"><a href="#5-5-1-隐式函数" class="headerlink" title="5.5.1 隐式函数"></a>5.5.1 隐式函数</h5><p>DateHelper 提供了我们想要的 days()方法。我们在该方法中使用的 match()方法 是 Scala 的模式匹配(我们将会在第 9 章中学习)的一部分。因为 DateHelper 是一个常规 类，所以我们可以创建一个它的实例，并调用其上面的 days()方法。但是，真正的乐趣在 于，在一个 Int 上调用 days()方法，并让 Scala 静默地将 Int 转换为一个 DateHelper 的实例，这样就可以调用这个方法了。Scala 只需在一个简单的函数前面加上 implicit 关 键字即可使用启用这个技巧的特性。<br>如果一个函数被标记为 implicit，且在当前作用域中存在这个函数(通过当前的 import 语句导入，或者存在于当前文件中)，那么 Scala 都将会自动使用这个函数。让我们 创建这个隐式函数，并进行流式调用吧:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scala.language.implicitConversions</span><br><span class="line"><span class="keyword">import</span> java.time.<span class="type">LocalDate</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">offset: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">LocalDate</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> today = <span class="type">LocalDate</span>.now</span><br><span class="line">    when <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; today.minusDays(offset)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; today.plusDays(offset)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; today</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">  <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//  implicit def convertInt2DateHelper(offset: Int): DateHelper = new DateHelper(offset)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TopStock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">convertInt2DateHelper</span></span>(offset: <span class="type">Int</span>): <span class="type">DateHelper</span> = <span class="keyword">new</span> <span class="type">DateHelper</span>(offset)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">    <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line">    <span class="keyword">val</span> past = <span class="number">2.</span>days(ago)</span><br><span class="line">    <span class="keyword">val</span> appointment = <span class="number">5</span> days from_now</span><br><span class="line">    println(past)</span><br><span class="line">    println(appointment)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-2-隐式类"><a href="#5-5-2-隐式类" class="headerlink" title="5.5.2 隐式类"></a>5.5.2 隐式类</h5><p>将一个类标记为 implicit 类。当使用隐式 类的时候，Scala 设置了一些限制。其中最值得注意的是，它不能是一个独立的类，它必须要 在一个单例对象、类或者特质中。让我们重新修改这个流式日期的例子，从而使用隐式类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DateUtil</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> ago = <span class="string">"ago"</span></span><br><span class="line">  <span class="keyword">val</span> from_now = <span class="string">"from_now"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="class"><span class="keyword">class</span> <span class="title">DateHelper</span>(<span class="params">val offset: <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">import</span> java.time.<span class="type">LocalDate</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">days</span></span>(when: <span class="type">String</span>): <span class="type">LocalDate</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> today = <span class="type">LocalDate</span>.now</span><br><span class="line">      when <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"ago"</span> =&gt; today.minusDays(offset)</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"from_now"</span> =&gt; today.plusDays(offset)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; today</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TopStock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">DateUtil</span>._</span><br><span class="line">    <span class="keyword">val</span> past = <span class="number">2</span> days ago</span><br><span class="line">    <span class="keyword">val</span> appointment = <span class="number">5</span> days from_now</span><br><span class="line">    println(past)</span><br><span class="line">    println(appointment)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  	</div>
	  
	  <div class="article-tags tags">
      
        <a href="/tags/software-programming/">software programming</a>
      
        <a href="/tags/scala/">scala</a>
      
	  </div>
    
		
	
		<div class="art-item-footer">
				
				
					<span class="art-item-right">next：<a href="/2020/01/01/----80/" rel="next"  title="开局一只狗，装备全靠打">
						开局一只狗，装备全靠打
					</a><i class="icon icon-chevron-thin-right"></i></span>
				
		</div>
	
	</section>
	
</article>
<script>
	window.subData = {
		title: 'Scala实用指南读书笔记（一）',
		tools: true
	}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>bon爸</div>
<div class='content'>
<div class='desc'>成为世界的基石 ...</div>
</div>
</section>


  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/bondaddy">
            <div class='name'>github</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/blog/"><div class='name'>blog</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/professional-skill/"><div class='name'>professional skill</div><div class='badget'>1</div></a></li>
    
        <li><a class="flat-box" href="/categories/qzone/"><div class='name'>qzone</div><div class='badget'>79</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/mood/" style="font-size: 17px; color: #404040">mood</a> <a href="/tags/qzone/" style="font-size: 20px; color: #000">qzone</a> <a href="/tags/scala/" style="font-size: 14px; color: #808080">scala</a> <a href="/tags/software-programming/" style="font-size: 14px; color: #808080">software programming</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/bondaddy" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
</body>
</html>
