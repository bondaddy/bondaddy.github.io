<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Scala实用指南读书笔记（三） | heros come back</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="heros come back">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="第三部分 Scala 中的并发编程 并发编程是意外的复杂性之一。 Scala提供了一些优雅的解决方案。读者将了解:  惰性求值有哪些优势 严格集合和惰性集合之间有哪些差异 如何使用并行集合 如何避免共享的可变性 如何使用 Actor 进行并发编程  惰性求值和并行集合人类大约需要 250 ms 来感知任何的移动，超过 5 s 的延迟就变得不可接受了。 释放惰性12val perform &#x3D; exp">
<meta property="og:type" content="article">
<meta property="og:title" content="Scala实用指南读书笔记（三）">
<meta property="og:url" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;14&#x2F;----84&#x2F;index.html">
<meta property="og:site_name" content="heros come back">
<meta property="og:description" content="第三部分 Scala 中的并发编程 并发编程是意外的复杂性之一。 Scala提供了一些优雅的解决方案。读者将了解:  惰性求值有哪些优势 严格集合和惰性集合之间有哪些差异 如何使用并行集合 如何避免共享的可变性 如何使用 Actor 进行并发编程  惰性求值和并行集合人类大约需要 250 ms 来感知任何的移动，超过 5 s 的延迟就变得不可接受了。 释放惰性12val perform &#x3D; exp">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;14&#x2F;----84&#x2F;15789868324156.jpg">
<meta property="article:published_time" content="2020-01-14T07:53:48.000Z">
<meta property="article:modified_time" content="2020-01-14T07:37:52.020Z">
<meta property="article:author" content="bon爸">
<meta property="article:tag" content="software programming">
<meta property="article:tag" content="scala">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;2020&#x2F;01&#x2F;14&#x2F;----84&#x2F;15789868324156.jpg">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
<meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="heros come back" type="application/atom+xml">
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				heros come back
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        <article id="post-----84"
  class="post white-box article-type-post"
  itemscope itemprop="blogPost">
	<section class='meta'>
	<h2 class="title">
  	<a href="/2020/01/14/----84/">
    	Scala实用指南读书笔记（三）
    </a>
  </h2>
	<time>
	  1月 14, 2020
	</time>
	
    
    <div class='cats'>
        <a href="/categories/professional-skill/">professional skill</a>
    </div>

	</section>
	
		<section class="toc-wrapper"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#惰性求值和并行集合"><span class="toc-number">1.</span> <span class="toc-text">惰性求值和并行集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#释放惰性"><span class="toc-number">1.1.</span> <span class="toc-text">释放惰性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#释放严格集合的惰性"><span class="toc-number">1.2.</span> <span class="toc-text">释放严格集合的惰性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终极惰性流"><span class="toc-number">1.3.</span> <span class="toc-text">终极惰性流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#将无限流转换为有限流"><span class="toc-number">1.3.1.</span> <span class="toc-text">将无限流转换为有限流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并行集合"><span class="toc-number">1.4.</span> <span class="toc-text">并行集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从顺序集合入手"><span class="toc-number">1.4.1.</span> <span class="toc-text">从顺序集合入手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用并行集合加速"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用并行集合加速</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#使用-Actor-编程"><span class="toc-number">2.</span> <span class="toc-text">使用 Actor 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一个顺序耗时问题"><span class="toc-number">2.1.</span> <span class="toc-text">一个顺序耗时问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#曲折的并发之路"><span class="toc-number">2.2.</span> <span class="toc-text">曲折的并发之路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建-Actor"><span class="toc-number">2.3.</span> <span class="toc-text">创建 Actor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Actor-和线程"><span class="toc-number">2.4.</span> <span class="toc-text">Actor 和线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用-Actor-模型进行并发"><span class="toc-number">2.5.</span> <span class="toc-text">使用 Actor 模型进行并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建无状态的-FileExplorer-Actor"><span class="toc-number">2.5.1.</span> <span class="toc-text">创建无状态的 FileExplorer Actor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有状态的-FilesCounter-Actor"><span class="toc-number">2.5.2.</span> <span class="toc-text">有状态的 FilesCounter Actor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建-ActorSystem-以及一个-FilesCounter-实例"><span class="toc-number">2.5.3.</span> <span class="toc-text">创建 ActorSystem 以及一个 FilesCounter 实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用建议"><span class="toc-number">2.6.</span> <span class="toc-text">使用建议</span></a></li></ol></li></ol></section>
	
	<section class="article typo">
  	<div class="article-entry" itemprop="articleBody">
    	<p>第三部分 Scala 中的并发编程</p>
<p>并发编程是意外的复杂性之一。 Scala提供了一些优雅的解决方案。读者将了解:</p>
<ul>
<li>惰性求值有哪些优势</li>
<li>严格集合和惰性集合之间有哪些差异</li>
<li>如何使用并行集合</li>
<li>如何避免共享的可变性</li>
<li>如何使用 Actor 进行并发编程</li>
</ul>
<h1 id="惰性求值和并行集合"><a href="#惰性求值和并行集合" class="headerlink" title="惰性求值和并行集合"></a>惰性求值和并行集合</h1><p>人类大约需要 250 ms 来感知任何的移动，超过 5 s 的延迟就变得不可接受了。</p>
<h2 id="释放惰性"><a href="#释放惰性" class="headerlink" title="释放惰性"></a>释放惰性</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> perform = expensiveComputation() </span><br><span class="line"><span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; perform)</span><br></pre></td></tr></table></figure>
<p>我们先调用了 expensiveComputation()方法，并将其结果存储在一个名为perform 的不可变变量中，然后在条件表达式中使用了该值。当我们运行这个修改后的版本时，不管 是否需要或者用到 perform 变量的值，该程序都会积极地对该方法进行求值，正如我们从 输出结果所看到的— 这太糟糕了。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lazy</span> <span class="keyword">val</span> perform = expensiveComputation() </span><br><span class="line"><span class="keyword">if</span> (input &gt;= <span class="number">10</span> &amp;&amp; perform)</span><br><span class="line">    println(<span class="string">"doing work..."</span>)</span><br></pre></td></tr></table></figure>

<p>可以将任何变量标记为 lazy2，这样对该变量值的绑定将会被推迟到它首次被使用时。</p>
<h2 id="释放严格集合的惰性"><a href="#释放严格集合的惰性" class="headerlink" title="释放严格集合的惰性"></a>释放严格集合的惰性</h2><p>你可以使用(严格集合上的)view()方法来获取一个严格集合的惰性视图。严格集合 在操作被调用时将会立即求值，而惰性集合则会推迟相应的操作。当且仅当请求了非惰性或者非视图的结果时，操作才会被执行。换句话说，在请求严格的或者非惰性的结果之前，它 将保持惰性，并且避免(进行实际的)计算。在前一个例子中的严格集合上调用第一个 filter()操作之前，让我们先将它转换为惰性集合。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> people = <span class="type">List</span>((<span class="string">"Mark"</span>, <span class="number">32</span>), (<span class="string">"Bob"</span>, <span class="number">22</span>), (<span class="string">"Jane"</span>, <span class="number">8</span>), (<span class="string">"Jill"</span>, <span class="number">21</span>),</span><br><span class="line">  (<span class="string">"Nick"</span>, <span class="number">50</span>), (<span class="string">"Nancy"</span>, <span class="number">42</span>), (<span class="string">"Mike"</span>, <span class="number">19</span>), (<span class="string">"Sara"</span>, <span class="number">12</span>), (<span class="string">"Paula"</span>, <span class="number">42</span>), (<span class="string">"John"</span>, <span class="number">21</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isOlderThan17</span></span>(person: (<span class="type">String</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">  println(<span class="string">s"isOlderThan17 called for <span class="subst">$person</span>"</span>)</span><br><span class="line">  <span class="keyword">val</span> (_, age) = person</span><br><span class="line">  age &gt; <span class="number">17</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isNameStartsWithJ</span></span>(person: (<span class="type">String</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">  println(<span class="string">s"isNameStartsWithJ called for <span class="subst">$person</span>"</span>)</span><br><span class="line">  <span class="keyword">val</span> (name, _) = person</span><br><span class="line">  name.startsWith(<span class="string">"J"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">  println(people.view.filter &#123;</span><br><span class="line">    isOlderThan17</span><br><span class="line">  &#125;.filter &#123;</span><br><span class="line">    isNameStartsWithJ</span><br><span class="line">  &#125;.head)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="终极惰性流"><a href="#终极惰性流" class="headerlink" title="终极惰性流"></a>终极惰性流</h2><p>通过调用严格集合上的 view()方法，派生其惰性视图并不会改变该集合;但是它有助于 将执行操作推迟到最后的可能时刻。也就是说，使用惰性视图，其对应的值可能都已经全部存 在了1，你只是不迫切或者不急切想处理它们。Stream 具有天然的惰性— 仅按需产生值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate</span></span>(starting: <span class="type">Int</span>): <span class="type">Stream</span>[<span class="type">Int</span>] = &#123; </span><br><span class="line">    starting #:: generate(starting + <span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line">println(generate(<span class="number">25</span>))</span><br></pre></td></tr></table></figure>

<p>generate()函数接受一个整数 starting 作为它的参数，并返回一个 Stream[Int]。 它的实现使用了一个特殊的函数#::来将 starting 变量的值和递归调用 generate()函数 的值连接起来。在概念上，Stream 的#::函数很像 List 的::函数;它们都将连接或者将一个值前拼接到各自对应的集合或者流上。然而，Stream 上的#::函数是惰性的，它只会<br>在需要的时候进行连接，并在最终结果被请求之前推迟执行。</p>
<p>调用的结果：<code>Stream(25, ?)</code><br>我们有一个初始值为 25 的流，后面跟着一个尚未计算的值。这看起来像是该流提出了一项挑战:“如果你想要知道下一个值，来，主动获取它。”如果你不在该流上进行任何的调用，那么它将不会进行任何实际的工作，也不会为元素占用任何的空间。</p>
<h3 id="将无限流转换为有限流"><a href="#将无限流转换为有限流" class="headerlink" title="将无限流转换为有限流"></a>将无限流转换为有限流</h3><p>force()方法和 toList()方法的用例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(generate(<span class="number">25</span>).take(<span class="number">10</span>).force) </span><br><span class="line">println(generate(<span class="number">25</span>).take(<span class="number">10</span>).toList)</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Stream</span>(<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">25</span>, <span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span>, <span class="number">29</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>)</span><br></pre></td></tr></table></figure>

<p>takeWhile()代替了 take()方法，其接受一个函数值作为参数。只要该函 数值中的表达式一直返回 true：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(generate(<span class="number">25</span>).takeWhile &#123; _ &lt; <span class="number">40</span> &#125;.force)</span><br></pre></td></tr></table></figure>
<h2 id="并行集合"><a href="#并行集合" class="headerlink" title="并行集合"></a>并行集合</h2><p>对象或者元素的数量很大，并且/或者处理它们的时间很长，那么产生结果的总体响 应时间可能会非常长。并行地在多个线程上运行这些任务，并利用多核 CPU，则可以极大地提高速度。 但是，使用低级别的线程构造和锁将导致额外的复杂性，并导致并发相关的错误，让程序员的生活一团糟。幸运的是，在 Scala 中你不必受这个罪，因为在数据的集合上 进行并行操作非常简单。</p>
<h3 id="从顺序集合入手"><a href="#从顺序集合入手" class="headerlink" title="从顺序集合入手"></a>从顺序集合入手</h3><p>城市按照城市名的顺序列出，与其一起列出的还有温度信息以及请求时的天气状况。代 码运行了大约 2 s，你观察到的执行时间将取决于你的网络速度以及拥塞情况。接下来，我们 将看到如何通过最小的改变从而更快地获取到结果。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pro.simba.service.<span class="type">Weather</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> scala.io.<span class="type">Source</span></span><br><span class="line"><span class="keyword">import</span> scala.xml.<span class="type">XML</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getWeatherData</span></span>(city: <span class="type">String</span>) = &#123;</span><br><span class="line">    <span class="keyword">val</span> response = <span class="type">Source</span>.fromURL(</span><br><span class="line">      <span class="string">s"https://raw.githubusercontent.com/ReactivePlatform/"</span> +</span><br><span class="line">        <span class="string">s"Pragmatic-Scala-StaticResources/master/src/main/resources/"</span> +</span><br><span class="line">        <span class="string">s"weathers/<span class="subst">$city</span>.xml"</span>)</span><br><span class="line">    <span class="keyword">val</span> xmlResponse = <span class="type">XML</span>.loadString(response.mkString)</span><br><span class="line">    <span class="keyword">val</span> cityName = (xmlResponse \\ <span class="string">"city"</span> \ <span class="string">"@name"</span>).text</span><br><span class="line">    <span class="keyword">val</span> temperature = (xmlResponse \\ <span class="string">"temperature"</span> \ <span class="string">"@value"</span>).text</span><br><span class="line">    <span class="keyword">val</span> condition = (xmlResponse \\ <span class="string">"weather"</span> \ <span class="string">"@value"</span>).text</span><br><span class="line">    (cityName, temperature, condition)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printWeatherData</span></span>(weatherData: (<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>)): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> (cityName, temperature, condition) = weatherData</span><br><span class="line">    println(<span class="string">f"<span class="subst">$cityName</span>%-15s <span class="subst">$temperature</span>%-6s <span class="subst">$condition</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">timeSample</span></span>(getData: <span class="type">List</span>[<span class="type">String</span>] =&gt; <span class="type">List</span>[(<span class="type">String</span>, <span class="type">String</span>, <span class="type">String</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> cities = <span class="type">List</span>(<span class="string">"Houston,us"</span>, <span class="string">"Chicago,us"</span>, <span class="string">"Boston,us"</span>, <span class="string">"Minneapolis,us"</span>,</span><br><span class="line">      <span class="string">"Oslo,norway"</span>, <span class="string">"Tromso,norway"</span>, <span class="string">"Sydney,australia"</span>, <span class="string">"Berlin,germany"</span>,</span><br><span class="line">      <span class="string">"London,uk"</span>, <span class="string">"Krakow,poland"</span>, <span class="string">"Rome,italy"</span>, <span class="string">"Stockholm,sweden"</span>, <span class="string">"Bangalore,india"</span>,</span><br><span class="line">      <span class="string">"Brussels,belgium"</span>, <span class="string">"Reykjavik,iceland"</span>)</span><br><span class="line">    <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line">    getData(cities) sortBy &#123;</span><br><span class="line">      _._1</span><br><span class="line">    &#125; foreach printWeatherData</span><br><span class="line">    <span class="keyword">val</span> end = <span class="type">System</span>.nanoTime</span><br><span class="line">    println(<span class="string">s"Time taken: <span class="subst">$&#123;(end - start) / 1.0e9&#125;</span> sec"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Weather</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> weather = <span class="keyword">new</span> <span class="type">Weather</span></span><br><span class="line">    weather.timeSample &#123; cities =&gt; cities map weather.getWeatherData &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用并行集合加速"><a href="#使用并行集合加速" class="headerlink" title="使用并行集合加速"></a>使用并行集合加速</h3><p>前面的例子有两个部分:慢的部分— 对于每个城市，我们都通过网络获取并收集天气 信息，快的部分— 我们对数据进行排序，并显示它们。非常简单，因为慢的部分被封装到 了作为参数传递给 timeSample()函数的函数值中。因此，我们只需要更换那部分代码来提 高速度即可，而其余的部分则可以保持不变。</p>
<p>我们传递给 map()函数的操作可以并行地执行， 因为获取一个城市的数据与获取另外一个城市的数据相互独立。值得庆幸的是，让 map() 方法为每个城市并行地执行操作并不需要太多工作。我们只需要将该集合转换为并行版本 就可以了。</p>
<p>对于许多顺序集合，Scala 都拥有其并行版本。1例如，ParArray 是 Array 对应的并 行版本，同样的，ParHashMap、ParHashSet 和 ParVector 分别对应于 HashMap、 HashSet 和 Vector。我们可以使用 par()和 seq()方法来在顺序集合及其并行版本之间 进行相互转换。</p>
<p>让我们使用 par()方法将城市列表转换为其并行版本。现在，map()方法将并行地执行 它的操作。在完成之后，我们将使用 toList()方法来将所生成的并行集合转换为顺序集合， 即(作为参数传入的)函数值的结果类型。下面我们使用并行集合而不是顺序集合，来重写 对 timeSample()方法的调用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timeSample &#123; cities =&gt; (cities.par map getWeatherData).toList &#125;</span><br></pre></td></tr></table></figure>

<h1 id="使用-Actor-编程"><a href="#使用-Actor-编程" class="headerlink" title="使用 Actor 编程"></a>使用 Actor 编程</h1><p>在编写复杂、耗时的应用程序时，我们经常会使用多线程以及并发来降低响应时间或者 提高性能。可惜，传统的并发解决方案导致了一些问题，如线程安全、竞态条件、死锁、活 锁以及不容易理解的、容易出错的代码。<strong>共享的可变性是罪魁祸首</strong>。</p>
<h2 id="一个顺序耗时问题"><a href="#一个顺序耗时问题" class="headerlink" title="一个顺序耗时问题"></a>一个顺序耗时问题</h2><p>顺序调用下，查询目录以及目录下面所有的文件：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pro.simba.service</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.<span class="type">File</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CountFilesSequential</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getChildren</span></span>(file: <span class="type">File</span>) = &#123;</span><br><span class="line">      <span class="keyword">val</span> children = file.listFiles()</span><br><span class="line">      <span class="keyword">if</span> (children != <span class="literal">null</span>) children.toList <span class="keyword">else</span> <span class="type">List</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line">    <span class="keyword">val</span> exploreFrom = <span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/Users/songchen"</span>)</span><br><span class="line">    <span class="keyword">var</span> count = <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">var</span> filesToVisit = <span class="type">List</span>(exploreFrom)</span><br><span class="line">    <span class="keyword">while</span> (filesToVisit.nonEmpty) &#123;</span><br><span class="line">      <span class="keyword">val</span> head = filesToVisit.head</span><br><span class="line">      filesToVisit = filesToVisit.tail</span><br><span class="line">      <span class="keyword">val</span> children = getChildren(head)</span><br><span class="line">      count = count + children.count &#123;</span><br><span class="line">        !_.isDirectory</span><br><span class="line">      &#125;</span><br><span class="line">      filesToVisit = filesToVisit ::: children.filter &#123;</span><br><span class="line">        _.isDirectory</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> end = <span class="type">System</span>.nanoTime</span><br><span class="line">    println(<span class="string">s"Number of files found: <span class="subst">$count</span>"</span>)</span><br><span class="line">    println(<span class="string">s"Time taken: <span class="subst">$&#123;(end - start) / 1.0e9&#125;</span> seconds"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="曲折的并发之路"><a href="#曲折的并发之路" class="headerlink" title="曲折的并发之路"></a>曲折的并发之路</h2><p>启动多个线程并不是真正的困难之处，只是比较笨拙而已— 你 将会使用 Executors 来创建一个线程池。你可以将探索不同子文件夹的任务调度给线程池 中的不同线程。但是，问题的根源在于那两个变量— 共享的可变变量。当多个线程访问各 个子目录时，我们不得不更新 count 和 filesToVisit 这两个变量。让我们看一下这为何 会是一个问题。</p>
<ul>
<li>为了保护 count 变量不受并发更改的影响，我们可能使用 AtomicLong。这是有问 题的，因为我们必须要保证对该变量的所有更改发生在该程序看到没有更多的文件需 要访问并报告文件总数之前。换句话说，虽然原子性保证了单个值的线程安全性，但 是其并不能保证跨多个值的原子性，因为这些值可能会同时发生变化。</li>
<li>我们可能不得不使用一个线程安全的集合— 同步列表或者并发列表，用来实现 filesToVisit 列表。这也只能保护一个变量的原子性，但是并不能解决跨两个变 量的原子性问题。</li>
<li>我们可以将这两个变量封装到同一个类中，并提供 synchronized 方法来一次性 地更新这两个值。这将确保对这两个变量的更改是原子的。然而，现在我们不得 不确保这个同步操作实际发生在正确的位置、正确的时间上。如果我们忘记了同 步，或者在错误的位置上进行了同步，那么 Java 编译器和运行时都不会给我们任 何的警告。</li>
</ul>
<h2 id="创建-Actor"><a href="#创建-Actor" class="headerlink" title="创建 Actor"></a>创建 Actor</h2><p>Actor 也是一个对象，但是你从来都不 会直接调用它的方法，而是通过发送消息，并且每个 Actor 都由一个消息队列支撑。如果一 个 Actor 正忙于处理消息，那么到达的消息将会被插入消息队列中，而不会阻塞消息的发送 者;它们发送并忘记(fire-and-forget)。在任意给定的时间，一个 Actor 将只会处理一条消息。 Actor 模型具有与生俱来的线程安全性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HollywoodActor</span>(<span class="params"></span>) <span class="keyword">extends</span> <span class="title">AbstractActor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> message =&gt; println(<span class="string">s"playing the role of <span class="subst">$message</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CreateActors</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"sample"</span>)</span><br><span class="line">  <span class="keyword">val</span> depp = system.actorOf(<span class="type">Props</span>[<span class="type">HollywoodActor</span>])</span><br><span class="line">  depp !<span class="string">"Wonka"</span></span><br><span class="line">  <span class="keyword">val</span> terminateFuture = system.terminate()</span><br><span class="line">  <span class="type">Await</span>.ready(terminateFuture, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Akka 的 Actor 托管在一个 ActorSystem 中，它管理了线程、消息队列以及 Actor 的生命 周期。相对于使用传统的 new 关键字来创建实例，我们使用了一种特殊的 actorOf 工厂方法 来创建 Actor，并将其对应的 ActorRef 赋值给了名为 depp 的引用。此外，我们也没有使用 传统的方法调用语法，而是发送了一个“Wonka”消息给 Actor— 在这个例子中只传递了一 个字符串— 我们使用了名为!的方法，你可以使用一个名为tell()的方法1，而不是使用!() 方法，但是那样就需要传递一个额外的 sender 参数。同时，如果你使用的方法名对阅读者来 说是直观的，那么你的代码也就太简单了。说到直觉，它们真应该被称为 action()。</p>
<p>我们给每个Actor都发送了两条消息:给Actor depp发送了“Wanka”和“Sparrow”， 给Actor hanks发送了“Gump”和“Phillips”。这个输出结果展示了许多有趣的细节。<br>Wonka - Thread[sample-akka.actor.default-dispatcher-2,5,main]<br>Gump - Thread[sample-akka.actor.default-dispatcher-3,5,main]<br>Calling from Thread[main,5,main]<br>Phillips - Thread[sample-akka.actor.default-dispatcher-3,5,main]<br>Sparrow - Thread[sample-akka.actor.default-dispatcher-2,5,main]</p>
<p>可以发现以下事实：</p>
<ul>
<li>一个可用的线程池，不必大惊小怪。</li>
<li>Actor 在不同的线程中运行，而不是调用代码的主线程。</li>
<li>每个 Actor 一次只处理一条消息。</li>
<li>多个 Actor 并发地运行，同时处理多条消息。</li>
<li>Actor 是异步的。</li>
<li>不会阻塞调用者— main 方法(直接)运行了 println()方法，根本不会等待这些 Actor 的回复。</li>
</ul>
<h2 id="Actor-和线程"><a href="#Actor-和线程" class="headerlink" title="Actor 和线程"></a>Actor 和线程</h2><p>在前面的 输出结果中我们看到，发送给 depp 的两条消息都是由同一个线程处理的，而发送给 hanks的两条消息则都是由另一个线程处理的。这可能会给人们留下一个印象:Actor 将会持有它 们自己的线程，但是这不是真的— 事实上，在你的计算机上，你甚至可能会观察到 Actor 切换线程的情况。</p>
<p>线程之于 Actor 类似于客服经理之于消费者。当你拨打客户服务热线时，任何有空的客 服经理都会接听你的热线。如果你挂掉之前的电话并重新拨通热线，此时上一位客服经理已 经在处理别的客服电话了，那么另一位完全随机的客服经理现在将会回答你的疑问。只有在 极端巧合下(在这两次热线电话的过程中)，你才可能和同一位客户经理谈话。</p>
<h2 id="使用-Actor-模型进行并发"><a href="#使用-Actor-模型进行并发" class="headerlink" title="使用 Actor 模型进行并发"></a>使用 Actor 模型进行并发</h2><p><img src="/2020/01/14/----84/15789868324156.jpg" alt="-w389"><br>对于一个给定目录下的多个子目录，查找子目录可以并发进行。因为在任何给定时刻， 对于一个 Actor，我们只能得到一个计算单元。因为我们需要同时执行并发任务，所以我们 将需要多个 Actor。在我们的设计中，FileExplorer 是一个无状态的 Actor— 我们将使用 由 Akka 提供的称为 RoundRobinPool 的路由器，它由这个类的几个实例支撑。顾名思义， 发送到这个路由器的消息将会被均匀地路由到支撑这个路由器的多个 Actor。我们还会使用 另一个 Actor，其只是一个 FilesCounter 的实例。这个 Actor 将是有状态的，这里便是被 隔离的可变状态所存在的地方，并会记录文件的个数。</p>
<h3 id="创建无状态的-FileExplorer-Actor"><a href="#创建无状态的-FileExplorer-Actor" class="headerlink" title="创建无状态的 FileExplorer Actor"></a>创建无状态的 FileExplorer Actor</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor._</span><br><span class="line"><span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileExplorer</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> dirName: <span class="type">String</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> file = <span class="keyword">new</span> <span class="type">File</span>(dirName)</span><br><span class="line">      <span class="keyword">val</span> children = file.listFiles()</span><br><span class="line">      <span class="keyword">var</span> filesCount = <span class="number">0</span></span><br><span class="line">      <span class="keyword">if</span> (children != <span class="literal">null</span>) &#123;</span><br><span class="line">        children.filter &#123;</span><br><span class="line">          _.isDirectory</span><br><span class="line">        &#125;</span><br><span class="line">          .foreach &#123;</span><br><span class="line">            sender ! _.getAbsolutePath</span><br><span class="line">          &#125; filesCount = children.count &#123;</span><br><span class="line">          !_.isDirectory</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      sender ! filesCount</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 receive()方法中，我们只查找包含该目录名的字符串。当接收到消息之后，我们 将在给定的目录下查找文件和子目录。我们简单地将每个子目录发送给该消息的发送者(一 个监管 Actor)，这样它便可以让其他 FileExplorer 着手遍历该子目录。之后，我们还将 在这个目录下查找到的文件数发送给该发送者。</p>
<h3 id="有状态的-FilesCounter-Actor"><a href="#有状态的-FilesCounter-Actor" class="headerlink" title="有状态的 FilesCounter Actor"></a>有状态的 FilesCounter Actor</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor._</span><br><span class="line"><span class="keyword">import</span> akka.routing._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesCounter</span> <span class="keyword">extends</span> <span class="title">Actor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> start: <span class="type">Long</span> = <span class="type">System</span>.nanoTime</span><br><span class="line">  <span class="keyword">var</span> filesCount = <span class="number">0</span>L</span><br><span class="line">  <span class="keyword">var</span> pending = <span class="number">0</span></span><br><span class="line">  <span class="keyword">val</span> fileExplorers: <span class="type">ActorRef</span> = context.actorOf(<span class="type">RoundRobinPool</span>(<span class="number">100</span>).props(<span class="type">Props</span>[<span class="type">FileExplorer</span>]))</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">Receive</span> = &#123;</span><br><span class="line">    <span class="keyword">case</span> dirName: <span class="type">String</span> =&gt; pending = pending + <span class="number">1</span></span><br><span class="line">      fileExplorers ! dirName</span><br><span class="line">    <span class="keyword">case</span> count: <span class="type">Int</span> =&gt;</span><br><span class="line">      filesCount = filesCount + count pending = pending - <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (pending == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> end = <span class="type">System</span>.nanoTime</span><br><span class="line">        println(<span class="string">s"Files count: <span class="subst">$filesCount</span>"</span>)</span><br><span class="line">        println(<span class="string">s"Time taken: <span class="subst">$&#123;(end - start) / 1.0e9&#125;</span> seconds"</span>)</span><br><span class="line">        context.system.terminate()</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="创建-ActorSystem-以及一个-FilesCounter-实例"><a href="#创建-ActorSystem-以及一个-FilesCounter-实例" class="headerlink" title="创建 ActorSystem 以及一个 FilesCounter 实例"></a>创建 ActorSystem 以及一个 FilesCounter 实例</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> akka.actor._</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CountFiles</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> system = <span class="type">ActorSystem</span>(<span class="string">"sample"</span>)</span><br><span class="line">  <span class="keyword">val</span> filesCounter = system.actorOf(<span class="type">Props</span>[<span class="type">FilesCounter</span>])</span><br><span class="line">  filesCounter ! args(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>我们学会了创建 Actor，给它们发送消息，以及如何协调多个 Actor 实例。我们使用了一 个无状态的 Actor 以及一个有状态的 Actor，并同时使用了单向通信和双向通信。这些灵活的 特性可能有点儿难以置信。让我们来探讨一些与最佳实践相关的建议。</p>
<ul>
<li>更多地依赖无状态的而不是有状态的 Actor。无状态的 Actor 没有特殊性，它们可以 提供更多的并发性，易于复制，并且很容易重启和复用。状态可能是不可避免的，但 是要尽可能少使用有状态的 Actor。</li>
<li>要保证 receive()方法中的处理速度非常快，尤其是接收 Actor 具有状态的时候。 改变状态的长时间运行任务将会降低并发性，要避免这样做。如果不修改状态的任务 不是非常快速也不是什么问题，因为我们可以很容易地通过复制这些 Actor 来改进并 发性，如同我们在 FileExplorer 中所做的那样。</li>
<li>确保在 Actor 之间传递的消息是不可变的对象。在所有的示例中，我们传递的都是 case 类的实例、String 或者 Int，所有的这些都是不可变的。传递不可变对象将保证我们不会在无意间修改共享状态，并最终导致并发问题。</li>
<li>尽量避免使用 ask()。双向通信通常都不是一个好主意。“发送并忘记”模型要好得多，而且也更加不容易出错。</li>
</ul>

  	</div>
	  
	  <div class="article-tags tags">
      
        <a href="/tags/software-programming/">software programming</a>
      
        <a href="/tags/scala/">scala</a>
      
	  </div>
    
		
	
		<div class="art-item-footer">
				
				
					<span class="art-item-right">next：<a href="/2020/01/12/----83/" rel="next"  title="鬼岛观测的完结">
						鬼岛观测的完结
					</a><i class="icon icon-chevron-thin-right"></i></span>
				
		</div>
	
	</section>
	
</article>
<script>
	window.subData = {
		title: 'Scala实用指南读书笔记（三）',
		tools: true
	}
</script>

      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>bon爸</div>
<div class='content'>
<div class='desc'>成为世界的基石 ...</div>
</div>
</section>


  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/bondaddy">
            <div class='name'>github</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/blog/"><div class='name'>blog</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/professional-skill/"><div class='name'>professional skill</div><div class='badget'>3</div></a></li>
    
        <li><a class="flat-box" href="/categories/qzone/"><div class='name'>qzone</div><div class='badget'>79</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/mood/" style="font-size: 14px; color: #808080">mood</a> <a href="/tags/qzone/" style="font-size: 20px; color: #000">qzone</a> <a href="/tags/scala/" style="font-size: 14px; color: #808080">scala</a> <a href="/tags/software-programming/" style="font-size: 14px; color: #808080">software programming</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/bondaddy" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
</body>
</html>
