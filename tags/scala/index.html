<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>Tag: scala | heros come back</title>
  <meta name="description" content="" />
  <meta name="keywords" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="shortcut icon" href="/">
  <link rel="alternate" href="/atom.xml" title="heros come back">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="heros come back">
<meta property="og:url" content="http:&#x2F;&#x2F;bondaddy.github.io&#x2F;tags&#x2F;scala&#x2F;index.html">
<meta property="og:site_name" content="heros come back">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="bon爸">
<meta name="twitter:card" content="summary">
    
  <link href="https://fonts.googleapis.com/css?family=Inconsolata|Titillium+Web" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">
  <link href='//cdn.bootcss.com/node-waves/0.7.5/waves.min.css' rel='stylesheet'>
  
<link rel="stylesheet" href="/style.css">

  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
<meta name="generator" content="Hexo 4.1.1"><link rel="alternate" href="/atom.xml" title="heros come back" type="application/atom+xml">
</head>

<body>
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>


  <script>setLoadingBarProgress(20)</script> 
  <header class="l_header">
	<div class='wrapper'>
		<div class="nav-main container container--flex">
			<a class="logo flat-box" href='/' >
				heros come back
			</a>
			<div class='menu'>
				<ul class='h-list'>
					
						<li>
							<a class='flat-box nav-home' href='/'>
								Home
							</a>
						</li>
					
						<li>
							<a class='flat-box nav-archives' href='/archives'>
								Archives
							</a>
						</li>
					
				</ul>
				<div class='underline'></div>
			</div>
			
			<ul class='switcher h-list'>
				
				<li class='s-menu'><a href='javascript:void(0)'><span class="icon icon-menu flat-box"></span></a></li>
			</ul>
		</div>
		
		<div class='nav-sub container container--flex'>
			<a class="logo" class="flat-box" href='javascript:void(0)'>
				Word of Forks
			</a>

			<ul class='switcher h-list'>
				<li class='s-comment'><a href='javascript:void(0)'><span class="icon icon-chat_bubble_outline flat-box"></span></a></li>
				<li class='s-top'><a href='javascript:void(0)'><span class="icon icon-arrow_upward flat-box"></span></a></li>
				<li class='s-toc'><a href='javascript:void(0)'><span class="icon icon-format_list_numbered flat-box"></span></a></li>
			</ul>
		</div>
	</div>
</header>
<aside class="menu-phone">
	<nav>
		
			<a href="/" class="nav-home nav">
				Home
			</a>
		
			<a href="/archives" class="nav-archives nav">
				Archives
			</a>
		
	</nav>
</aside>

    <script>setLoadingBarProgress(40);</script>
  <div class="l_body">
    <div class='container clearfix'>
      <div class='l_main'>
        
  <script>
    window.subData= { title:'Tag : scala'}
  </script>

<section class="post-list">
	
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2020/01/07/----82/">
        Scala实用指南读书笔记（二）
      </a>
    </h2>
    
    <time>
      1月 7, 2020
    </time>
		
    
    <div class='cats'>
        <a href="/categories/professional-skill/">professional skill</a>
    </div>

  </section>
  <section class="article typo">
	  <p>第二部分 深入 Scala</p>
<p>是时候深入学习 Scala 了。读者将了解:</p>
<ul>
<li>如何创建和使用函数值</li>
<li>如何使用特质进行编程</li>
<li>如何使用不同类型的集合</li>
<li>如何使用模式匹配的能力</li>
<li>如何进行尾调用优化</li>
</ul>
<h1 id="函数值和闭包"><a href="#函数值和闭包" class="headerlink" title="函数值和闭包"></a>函数值和闭包</h1><p>函数可以作为参数值传入其他函数中，函数的返回值可 以是函数，函数甚至可以嵌套函数。这些高阶函数在 Scala 中被称为函数值(function value)。闭 包(closure)是函数值的特殊形式，会捕获或者绑定到在另一个作用域或上下文中定义的变量。</p>
<h2 id="常规函数的局限性"><a href="#常规函数的局限性" class="headerlink" title="常规函数的局限性"></a>常规函数的局限性</h2><p>要算出从 1 到给定整数 number 区间内所有整数的总和，我们可能会编写代码如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span></span>(number: <span class="type">Int</span>) = &#123; </span><br><span class="line">    <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to number) &#123;</span><br><span class="line">    result += i </span><br><span class="line">    &#125;</span><br><span class="line">    result </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码完成了工作，但它不可扩展。现在，如果额外需要计算给定区间内偶数的个数和 奇数的个数，使用这段代码就会碰壁。</p>
<h2 id="可扩展性与高阶函数"><a href="#可扩展性与高阶函数" class="headerlink" title="可扩展性与高阶函数"></a>可扩展性与高阶函数</h2><p><strong>将其他函数作为参数的函数称为高阶函数</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">totalResultOverRange</span></span>(number: <span class="type">Int</span>, codeBlock: <span class="type">Int</span> =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to number) &#123;</span><br><span class="line">    result += codeBlock(i)</span><br><span class="line">  &#125;</span><br><span class="line">  result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们将两个参数传递给该方法:第一个参数是所遍历的区间上限(11);第二个参数实际 上是一个匿名的即时函数(just-in-time function)，即一个没有名称只有参数和实现的函数。 在这个例子中，实现只是返回了给定的参数。在这个例子中，符号=&gt;的左边是参数列表，右 边是实现。Scala 能够从 totalResultOverRange()方法的参数列表中推断出参数 i 是 Int 类型的。如果参数的类型或结果类型与预期的不匹配，Scala 会给出一个错误。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(totalResultOverRange(<span class="number">11</span>, i =&gt; i))</span><br></pre></td></tr></table></figure>

<p>对于一个简单的数值求和过程，与调用之前写的普通函数 sum()相比，调用 total ResultOverRange()方法需要一个数和一个函数作为参数就显得太笨重了。然而，新版本 是可扩展的，我们可以用类似的方式调用它来完成其他操作。例如，如果我们想要对区间内 的偶数求和而不是求总和，就可以像下面这样调用这个函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(totalResultOverRange(<span class="number">11</span>, i =&gt; <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) i <span class="keyword">else</span> <span class="number">0</span>))</span><br></pre></td></tr></table></figure>
<p>在这个例子中，如果输入是偶数，那么作为参数传入的函数值会返回输入本身;否则返 回 0。因此，函数 totalResulOverRange()将只会对给定区间内的所有偶数求和。<br>如果我们想要对奇数求和，就可以用如下方式调用这个函数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(totalResultOverRange(<span class="number">11</span>, i =&gt; <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) <span class="number">0</span> <span class="keyword">else</span> i))</span><br></pre></td></tr></table></figure>
<p>与 sum()函数不同，我们看到了如何扩展 totalResultOverRange()函数，从而在指定区间上使用不同的元素选取策略求和。</p>
<h2 id="具有多个参数的函数值"><a href="#具有多个参数的函数值" class="headerlink" title="具有多个参数的函数值"></a>具有多个参数的函数值</h2><p><strong>函数值其实可以接收零个或多个参数</strong><br>没有参数的函数值是怎样定义和使 用的例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printValue</span></span>(generator: () =&gt; <span class="type">Int</span>): <span class="type">Unit</span> = &#123; </span><br><span class="line">    println(<span class="string">s"Generated value is <span class="subst">$&#123;generator()&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line">printValue(() =&gt; <span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<p>传递多个参数:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], initial: <span class="type">Int</span>, operation: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>) = &#123;</span><br><span class="line">  <span class="keyword">var</span> carryOver = initial</span><br><span class="line">  arr.foreach(element =&gt; carryOver = operation(carryOver, element))</span><br><span class="line">  carryOver</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> sum = inject(array, <span class="number">1</span>, (carry, elem) =&gt; carry * elem)</span><br><span class="line">println(<span class="string">s"Sum of elements in array is <span class="subst">$sum</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> max = inject(array, <span class="type">Integer</span>.<span class="type">MIN_VALUE</span>, (carry, elem) =&gt; <span class="type">Math</span>.max(carry, elem))</span><br><span class="line">println(<span class="string">s"Max of elements in array is <span class="subst">$max</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>可以看到同样的一个方法，最终得出来的结论完全可以由传入的函数得出不同的结论而避免代码重复。<br>Scala 标准库已经内置了这种方法。即 foldLeft()方 法。下面是使用内置的 foldLeft()方法来获取数组中元素的总和和最大值的例子:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> array = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> sum = array.foldLeft(<span class="number">0</span>) &#123; (sum, elem) =&gt; sum + elem &#125;</span><br><span class="line"><span class="keyword">val</span> max = array.foldLeft(<span class="type">Integer</span>.<span class="type">MIN_VALUE</span>) &#123; (large, elem) =&gt;</span><br><span class="line">  <span class="type">Math</span>.max(large, elem)</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">s"Sum of elements in array is <span class="subst">$sum</span>"</span>) </span><br><span class="line">println (<span class="string">s"Max of elements in array is <span class="subst">$max</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>为了使代码更加简洁，Scala 选择了一些方法并为它们定义了一些简称和记号。 foldLeft()方法有一个等效的/:操作符。我们可以用 foldLeft()或等效的/:操作符执 行先前的操作。以冒号(:)结尾的方法在 Scala 中有特殊含义，8.5 节将介绍相关知识。让 我们快速浏览一下如何使用该等效操作符而不是 foldLeft():</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum = (<span class="number">0</span> /: array) ((sum, elem) =&gt; sum + elem)</span><br><span class="line"><span class="keyword">val</span> max = (<span class="type">Integer</span>.<span class="type">MIN_VALUE</span> /: array) &#123; (large, elem) =&gt; <span class="type">Math</span>.max(large, elem) &#125;</span><br></pre></td></tr></table></figure>

<h2 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h2><p>Scala 中的柯里化(currying)会把接收多个参数的函数转化为接收多个参数列表的函数。 如果你会用同样的一组参数多次调用一个函数，你就能用柯里化去除噪声并使代码更加有趣。</p>
<p>改善了传递函数值的语法：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inject</span></span>(arr: <span class="type">Array</span>[<span class="type">Int</span>], initial: <span class="type">Int</span>)(operation: (<span class="type">Int</span>, <span class="type">Int</span>) =&gt; <span class="type">Int</span>): <span class="type">Int</span> = &#123; </span><br><span class="line">    <span class="keyword">var</span> carryOver = initial</span><br><span class="line">    arr.foreach(element =&gt; carryOver = operation(carryOver, element))</span><br><span class="line">    carryOver</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个版本的 inject()方法的唯一区别在于参数列表变成了多个。第一个参数列表接收两个参数，第二个只接收一个函数值。现在我们就没有必要再在括号中以逗号分隔的参数传递函数值了。我们可以用更美观的 大括号来调用这个方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sum: <span class="type">Int</span> = inject(array, <span class="number">0</span>) &#123; (carryOver, elem) =&gt; carryOver + elem &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数的占位符"><a href="#参数的占位符" class="headerlink" title="参数的占位符"></a>参数的占位符</h2><p>函数中只使用一次的参数可以用_来代替</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> negativeNumberExists1 = arr.exists &#123; elem =&gt; elem &lt; <span class="number">0</span> &#125; </span><br><span class="line"><span class="keyword">val</span> negativeNumberExists2 = arr.exists &#123; _ &lt; <span class="number">0</span> &#125;</span><br></pre></td></tr></table></figure>

<h2 id="参数路由"><a href="#参数路由" class="headerlink" title="参数路由"></a>参数路由</h2><p>_不仅能表示单个参数，也能表示整个参数列表。因此我们可以将对 max()的调用改成 如下形式:<br><code>val largest = (Integer.MIN_VALUE /: arr) { Math.max _ }</code></p>
<p>我们甚至不需要_这种形式。我们可以进一步简 化前面的代码:<br><code>val largest = (Integer.MIN_VALUE /: arr) { Math.max }</code></p>
<h2 id="复用函数值"><a href="#复用函数值" class="headerlink" title="复用函数值"></a>复用函数值</h2><p>在这段代码中，我们想在两个 Equipment 实例中使用相同的计算代码。遗憾的是，这 段计算代码重复了。这段代码并不遵循 DRY 原则，如果想改变计算逻辑，我们就必须两个 一起改。如果计算逻辑只写一次，然后复用，就非常好。我们可以把这个函数值赋值给一个 val 变量，以便复用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">EquipmentUseDry</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> calculator = &#123; input: <span class="type">Int</span> =&gt; println(<span class="string">s"calc with <span class="subst">$input</span>"</span>); input &#125;</span><br><span class="line">  <span class="keyword">val</span> equipment1 = <span class="keyword">new</span> <span class="type">Equipment</span>(calculator) </span><br><span class="line">  <span class="keyword">val</span> equipment2 = <span class="keyword">new</span> <span class="type">Equipment</span>(calculator)</span><br><span class="line">  equipment1.simulate(<span class="number">4</span>)</span><br><span class="line">  equipment2.simulate(<span class="number">6</span>) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="部分应用函数"><a href="#部分应用函数" class="headerlink" title="部分应用函数"></a>部分应用函数</h2><p>date 和 message。我们想多次调用这个 方法，date 的值保持不变但 message 每次用不同的值。将 date 参数部分应用到 log() 方法中，就可以去除每次调用都要传递同样的 date 参数这类语法噪声。<br>在下面的代码样例中，我们首先把一个值绑定到了 date 参数上。我们使用_将第二个参 数标记为未绑定。其结果是一个部分应用函数，然后我们将它存储到 logWithDateBound 这个引用中。现在我们就可以只用未绑定的参数 message 调用这个新方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> date = <span class="keyword">new</span> <span class="type">Date</span>(<span class="number">1420095600000</span>L)</span><br><span class="line"><span class="keyword">val</span> logWithDateBound = log(date, _: <span class="type">String</span>) </span><br><span class="line">logWithDateBound(<span class="string">"message1"</span>) </span><br><span class="line">logWithDateBound(<span class="string">"message2"</span>) </span><br><span class="line">logWithDateBound(<span class="string">"message3"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>在前面的例子中，在函数值或者代码块中使用的变量和值都是已经绑定的。你明确地知道它们所绑定的(实体)，即本地变量或者参数。除此之外，你还可以创建带有未绑定变量的 代码块。这样的话，你就必须在调用函数之前，为这些变量做绑定。但它们也可以绑定到或 者捕获作用域和参数列表之外的变量。这也是这样的代码块被称之为闭包(closure)的原因。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loopThrough</span></span>(number: <span class="type">Int</span>)(closure: <span class="type">Int</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to number) &#123;</span><br><span class="line">    closure(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> addIt = &#123; value: <span class="type">Int</span> =&gt; result += value &#125;</span><br><span class="line">loopThrough(<span class="number">10</span>) &#123; elem =&gt; addIt(elem) &#125;</span><br><span class="line">println(<span class="string">s"Total of values from 1 to 10 is <span class="subst">$result</span>"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="Execute-Around-Method-模式"><a href="#Execute-Around-Method-模式" class="headerlink" title="Execute Around Method 模式"></a>Execute Around Method 模式</h2><p><del>传递函数的时候可以传递多个让我表示很惊讶，是否我有遗漏细节需要确认。这种模式可以同意的开启一个事务，到最终事务结束以后进行完成工作。可以用于流的操作或者事务的提交。</del><br>愚蠢的我，传进去的是函数，就是代码，当然愿意调用几次就调用几次的代码 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Resource</span> <span class="title">private</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  println(<span class="string">"Starting transaction..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">cleanUp</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"Ending transaction..."</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op1</span></span>(num: <span class="type">Int</span>): <span class="type">Unit</span> = println(<span class="string">s"Operation <span class="subst">$&#123;num + 1&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op2</span></span>(num: <span class="type">Int</span>): <span class="type">Unit</span> = println(<span class="string">s"Operation <span class="subst">$&#123;num + 2&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">op3</span></span>(num: <span class="type">Int</span>): <span class="type">Unit</span> = println(<span class="string">s"Operation <span class="subst">$&#123;num + 3&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Resource</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">use</span></span>(num: <span class="type">Int</span>)(codeBlock: (<span class="type">Int</span>, <span class="type">Resource</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> resource = <span class="keyword">new</span> <span class="type">Resource</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      codeBlock(num, resource)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; println(e)</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      resource.cleanUp()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TopStock</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">Resource</span>.use(<span class="number">10</span>) &#123; (num, resource) =&gt;</span><br><span class="line">      resource.op1(num)</span><br><span class="line">      resource.op2(num)</span><br><span class="line">      resource.op3(num)</span><br><span class="line">      resource.op1(num)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">import</span> java.io._</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeToFile</span></span>(fileName: <span class="type">String</span>)(codeBlock: <span class="type">PrintWriter</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(<span class="keyword">new</span> <span class="type">File</span>(fileName))</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        codeBlock(writer)</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        writer.close()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    writeToFile(<span class="string">"/Users/songchen/output.txt"</span>) &#123;</span><br><span class="line">      writer =&gt;</span><br><span class="line">        writer write <span class="string">"hello from Scala"</span></span><br><span class="line">        writer write <span class="string">"hello from Scala"</span></span><br><span class="line">        writer write <span class="string">"hello from Scala"</span></span><br><span class="line">        writer write <span class="string">"hello from Scala"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="特质"><a href="#特质" class="headerlink" title="特质"></a>特质</h1><p>Java 只允许单继承，这会强制建立一种线性的层次结构模型。但现实世界中充满了横切 关注点(crosscutting concerns)— 一种横切且影响多个抽象的概念，这些抽象并不同属于某个单一的类层次结构 。在典型的企业级应用程序中，安全、日志记录、验证、事务以及资源管理都是这些横切关注点的应用场景。但是，因为我们受限于单一的类层次结构，所以实现这些横切关注点变得相当困难，往往需要代码上的重复或者引入重量级工具 。Scala 使 用特质(trait)解决了这个问题。</p>
<h2 id="理解特质"><a href="#理解特质" class="headerlink" title="理解特质"></a>理解特质</h2><p>将一个 Friend 特质混入任何的类中，如 Man、Woman、Dog 等，而又不必 让所有这些类都继承同一个公共基类。<br>这段代码的一个缺点是“友好”这个特点并不凸显，而且被合并到了 Human 类中。此外， 经过几个星期的开发，我们发现我们忘记了人类最好的朋友。狗是人类的好朋友— 当我们 需要减压时，它们会安静地倾听。但是，在当前的设计中，我们很难让狗成为一个“朋友”。 因为我们不能为此让 Dog 继承 Human。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Friend</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> name: <span class="type">String</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"Your friend <span class="subst">$name</span> is listening"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Human 类混入了 Friend 特质。如果一个类没有扩展任何其他类，则使用 extends 关 键字来混入特质。Human 类以及它的派生类 Man 和 Woman 简单地使用了由 Friend 特质提 供的 listen()方法。你很快将会看到，我们可以按照自己意愿选择重写该方法的实现。</p>
<p>我们可以混入任意数量的特质。如果要混入额外的特质，要使用 with 关键字。如果一个类已 经扩展了另外一个类(如在下一个示例中的 Dog 类)，那么我们也可以使用 with 关键字来混入第一 个特质。除了混入该特质之外，我们还重写了 Dog 类中的 listen()方法(实际上继承自该特质)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">val name: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Animal</span> <span class="keyword">with</span> <span class="title">Friend</span> </span>&#123; <span class="comment">// 选择性重写方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">listen</span></span>(): <span class="type">Unit</span> = println(<span class="string">s"<span class="subst">$name</span>'s listening quietly"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="选择性混入"><a href="#选择性混入" class="headerlink" title="选择性混入"></a>选择性混入</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">useFriend</span></span>(friend: <span class="type">Friend</span>): <span class="type">Unit</span> = friend.listen()</span><br><span class="line"><span class="keyword">val</span> angel = <span class="keyword">new</span> <span class="type">Cat</span>(<span class="string">"Angel"</span>) <span class="keyword">with</span> <span class="type">Friend</span> </span><br><span class="line"><span class="keyword">val</span> friend: <span class="type">Friend</span> = angel angel.listen()</span><br><span class="line">useFriend(angel)</span><br></pre></td></tr></table></figure>

<h2 id="使用特质实现装饰器模式"><a href="#使用特质实现装饰器模式" class="headerlink" title="使用特质实现装饰器模式"></a>使用特质实现装饰器模式</h2><p>在 Scala 中，特质是一个强大的工具，有助于混入横切关注点，而且可以使用它们来创 建轻量的具有高度扩展性的代码。我们可以精简到仅仅使用最基本的、最少的代码来实现这 种设计，而不是创建一个类和接口的层次结构。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Application</span> <span class="keyword">extends</span> <span class="title">Check</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">abstract</span> <span class="title">class</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>: <span class="type">String</span> = <span class="string">"Checked Application Details..."</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">trait</span> <span class="title">CreditCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>: <span class="type">String</span> = <span class="string">s"Checked Credit... <span class="subst">$&#123;super.check&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">trait</span> <span class="title">EmploymentCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>: <span class="type">String</span> = <span class="string">s"Checked Employment...<span class="subst">$&#123;super.check&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">trait</span> <span class="title">CriminalRecordCheck</span> <span class="keyword">extends</span> <span class="title">Check</span> </span>&#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">check</span></span>: <span class="type">String</span> = <span class="string">s"Check Criminal Records...<span class="subst">$&#123;super.check&#125;</span>"</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> apartmentApplication =</span><br><span class="line">      <span class="keyword">new</span> <span class="type">Application</span> <span class="keyword">with</span> <span class="type">CreditCheck</span> <span class="keyword">with</span> <span class="type">CriminalRecordCheck</span></span><br><span class="line">    println(apartmentApplication.check)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特质中的方法延迟绑定"><a href="#特质中的方法延迟绑定" class="headerlink" title="特质中的方法延迟绑定"></a>特质中的方法延迟绑定</h2><p>在上面的例子中，Check 类的 check()方法是具体的。我们的特质扩展自这个类，并 且重写了该方法。我们看到了在该特质中对 super.check()方法的调用是如何绑定到位于 其左侧的特质或者是混入了该特质的类的。如果在基类中方法是抽象的，那么事情就会变得 更复杂一些— 方法绑定必须要推迟到某个具体的方法已知为止。下面让我们更深入地探讨 这一点。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Test12</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeMessage</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">UpperCaseWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">writeMessage</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span> = <span class="keyword">super</span>.writeMessage(message.toUpperCase)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">trait</span> <span class="title">ProfanityFilteredWriter</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">writeMessage</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span> =</span><br><span class="line">      <span class="keyword">super</span>.writeMessage(message.replace(<span class="string">"stupid"</span>, <span class="string">"s-----"</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">StringWriterDelegate</span> <span class="keyword">extends</span> <span class="title">Writer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> writer = <span class="keyword">new</span> java.io.<span class="type">StringWriter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">writeMessage</span></span>(message: <span class="type">String</span>): <span class="type">Unit</span> = writer.write(message)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">toString</span></span>: <span class="type">String</span> = writer.toString</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> myWriterProfanityFirst = <span class="keyword">new</span> <span class="type">StringWriterDelegate</span> <span class="keyword">with</span> <span class="type">UpperCaseWriter</span> <span class="keyword">with</span> <span class="type">ProfanityFilteredWriter</span></span><br><span class="line">    <span class="keyword">val</span> myWriterProfanityLast = <span class="keyword">new</span> <span class="type">StringWriterDelegate</span> <span class="keyword">with</span> <span class="type">ProfanityFilteredWriter</span> <span class="keyword">with</span> <span class="type">UpperCaseWriter</span></span><br><span class="line">    myWriterProfanityFirst writeMessage <span class="string">"There is no sin except stupidity"</span></span><br><span class="line">    myWriterProfanityLast writeMessage <span class="string">"There is no sin except stupidity"</span></span><br><span class="line">    println(myWriterProfanityFirst)</span><br><span class="line">    println(myWriterProfanityLast)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h1><h2 id="常见的-Scala-集合"><a href="#常见的-Scala-集合" class="headerlink" title="常见的 Scala 集合"></a>常见的 Scala 集合</h2><p>Scala 有 3 种主要的集合类型:</p>
<ul>
<li>List— 有序的对象集合</li>
<li>Set— 无序的集合</li>
<li>Map— 键值对字典</li>
</ul>
<p>Scala 推崇不可变集合，尽管也可以使用可变版本。如果想要修改集合，而且集合上所有 的操作都在单线程中进行，那么就可以选择可变集合。</p>
<h2 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h2><p>如果我们只是想更新从 feeds1 中选择的 feed，如所有包含有“blog”这个词的，那么 我们可以使用 filter()方法来获取这些 feed。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> blogFeeds = feeds1 filter (_ contains <span class="string">"blog"</span>) </span><br><span class="line">println(<span class="string">s"blog feeds: <span class="subst">$&#123;blogFeeds.mkString(", ")&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>我们将会得到如下输出:<br>blog feeds: blog.toolshed.com, blog.agiledeveloper.com</p>
<p>如果要合并两个 Set 的 feed 来创建一个新的 Set，那么我们可以使用++()方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> mergedFeeds = feeds1 ++ feeds2</span><br><span class="line">println(<span class="string">s"# of merged feeds: <span class="subst">$&#123;mergedFeeds.size&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>执行求交集操作(即调用&amp;()方法):</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> commonFeeds = feeds1 &amp; feeds2</span><br><span class="line">println(<span class="string">s"common feeds: <span class="subst">$&#123;commonFeeds.mkString(", ")&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>在每个 feed 的前面加上一个“http://”字符串前缀，我们可以使用 map()方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> urls = feeds1 map (<span class="string">"http://"</span> + _) </span><br><span class="line">println(<span class="string">s"One url: <span class="subst">$&#123;urls.head&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="关联映射"><a href="#关联映射" class="headerlink" title="关联映射"></a>关联映射</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> feeds = <span class="type">Map</span>(</span><br><span class="line"><span class="string">"Andy Hunt"</span> -&gt; <span class="string">"blog.toolshed.com"</span>,</span><br><span class="line"><span class="string">"Dave Thomas"</span> -&gt; <span class="string">"pragdave.me"</span>,</span><br><span class="line"><span class="string">"NFJS"</span> -&gt; <span class="string">"nofluffjuststuff.com/blog"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>过滤key值</strong>：如果想要得到一个 feed 的 Map，其中 feed 的作者名开头都为“D”，那么我们可以使用 filterKeys()方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filterNameStartWithD = feeds filterKeys (_ startsWith <span class="string">"D"</span>) </span><br><span class="line">println(<span class="string">s"# of Filtered: <span class="subst">$&#123;filterNameStartWithD.size&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p><strong>过滤key和值</strong>：想要对这些值进行筛选，那么除对键进行操作之外，我们还可以使用 filter() 方法。提供给 filter()方法的函数值接收一个(键，值)元组，我们可以像下面这样使 用它:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> filterNameStartWithDAndPragprogInFeed = feeds filter &#123; element =&gt; <span class="keyword">val</span> (key, value) = element</span><br><span class="line">(key startsWith <span class="string">"D"</span>) &amp;&amp; (value contains <span class="string">"pragdave"</span>)</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"# of feeds with auth name D* and pragdave in URL: "</span>) println(filterNameStartWithDAndPragprogInFeed.size)</span><br></pre></td></tr></table></figure>

<p><strong>更新map</strong>：要添加 feed，请使用 updated()方法。因为我们使用的是不可变集合，所以 updated() 方法不会影响原来的 Map。如同其方法名所提示的一样，它会返回一个携带着新元素的全新 Map。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> newFeeds1 = feeds.updated(<span class="string">"Venkat Subramaniam"</span>, <span class="string">"blog.agiledeveloper.com"</span>)</span><br><span class="line">println(<span class="string">"Venkat's blog in original feeds: "</span> + feeds.get(<span class="string">"Venkat Subramaniam"</span>))</span><br><span class="line">println(<span class="string">"Venkat's blog in new feed: "</span> + newFeeds1(<span class="string">"Venkat Subramaniam"</span>))</span><br></pre></td></tr></table></figure>
<p>X() = b 等价于 X.updated(b)</p>
<h2 id="不可变列表"><a href="#不可变列表" class="headerlink" title="不可变列表"></a>不可变列表</h2><p>通过使用 head 方法，Scala 使访问一个列表的第一个元素更加简单快速。使用 tail 方 法，可以访问除第一个元素之外的所有元素。访问列表中的最后一个元素需要对列表进行遍 历，因此相比访问列表的头部和尾部1，该操作更加昂贵。所以，列表上的大多数操作都是 围绕着对头部和尾部的操作构造的。</p>
<p><strong>插入对象</strong>：如果我们想要前插一个元素，即将一个元素放在当前 List 的前面，我们可以使用特殊 的::()方法。a :: list读作“将a前插到list”</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> prefixedList = <span class="string">"forums.pragprog.com/forums/87"</span> :: feeds </span><br><span class="line">println(<span class="string">s"First Feed In Prefixed: <span class="subst">$&#123;prefixedList.head&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p><strong>插入列表</strong>：假设我们想要追加一个列表到另外一个列表，例如，将 listA 追加到另外一个列表list。那么我们可以使用:::()方法将 list 实际上前插到 listA。因此，代码应该是list ::: listA，并读作“将list前插到listA”。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> feedsWithForums = feeds ::: <span class="type">List</span>(<span class="string">"forums.pragprog.com/forums/87"</span>,<span class="string">"forums.pragprog.com/forums/246"</span>)</span><br><span class="line">println(<span class="string">s"First feed in feeds with forum: <span class="subst">$&#123;feedsWithForums.head&#125;</span>"</span>) </span><br><span class="line">println(<span class="string">s"Last feed in feeds with forum: <span class="subst">$&#123;feedsWithForums.last&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>

<p>满足某些条件的 feed，应该使用 filter()方法。如果我们想要检查是 否所有的 feed 都满足某个特定的条件，则可以使用 forall()方法。另外，如果我们想要知 道是否有任意 feed 满足某一条件，那么 exists()方法可以帮到我们</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="string">s"Feeds with blog: <span class="subst">$&#123;feeds.filter(_ contains "blog").mkString(", ")&#125;</span>"</span>) </span><br><span class="line">println(<span class="string">s"All feeds have com: <span class="subst">$&#123;feeds.forall(_ contains "com")&#125;</span>"</span>) </span><br><span class="line">println(<span class="string">s"All feeds have dave: <span class="subst">$&#123;feeds.forall(_ contains "dave")&#125;</span>"</span>) </span><br><span class="line">println(<span class="string">s"Any feed has dave: <span class="subst">$&#123;feeds.exists(_ contains "dave")&#125;</span>"</span>) </span><br><span class="line">println(<span class="string">s"Any feed has bill: <span class="subst">$&#123;feeds.exists(_ contains "bill")&#125;</span>"</span>)</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>Feeds with blog: blog.toolshed.com, blog.agiledeveloper.com<br>All feeds have com: false<br>All feeds have dave: false<br>Any feed has dave: true<br>Any feed has bill: false</p>
<p><strong>foldLeft()方法</strong>，如下所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> total = feeds.foldLeft(<span class="number">0</span>) &#123; (total, feed) =&gt; total + feed.length &#125; </span><br><span class="line">println(<span class="string">s"Total length of feed urls: <span class="subst">$total</span>"</span>)</span><br></pre></td></tr></table></figure>


<h1 id="模式匹配和正则表达式"><a href="#模式匹配和正则表达式" class="headerlink" title="模式匹配和正则表达式"></a>模式匹配和正则表达式</h1><p>学到 Scala 的模式匹配的机制、case 类和提取器，以 及如何创建和使用正则表达式。</p>
<h2 id="模式匹配综述"><a href="#模式匹配综述" class="headerlink" title="模式匹配综述"></a>模式匹配综述</h2><p>Scala 的模式匹配非常灵活，可以匹配字面量和常量，以及使用通配符匹配任意的值、元 组和列表，甚至还可以根据类型以及判定守卫来进行匹配。接下来我们就来逐个探索一下这 些应用方式。</p>
<h3 id="匹配字面量和常量"><a href="#匹配字面量和常量" class="headerlink" title="匹配字面量和常量"></a>匹配字面量和常量</h3><p>match 语句是一个在 Any 上进行的表达式。在这个例子中，我们将其应用到了 String 上。它将在目标上进行模式匹配，并使用模式匹配的值调用适当的 case 表达式。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activity</span> </span>(day: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">  day <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Sunday"</span> =&gt; print (<span class="string">"Eat, sleep, repeat... "</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Saturday"</span> =&gt; print (<span class="string">"Hang out with friends... "</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Monday"</span> =&gt; print (<span class="string">"...code for fun..."</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">"Friday"</span> =&gt; print (<span class="string">"...read a good book..."</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">List</span> (<span class="string">"Monday"</span>, <span class="string">"Sunday"</span>, <span class="string">"Saturday"</span>).foreach &#123;</span><br><span class="line">  activity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="匹配通配符"><a href="#匹配通配符" class="headerlink" title="匹配通配符"></a>匹配通配符</h3><p>使用下划线(_)表示的通配符处理其他工作日。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">DayOfWeek</span> <span class="keyword">extends</span> <span class="title">Enumeration</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SUNDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Sunday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MONDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Monday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">TUESDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Tuesday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">WEDNESDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Wednesday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">THURSDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Thursday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">FRIDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Friday"</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">SATURDAY</span>: <span class="type">DayOfWeek</span>.<span class="type">Value</span> = <span class="type">Value</span>(<span class="string">"Saturday"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activity</span></span>(day: <span class="type">DayOfWeek</span>.<span class="type">Value</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    day <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">DayOfWeek</span>.<span class="type">SUNDAY</span> =&gt; println(<span class="string">"Eat, sleep, repeat..."</span>)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">DayOfWeek</span>.<span class="type">SATURDAY</span> =&gt; println(<span class="string">"Hang out with friends"</span>)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt; println(<span class="string">"...code for fun..."</span>)</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br><span class="line">activity(<span class="type">DayOfWeek</span>.<span class="type">SATURDAY</span>) </span><br><span class="line">activity(<span class="type">DayOfWeek</span>.<span class="type">MONDAY</span>)</span><br></pre></td></tr></table></figure>

<h3 id="匹配元组和列表"><a href="#匹配元组和列表" class="headerlink" title="匹配元组和列表"></a>匹配元组和列表</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processCoordinates</span></span>(input: <span class="type">Any</span>): <span class="type">Unit</span> = &#123; input <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> (lat, long) =&gt; printf(<span class="string">"Processing (%d, %d)..."</span>, lat, long) <span class="keyword">case</span> <span class="string">"done"</span> =&gt; println(<span class="string">"done"</span>)</span><br><span class="line">  <span class="keyword">case</span> _ =&gt; println(<span class="string">"invalid input"</span>)</span><br><span class="line">&#125; &#125;</span><br><span class="line">processCoordinates((<span class="number">39</span>, <span class="number">-104</span>)) </span><br><span class="line">processCoordinates(<span class="string">"done"</span>)</span><br></pre></td></tr></table></figure>

<p>可以用匹配元组的方式来对 List 进行模式匹配，只需要提供你关心的元素即可，而 对于剩下的元素可以使用数组展开(array explosion)标记(_*)。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processItems</span></span>(items: <span class="type">List</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123; items <span class="keyword">match</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"ibm"</span>) =&gt; println(<span class="string">"Apples and IBMs"</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"white"</span>) =&gt; println(<span class="string">"Stars and Stripes..."</span>)</span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, _*) =&gt; println(<span class="string">"colors red, blue,... "</span>) </span><br><span class="line">  <span class="keyword">case</span> <span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"orange"</span>, otherFruits @ _*) =&gt;</span><br><span class="line">    println(<span class="string">"apples, oranges, and "</span> + otherFruits) &#125;</span><br><span class="line">&#125;</span><br><span class="line">processItems(<span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"ibm"</span>)) </span><br><span class="line">processItems(<span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>))</span><br><span class="line">processItems(<span class="type">List</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"white"</span>)) </span><br><span class="line">processItems(<span class="type">List</span>(<span class="string">"apple"</span>, <span class="string">"orange"</span>, <span class="string">"grapes"</span>, <span class="string">"dates"</span>))</span><br></pre></td></tr></table></figure>

<h2 id="使用-case-类进行模式匹配"><a href="#使用-case-类进行模式匹配" class="headerlink" title="使用 case 类进行模式匹配"></a>使用 case 类进行模式匹配</h2><p>case 类是特殊的类，可以使用 case 表达式来进行模式匹配。case 类很简洁，并且容 易创建，它将其构造参数都公开为值。可以使用 case 类来创建轻量级值对象，或者类名和 属性名都富有意义的数据持有者。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Trade</span></span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Sell</span>(<span class="params">stockSymbol: <span class="type">String</span>, quantity: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Trade</span> </span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Buy</span>(<span class="params">stockSymbol: <span class="type">String</span>, quantity: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Trade</span> </span></span><br><span class="line"><span class="class"><span class="title">case</span> <span class="title">class</span> <span class="title">Hdge</span>(<span class="params">stockSymbol: <span class="type">String</span>, quantity: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Trade</span></span></span><br></pre></td></tr></table></figure>

<p>使用class进行模式匹配</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TradeProcessor</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">processTransaction</span></span>(request: <span class="type">Trade</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    request <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sell</span>(stock, <span class="number">1000</span>) =&gt; println(<span class="string">s"Selling 1000-units of <span class="subst">$stock</span>"</span>) </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Sell</span>(stock, quantity) =&gt; println(<span class="string">s"Selling <span class="subst">$quantity</span> units of <span class="subst">$stock</span>"</span>) </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Buy</span>(stock, quantity) <span class="keyword">if</span> quantity &gt; <span class="number">2000</span> =&gt; println(<span class="string">s"Buying <span class="subst">$quantity</span> (large) units of <span class="subst">$stock</span>"</span>) </span><br><span class="line">        <span class="keyword">case</span> <span class="type">Buy</span>(stock, quantity) =&gt; println(<span class="string">s"Buying <span class="subst">$quantity</span> units of <span class="subst">$stock</span>"</span>) &#125;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="提取器和正则表达式"><a href="#提取器和正则表达式" class="headerlink" title="提取器和正则表达式"></a>提取器和正则表达式</h2><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(input: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"><span class="keyword">val</span> <span class="type">GoogStock</span> = <span class="string">""</span><span class="string">"^GOOG:(\d*\.\d+)"</span><span class="string">""</span>.r </span><br><span class="line">input <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">GoogStock</span>(price) =&gt; println(<span class="string">s"Price of GOOG is $$<span class="subst">$price</span>"</span>)</span><br><span class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">s"not processing <span class="subst">$input</span>"</span>) &#125;</span><br><span class="line">&#125; </span><br><span class="line">process(<span class="string">"GOOG:310.84"</span>) </span><br><span class="line">process(<span class="string">"GOOG:310"</span>) </span><br><span class="line">process(<span class="string">"IBM:84.01"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="无处不在的下划线字符"><a href="#无处不在的下划线字符" class="headerlink" title="无处不在的下划线字符"></a>无处不在的下划线字符</h2><ul>
<li>作为包引入的通配符。例如，在Scala中import java.util._等同于Java中的 import java.util.*。</li>
<li>作为元组索引的前缀。对于给定的一个元组val names = (“Tom”, “Jerry”)， 可以使用 names._1 和 names._2 来分别索引这两个值。</li>
<li>作为函数值的隐式参数。代码片段list.map { _ * 2 }和list.map { e =&gt; e * 2 }是等价的。同样，代码片段 list.reduce { _ + _ }和 list.reduce { (a, b) =&gt; a + b }也是等价的。</li>
<li>用于用默认值初始化变量。例如，var min : Int = _将使用0初始化变量min， 而var msg : String = _将使用null初始化变量msg。</li>
<li>用于在函数名中混合操作符。你应该还记得，在Scala中，操作符被定义为方法。例如，用于将元素前插到一个列表中的::()方法。Scala 不允许直接使用字母和数字字 符的操作符。例如，foo:是不允许的，但是可以通过使用下划线来绕过这个限制， 如 foo_:。</li>
<li>在进行模式匹配时作为通配符。case <em>将会匹配任意给定的值，而 case _:Int 将匹配任何整数。此外，case <people>{</people></em>*}将会匹配名为 people 的 XML 元素，其具有 0 个或者多个子元素。</li>
<li>在处理异常时，在catch代码块中和case联用。</li>
<li>作为分解操作的一部分。例如，max(arg: _*)在将数组或者列表参数传递给接受可变长度参数的函数前，将其分解为离散的值。</li>
<li>用于部分应用一个函数。例如，在代码片段val square = Math.pow(_: Int,2)中，我们部分应用了 pow()方法来创建了一个 square()函数。</li>
</ul>
<h1 id="处理异常"><a href="#处理异常" class="headerlink" title="处理异常"></a>处理异常</h1><h2 id="Scala-中的异常"><a href="#Scala-中的异常" class="headerlink" title="Scala 中的异常"></a>Scala 中的异常</h2><p>try catch标准用法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  print(<span class="string">s"Amount: $$<span class="subst">$amount</span> "</span>)</span><br><span class="line">  println(<span class="string">s"Tax: $$<span class="subst">$&#123;Tax.taxFor(amount)&#125;</span>"</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">IllegalArgumentException</span> =&gt; println(ex.getMessage)</span><br><span class="line">  <span class="keyword">case</span> ex: <span class="type">RuntimeException</span> =&gt;</span><br><span class="line">    <span class="comment">// 如果需要一段代码来处理异常</span></span><br><span class="line">    println(<span class="string">s"Don't bother reporting...<span class="subst">$&#123;ex.getMessage&#125;</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意-catch-的顺序"><a href="#注意-catch-的顺序" class="headerlink" title="注意 catch 的顺序"></a>注意 catch 的顺序</h2><p>在Scala中，用于catch代码块的模式匹配代码将按照它们被编写顺序生效。可惜的是， 如果前面的语句处理了你本打算在后面的语句中处理的异常，Scala 并不会警告你。我们可以 在下面的示例中看到这一点。</p>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>一般来说，递归最大的问题是大规模的输入值会造成栈溢出。但幸运的是，在 Scala 中可以 使用特殊构造的递归来规避这个问题。在本章中，我们将分别探讨强大的尾调用优化(tail call optimization)技术以及 Scala 标准库中的相关支持类。使用这些易于访问的工具，就可以在高度递归的算法实现中既可以处理大规模的输入值又能同时规避栈溢出(即触发 StackOverflowError)的风险。</p>
<h2 id="使用尾部调用优化回调"><a href="#使用尾部调用优化回调" class="headerlink" title="使用尾部调用优化回调"></a>使用尾部调用优化回调</h2><p>所有支持递归的编程语言都支持尾调用优化。例如，Java 就不支持尾调用优化，所有 的递归，不管是不是尾部调用，都注定会在输入大值时栈溢出。Scala 则很容易支持尾调用优化。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mad</span></span>(parameter: <span class="type">Int</span>): <span class="type">Int</span> = &#123; </span><br><span class="line">    <span class="keyword">if</span> (parameter == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Error"</span>) </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="number">1</span> * mad(parameter - <span class="number">1</span>) </span><br><span class="line">&#125;</span><br><span class="line">mad(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<p>我们改造一下 mad()函数，去除多余的乘 1 操作。这将使调用在尾部递归— 对函数的 调用在最后，即在尾部。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mad</span></span>(parameter: <span class="type">Int</span>): <span class="type">Int</span> = &#123; <span class="keyword">if</span> (parameter == <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">RuntimeException</span>(<span class="string">"Error"</span>) <span class="keyword">else</span></span><br><span class="line">  mad(parameter - <span class="number">1</span>) &#125;</span><br><span class="line">mad(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h2 id="scala确保尾调用优化"><a href="#scala确保尾调用优化" class="headerlink" title="scala确保尾调用优化"></a>scala确保尾调用优化</h2><p>还好 Scala 提供了一个注解，辅助尾递归的编写。可以用 tailrec 注解标记任何函数， Scala 会在编译时检查函数是否是尾递归的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.tailrec</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(number: <span class="type">Int</span>): <span class="type">BigInt</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (number == <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    number * factorial(number - <span class="number">1</span>)</span><br><span class="line">&#125; </span><br><span class="line">println(factorial(<span class="number">10000</span>))</span><br></pre></td></tr></table></figure>

<p>因为这个版本的 factorial()函数是常规递归，而不是尾递归，因此编译器会报一个 恰当的错误:<br>error: could not optimize @tailrec annotated method factorial: it contains a recursive call not in tail position<br>    number * factorial(number - 1) ^<br>error found</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@scala</span>.annotation.tailrec</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(fact: <span class="type">BigInt</span>, number: <span class="type">Int</span>): <span class="type">BigInt</span> = &#123; </span><br><span class="line">    <span class="keyword">if</span> (number == <span class="number">0</span>)</span><br><span class="line">        fact </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        factorial(fact * number, number - <span class="number">1</span>) </span><br><span class="line">&#125;</span><br><span class="line">println(factorial(<span class="number">1</span>, <span class="number">10000</span>))</span><br></pre></td></tr></table></figure>
<p>修改后的 factorial()函数接收两个参数，其中第一个参数 fact 是已经计算出来的 部分结果。对 factorial()函数的递归调用发生在尾部，符合函数头部的注解。在做了这 样的更改之后，Scala 就不会报错，而会在调用中做优化。</p>
<h2 id="蹦床调用"><a href="#蹦床调用" class="headerlink" title="蹦床调用"></a>蹦床调用</h2><p>尽管 Scala 中的尾调用优化非常强大，但也有诸多限制。编译器只能够检测到直接的递 归，也就是说函数调用自己。如果两个函数相互调用，也就是蹦床调用(trampoline call)， 那么 Scala 就无法检测到这种递归，也不会做优化。<br>用@scala.annotation.tailrec 去标记例子中的函数不会有效果— 你将会得到 错误提示，表明这些函数都不是递归的。Scala 编译器无法识别跨方法的递归。<br>像这种函数间相互调用产生的递归，我们可以用 TailRec 类和 scala.util.control. TailCalls 包中的可用函数解决。<br>TailRec 的实例将会保存函数值(参见第 6 章)。TailRec 中的 result()函数是一个 简单的迭代器或者说是循环。它会取出保存在 TailRec 中的内部函数，检查它是不是子类 Call 或者 Done 的实例。如果是 Call 的实例，那么它会发信号通知调用继续执行，迭代会 继续执行内部函数以便做进一步的处理。如果是 Done 的实例，那么它会发信号通知迭代终 止，并将内部函数中留存的结果返回。</p>


    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/software-programming/">software programming</a>
      
        <a href="/tags/scala/">scala</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
    <div class='post-wrapper'>
      <article class="post reveal">
  <section class="meta">
    
    <h2 class="title">
      <a href="/2020/01/02/----81/">
        Scala实用指南读书笔记（一）
      </a>
    </h2>
    
    <time>
      1月 2, 2020
    </time>
		
    
    <div class='cats'>
        <a href="/categories/professional-skill/">professional skill</a>
    </div>

  </section>
  <section class="article typo">
	  <p>第一部分 小试牛刀<br>Scala 是一门强大的编程语言:不需要牺牲强大的静态类型检查支持，就可以写出富有表 现力而又简洁的代码。</p>
<h1 id="探索scala"><a href="#探索scala" class="headerlink" title="探索scala"></a>探索scala</h1><h2 id="scala的特殊性"><a href="#scala的特殊性" class="headerlink" title="scala的特殊性"></a>scala的特殊性</h2><p>scala的关键特性信息：</p>
<ul>
<li>同时支持命令式风格和函数式风格</li>
<li>纯面向对象</li>
<li>强制合理的静态类型和类型推断</li>
<li>简洁而富有表现力</li>
<li>能和 Java 无缝地互操作</li>
<li>基于精小的内核构建</li>
<li>高度的伸缩性，仅用少量代码就可以创建高性能的应用程序</li>
<li>具有强大、易用的并发模型</li>
</ul>
<h2 id="以少胜多"><a href="#以少胜多" class="headerlink" title="以少胜多"></a>以少胜多</h2><p>用更少的代码解决更多的问题 — 简化日常编程<br>筛选出内部最高价格的股票</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span>(<span class="params">year: <span class="type">Int</span>, month: <span class="type">Int</span>, date: <span class="type">Int</span>, closePrice: <span class="type">BigDecimal</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">object</span> <span class="title">PrintMax</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getYearEndClosingPrice</span></span>(symbol: <span class="type">String</span>, year: <span class="type">Int</span>): <span class="type">BigDecimal</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> url = <span class="string">s"https://raw.githubusercontent.com/ReactivePlatform/"</span> +</span><br><span class="line">      <span class="string">s"Pragmatic-Scala-StaticResources/master/src/main/resources/"</span> + <span class="string">s"stocks/daily/daily_<span class="subst">$symbol</span>.csv"</span></span><br><span class="line">    <span class="keyword">val</span> data = io.<span class="type">Source</span>.fromURL(url).mkString</span><br><span class="line">    <span class="keyword">val</span> maxClosePrize = data.split(<span class="string">"\n"</span>)</span><br><span class="line">      .filter(record =&gt; record.startsWith(<span class="string">s"<span class="subst">$year</span>-12"</span>)).map(record =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(timestamp, open, high, low, close, volume) = record.split(<span class="string">","</span>)</span><br><span class="line">      <span class="keyword">val</span> <span class="type">Array</span>(year, month, date) = timestamp.split(<span class="string">"-"</span>)</span><br><span class="line">      <span class="type">Record</span>(year.toInt, month.toInt, date.toInt, <span class="type">BigDecimal</span>(close.trim))</span><br><span class="line">    &#125;).sortBy(_.date)(<span class="type">Ordering</span>[<span class="type">Int</span>].reverse).take(<span class="number">1</span>)</span><br><span class="line">      .map(_.closePrice)</span><br><span class="line">      .head</span><br><span class="line">    maxClosePrize</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> symbols = <span class="type">List</span>(<span class="string">"AMD"</span>, <span class="string">"AAPL"</span>)</span><br><span class="line">    <span class="keyword">val</span> year = <span class="number">2017</span></span><br><span class="line">    <span class="keyword">val</span> (topStock, topPrice) = symbols.par.map &#123; ticker =&gt; (ticker, getYearEndClosingPrice(ticker, year)) &#125;</span><br><span class="line">      .maxBy &#123; stockPrice =&gt; stockPrice._2 &#125;</span><br><span class="line">    printf(<span class="string">s"Top stock of <span class="subst">$year</span> is <span class="subst">$topStock</span> closing at price $$<span class="subst">$topPrice</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个功能强大的专用迭代器— map() 函数和 maxBy()函数。在 Java 中，我们习惯用“方法”这个术语来指代类的成员，而“函 数”这个术语通常用于指代不属于类的过程(procedure)。然而，在 Scala 中这两个术语可交 换使用。</p>
<p>这两个迭代器分别行使了两种独立的职责。首先，我们使用 map()函数遍历股票代码， 以创建一个由股票代码及其 2017 年收盘价格组成的“对”或“元组”为元素的列表。最终结 果的元组列表形式为 List((股票代码 1，价格 1)，(股票代码 2，价格 2)，…)。</p>

    
	  <div class="readmore">
      <a href="/2020/01/02/----81/">Read More</a>
    </div>
    
    
    
	  <div class="full-width auto-padding tags">
      
        <a href="/tags/software-programming/">software programming</a>
      
        <a href="/tags/scala/">scala</a>
      
	  </div>
    
  </section>
</article>
    </div>
  
</section>


      </div>
      <aside class='l_side'>
        
  <section class='m_widget about'>

<img class='avatar waves-image' src='/images/avatar.jpg' />

<div class='header'>bon爸</div>
<div class='content'>
<div class='desc'>成为世界的基石 ...</div>
</div>
</section>


  <section class='m_widget links'>
<div class='header'>Links</div>
<div class='content'>
    <ul class="entry">
    
        <li><a class="flat-box" target="_blank" href="https://github.com/bondaddy">
            <div class='name'>github</div>
        </a></li>
    
    </ul>
</div>
</section>

  <section class='m_widget categories'>
<div class='header'>Categories</div>
<div class='content'>
    
    <ul class="entry">
    
        <li><a class="flat-box" href="/categories/blog/"><div class='name'>blog</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/professional-skill/"><div class='name'>professional skill</div><div class='badget'>2</div></a></li>
    
        <li><a class="flat-box" href="/categories/qzone/"><div class='name'>qzone</div><div class='badget'>79</div></a></li>
    
    </ul>
    
</div>
</section>

  
<div class="m_widget tagcloud">
    <div class="header">Tags</div>
    <div class='content'>
        <a href="/tags/mood/" style="font-size: 14px; color: #808080">mood</a> <a href="/tags/qzone/" style="font-size: 20px; color: #000">qzone</a> <a href="/tags/scala/" style="font-size: 14px; color: #808080">scala</a> <a href="/tags/software-programming/" style="font-size: 14px; color: #808080">software programming</a>
    </div>
</div>



      </aside>
      <script>setLoadingBarProgress(60);</script>
    </div>
  </div>
  <footer id="footer" class="clearfix">

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/bondaddy" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
        <a href="/atom.xml" class="social rss"
          target="_blank" rel="external">
          <span class="icon icon-rss"></span>
        </a>
      
    
  </div>
</footer>


  <script>setLoadingBarProgress(80);</script>
  

<script src="//apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
<script src='//cdn.bootcss.com/node-waves/0.7.5/waves.min.js'></script>
<script src="//cdn.bootcss.com/scrollReveal.js/3.3.2/scrollreveal.min.js"></script>

<script src="/js/jquery.fitvids.js"></script>

<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "hexo";
  var ROOT = "/"||"/";
  if(!ROOT.endsWith('/'))ROOT += '/';
</script>

<script src="/js/search.js"></script>


<script src="/js/app.js"></script>



  <script>setLoadingBarProgress(100);</script>
</body>
</html>
